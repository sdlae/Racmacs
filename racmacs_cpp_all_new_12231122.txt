

# ================================================
# FILE: src/ac_bootstrap_output.h
# ================================================


#include <RcppArmadillo.h>

#ifndef Racmacs__ac_bootstrap_output__h
#define Racmacs__ac_bootstrap_output__h

struct BootstrapOutput
{
  arma::vec sampling;
  arma::mat coords;
  double stress;
};

#endif


# ================================================
# FILE: src/ac_bootstrap.cpp
# ================================================


#include "acmap_map.h"
#include "acmap_titers.h"
#include "ac_optim_map_stress.h"
#include "ac_bootstrap.h"
#include "ac_optimizer_options.h"

// Function for sampling from a dirichilet
arma::vec rdirichilet(
    arma::uword n
) {

  arma::vec beta_sample = arma::randg<arma::vec>( n );
  return beta_sample / arma::accu(beta_sample);

}

// [[Rcpp::export]]
BootstrapOutput ac_bootstrap_map(
    const AcMap map,
    std::string method,
    bool bootstrap_ags,
    bool bootstrap_sr,
    bool reoptimize,
    double ag_noise_sd,
    double titer_noise_sd,
    std::string minimum_column_basis,
    arma::vec fixed_column_bases,
    arma::vec ag_reactivity_adjustments,
    int num_optimizations,
    int num_dimensions,
    AcOptimizerOptions options
){

  // Fetch titer table
  AcTiterTable titer_table = map.titer_table_flat;
  arma::uword num_ags = titer_table.nags();
  arma::uword num_sr = titer_table.nsr();

  // Declare variables
  arma::vec colbases;
  arma::vec pt_sampling;

  // Add noise to the titer table
  if (method == "noisy") {

    // First a matrix of shared antigen noise
    arma::vec ag_noise = arma::randn<arma::vec>(num_ags)*ag_noise_sd;
    arma::mat ag_noise_matrix(num_ags, num_sr, arma::fill::zeros);
    ag_noise_matrix.each_col() += ag_noise;
    titer_table.add_log_titers(ag_noise_matrix);

    // Then a full matrix of titer noise
    arma::mat titer_noise = arma::randn<arma::mat>(num_ags, num_sr)*titer_noise_sd;
    titer_table.add_log_titers(titer_noise);

    // Save ag weights into point weights
    arma::vec sr_noise = arma::vec(num_sr, arma::fill::zeros);
    pt_sampling = arma::join_cols(ag_noise, sr_noise);

  }

  // Get column bases (after setting any noise)
  colbases = titer_table.calc_colbases(
    minimum_column_basis,
    fixed_column_bases,
    ag_reactivity_adjustments
  );

  // Set antigen and sera weights
  arma::vec ag_weights = arma::vec(num_ags, arma::fill::ones);
  arma::vec sr_weights = arma::vec(num_sr, arma::fill::ones);

  // Set weights according to a random resample
  if (method == "resample") {

    if (bootstrap_ags) {
      ag_weights.zeros();
      arma::uvec ag_sample = arma::randi<arma::uvec>(num_ags, arma::distr_param(0, num_ags - 1));
      for (arma::uword i=0; i<num_ags; i++) ag_weights(ag_sample(i)) += 1.0;
    }

    if (bootstrap_sr) {
      sr_weights.zeros();
      arma::uvec sr_sample = arma::randi<arma::uvec>(num_sr, arma::distr_param(0, num_sr - 1));
      for (arma::uword i=0; i<num_sr; i++) sr_weights(sr_sample(i)) += 1.0;
    }

    // Save into point weights
    pt_sampling = arma::join_cols(ag_weights, sr_weights);

  }

  // Set weights according to a dirichilet distribution
  if (method == "bayesian") {

    if (bootstrap_ags) ag_weights = rdirichilet(num_ags);
    if (bootstrap_sr) sr_weights = rdirichilet(num_sr);

    // Save into point weights
    pt_sampling = arma::join_cols(ag_weights, sr_weights);

  }

  // Calculate titer weights
  arma::mat titer_weights = arma::mat(num_ags, num_sr, arma::fill::ones);
  titer_weights.each_row() %= sr_weights.as_row();
  titer_weights.each_col() %= ag_weights.as_col();

  // Set variables
  double stress;
  arma::mat ag_coords;
  arma::mat sr_coords;
  if (reoptimize) { // If reoptimizing from scratch

    // Run the optimization
    std::vector<AcOptimization> optimizations;
    optimizations = ac_runOptimizations(
      titer_table,
      minimum_column_basis,
      fixed_column_bases,
      ag_reactivity_adjustments,
      num_dimensions,
      num_optimizations,
      options,
      titer_weights,
      map.dilution_stepsize
    );

    // Sort by stress and keep lowest stress coords
    sort_optimizations_by_stress(optimizations);
    ag_coords = optimizations.at(0).agCoords();
    sr_coords = optimizations.at(0).srCoords();
    stress = optimizations.at(0).stress;

  } else { // If simply relaxing the map

    ag_coords = map.optimizations.at(0).agCoords();
    sr_coords = map.optimizations.at(0).srCoords();

    stress = ac_relax_coords(
      titer_table.numeric_table_distances(
        minimum_column_basis,
        fixed_column_bases,
        ag_reactivity_adjustments
      ),
      titer_table.get_titer_types(),
      ag_coords,
      sr_coords,
      options,
      arma::uvec(), // Fixed ags
      arma::uvec(), // Fixed sera
      titer_weights,
      map.dilution_stepsize
    );

  }

  // Set coordinates for ag and sr coords weighted 0 to NaN
  for (arma::uword i=0; i<num_ags; i++) if(ag_weights(i) == 0) ag_coords.row(i).fill(arma::datum::nan);
  for (arma::uword i=0; i<num_sr; i++)  if(sr_weights(i) == 0) sr_coords.row(i).fill(arma::datum::nan);

  // Setup for output
  struct BootstrapOutput results{
    pt_sampling,
    arma::join_cols(
      ag_coords,
      sr_coords
    ),
    stress
  };

  // Return results
  return results;

}





# ================================================
# FILE: src/ac_bootstrap.h
# ================================================


#include <RcppArmadillo.h>
#include "acmap_titers.h"
#include "ac_optimizer_options.h"
#include "acmap_map.h"
#include "ac_bootstrap_output.h"

#ifndef Racmacs__ac_bootstrap__h
#define Racmacs__ac_bootstrap__h

BootstrapOutput ac_bootstrap_map(
    AcMap map,
    std::string method,
    bool bootstrap_ags,
    bool bootstrap_sr,
    bool reoptimize,
    double ag_noise_sd,
    double titer_noise_sd,
    std::string minimum_column_basis,
    arma::vec fixed_column_bases,
    arma::vec ag_reactivity_adjustments,
    int num_optimizations,
    int num_dimensions,
    AcOptimizerOptions options
);

#endif


# ================================================
# FILE: src/ac_coords_stress.h
# ================================================


#include <RcppArmadillo.h>
#include "acmap_titers.h"

#ifndef Racmacs__ac_coords_stress__h
#define Racmacs__ac_coords_stress__h

// Calculating stress
double ac_coords_stress(
    const AcTiterTable &titers,
    const std::string &min_colbasis,
    const arma::vec &fixed_colbases,
    const arma::vec &ag_reactivity_adjustments,
    arma::mat &ag_coords,
    arma::mat &sr_coords,
    double dilution_stepsize
);

#endif


# ================================================
# FILE: src/ac_dimension_test.cpp
# ================================================


#include "acmap_map.h"
#include "acmap_titers.h"
#include "ac_optim_map_stress.h"
#include "ac_dimension_test.h"
#include "ac_optimizer_options.h"

// [[Rcpp::export]]
DimTestOutput ac_dimension_test_map(
  AcTiterTable titer_table,
  arma::uvec dimensions_to_test,
  double test_proportion,
  std::string minimum_column_basis,
  arma::vec fixed_column_bases,
  arma::vec ag_reactivity_adjustments,
  int num_optimizations,
  AcOptimizerOptions options
) {

  // Silence normal optimization progress reporting
  options.report_progress = false;

  // Get a random index of measured titers to test
  int num_measured = titer_table.num_measured();
  int num_test = round(num_measured*test_proportion);

  arma::uvec indices_measured = titer_table.vec_indices_measured();
  arma::uvec sample = arma::randperm( num_measured, num_test );
  arma::uvec indices_test = indices_measured.elem( sample );
  arma::umat indices_test_mat = arma::ind2sub( titer_table.size(), indices_test );

  // Set test indices to unmeasured
  titer_table.set_unmeasured(indices_test);

  // Get column bases after setting don't cares if not setting from full table
  arma::vec colbases = titer_table.calc_colbases(
    minimum_column_basis,
    fixed_column_bases,
    ag_reactivity_adjustments
  );

  // Setup for output
  struct DimTestOutput results = {
    indices_test,
    dimensions_to_test,
    std::vector<arma::mat>(dimensions_to_test.n_elem),
    std::vector<arma::vec>(dimensions_to_test.n_elem)
  };

  // Run the optimization for each set of dimensions
  std::vector<AcOptimization> optimizations;
  arma::vec predicted_titers(indices_test.n_elem);
  for(arma::uword i = 0; i < dimensions_to_test.n_elem; i++){

    // Check for user interrupt
    Rcpp::checkUserInterrupt();

    // Get optimizations
    optimizations = ac_runOptimizations(
      titer_table,
      minimum_column_basis,
      fixed_column_bases,
      ag_reactivity_adjustments,
      dimensions_to_test(i),
      num_optimizations,
      options
    );

    // Sort by stress and keep lowest stress coords
    sort_optimizations_by_stress(optimizations);

    // Work out predicted titers for each of the test cases
    for(arma::uword j=0; j<predicted_titers.n_elem; j++){
      double dist = optimizations.at(0).ptDist(
        indices_test_mat(0,j),
        indices_test_mat(1,j)
      );
      double colbase = colbases(indices_test_mat(1,j));
      predicted_titers[j] = colbase - dist;
    }

    // Store results
    arma::mat ptcoords = optimizations.at(0).ptCoords();
    results.coords.at(i) = ptcoords;
    results.predictions.at(i) = predicted_titers;

  }

  // Return results
  return results;

}




# ================================================
# FILE: src/ac_dimension_test.h
# ================================================


#include <RcppArmadillo.h>
#include "acmap_titers.h"
#include "ac_optimizer_options.h"

#ifndef Racmacs__ac_dimension_test__h
#define Racmacs__ac_dimension_test__h

struct DimTestOutput
{
  arma::uvec test_indices;
  arma::uvec dim;
  std::vector<arma::mat> coords;
  std::vector<arma::vec> predictions;
};

#endif


# ================================================
# FILE: src/ac_errorlines.cpp
# ================================================


# include <RcppArmadillo.h>
# include "ac_errorlines.h"
# include "acmap_map.h"
# include "ac_optim_map_stress.h"

// For merging character titers
// [[Rcpp::export]]
ErrorLineData ac_errorline_data(const AcMap& map){

  // Work out number of lines
  int nlines = map.titer_table_flat.num_measured() * 2;

  // Setup output
  struct ErrorLineData errorlines{
    arma::vec(nlines),
    arma::vec(nlines),
    arma::vec(nlines),
    arma::vec(nlines),
    arma::uvec(nlines)
  };

  // Fetch relevant parameters
  arma::mat residual_table = ac_point_residuals(map, 0);
  arma::mat ag_coords = map.optimizations.at(0).agCoords();
  arma::mat sr_coords = map.optimizations.at(0).srCoords();
  
  // Calculate error lines
  arma::uword n = 0;
  arma::uword num_antigens = map.antigens.size();
  arma::uword num_sera = map.sera.size();

  for (arma::uword ag = 0; ag < num_antigens; ag++) {
    for (arma::uword sr = 0; sr < num_sera; sr++) {

      // Fetch variables
      arma::rowvec from = ag_coords.row(ag);
      arma::rowvec to = sr_coords.row(sr);
      double residual = residual_table(ag, sr);

      if (map.titer_table_flat.get_titer(ag, sr).type > 0) {

        // Calculate the unit vector
        arma::rowvec vec = to - from;
        vec = vec / std::sqrt(arma::accu(arma::square(vec)));

        // Get color
        arma::uword linecol;
        if (residual > 0) linecol = 0;
        else              linecol = 1;

        arma::rowvec from_end = from + vec * (residual / 2);
        arma::rowvec to_end   = to - vec * (residual / 2);

        // Store result
        errorlines.x(n) = from(0);
        errorlines.y(n) = from(1);
        errorlines.xend(n) = from_end(0);
        errorlines.yend(n) = from_end(1);
        errorlines.color(n) = linecol;

        errorlines.x(n+1) = to(0);
        errorlines.y(n+1) = to(1);
        errorlines.xend(n+1) = to_end(0);
        errorlines.yend(n+1) = to_end(1);
        errorlines.color(n+1) = linecol;
        
        n++;
        n++;

      }

    }
  }

  // Return the error line data
  return(errorlines);

}


# ================================================
# FILE: src/ac_errorlines.h
# ================================================


#include <RcppArmadillo.h>

#ifndef Racmacs__ac_errorlines__h
#define Racmacs__ac_errorlines__h

struct ErrorLineData
{
  arma::vec x;
  arma::vec xend;
  arma::vec y;
  arma::vec yend;
  arma::uvec color;
};

#endif


# ================================================
# FILE: src/ac_hemi_test.cpp
# ================================================


#include <RcppArmadillo.h>
#include "ac_hemi_test.h"
#include "ac_stress_blobs.h"
#include "acmap_optimization.h"
#include "utils.h"
#include "utils_error.h"

std::vector<HemiData> ac_hemi_test_points(
  arma::mat ag_coords,
  arma::mat sr_coords,
  arma::mat tabledists,
  arma::imat titertypes,
  double grid_spacing,
  double stress_lim,
  AcOptimizerOptions options,
  double dilution_stepsize
){

  // Set variables
  arma::uword num_ags = ag_coords.n_rows;
  arma::uword num_sr = sr_coords.n_rows;
  arma::uword dim = ag_coords.n_cols;

  // Check input
  if(dim < 2 || dim > 3){
    ac_error("Hemisphere testing is only supported for 2 or 3 dimensions");
  }

  // Setup for output
  std::vector<HemiData> output;

  // Set objects to use in loop
  arma::rowvec hemi_ag_orig_coords( dim );
  arma::rowvec hemi_ag_improved_coords( dim );
  arma::rowvec hemi_ag_relaxed_coords( dim );
  arma::uvec fixed_antigens;
  arma::uvec fixed_sera;

  // Check hemisphering antigens
  for(arma::uword ag=0; ag<num_ags; ag++){

    // Get the original ag coords and setup for any hemisphering coords
    hemi_ag_orig_coords = ag_coords.row(ag);
    std::vector<HemiDiagnosis> hemi_diagnoses;

    // Do a grid search
    StressBlobGrid grid_results = ac_stress_blob_grid(
      ag_coords.row(ag).as_col(),
      sr_coords,
      tabledists.row(ag).as_col(),
      titertypes.row(ag).as_col(),
      stress_lim,
      grid_spacing
    );

    // Get indices of those with lower stress
    arma::uvec indices = arma::find( grid_results.grid < stress_lim );

    // For those with lower stress see if they move back to the original position
    // on relaxing the map
    for(arma::uword i=0; i<indices.n_elem; i++){

      // Get the stress diff
      double stress_diff = grid_results.grid(indices(i));

      // Get the coords of the improved grid position
      arma::uvec sub = arma::ind2sub( arma::size(grid_results.grid), indices(i) );
      hemi_ag_improved_coords(0) = grid_results.xcoords( sub(0) );
      hemi_ag_improved_coords(1) = grid_results.ycoords( sub(1) );
      if(dim == 3){
        hemi_ag_improved_coords(2) = grid_results.zcoords( sub(2) );
      }

      // Move the antigen to the test position
      ag_coords.row(ag) = hemi_ag_improved_coords;

      // Set other points to be fixed
      fixed_antigens = arma::regspace<arma::uvec>( 0, num_ags - 1);
      fixed_sera = arma::regspace<arma::uvec>( 0, num_sr - 1);
      fixed_antigens.shed_row( ag );

      // Relax the coordinates
      ac_relax_coords(
        tabledists,
        titertypes,
        ag_coords,
        sr_coords,
        options,
        fixed_antigens,
        fixed_sera
      );

      // Get the coords of the relaxed position
      // and replace the antigen to the original position
      hemi_ag_relaxed_coords = ag_coords.row(ag);
      ag_coords.row(ag) = hemi_ag_orig_coords;

      // Check if the hemisphering point is in a new position
      bool equals_original_coords = arma::approx_equal(
        hemi_ag_orig_coords,
        hemi_ag_relaxed_coords,
        "absdiff",
        0.001
      );

      bool equals_previous_diagnosis = false;
      for (auto &diagnosis : hemi_diagnoses) {
        if (
          arma::approx_equal(
            diagnosis.coords,
            hemi_ag_relaxed_coords.as_col(),
            "absdiff",
            0.001
          )
        ) {
          equals_previous_diagnosis = true;
          break;
        }
      }

      // Add the record
      if (!equals_original_coords && !equals_previous_diagnosis) {

        // Set the diagnosis
        std::string diagnosis;
        if (stress_diff < -stress_lim) diagnosis = "trapped";
        else if ( stress_diff < 0)     diagnosis = "hemisphering-trapped";
        else                           diagnosis = "hemisphering";

        // Append a record of the coordinates
        hemi_diagnoses.push_back(
          HemiDiagnosis { diagnosis, hemi_ag_relaxed_coords.as_col() }
        );

      }

    }

    // Append the record of hemisphering coordinates
    if(hemi_diagnoses.size() > 0){
      HemiData hdata;
      hdata.diagnoses = hemi_diagnoses;
      hdata.index = ag;
      output.push_back( hdata );
    }

  }

  // Return the output
  return output;

}


// [[Rcpp::export]]
AcOptimization ac_hemi_test(
    AcOptimization optimization,
    AcTiterTable titertable,
    double grid_spacing,
    double stress_lim,
    AcOptimizerOptions options,
    double dilution_stepsize
){

  arma::mat tabledists = titertable.numeric_table_distances(
    optimization.get_min_column_basis(),
    optimization.get_fixed_column_bases(),
    optimization.get_ag_reactivity_adjustments()
  );
  arma::imat titertypes =titertable.get_titer_types();

  // Setup output
  arma::uword num_antigens = optimization.num_ags();
  arma::uword num_sera = optimization.num_sr();
  std::vector<HemiData> hemi_antigens(num_antigens);
  std::vector<HemiData> hemi_sera(num_sera);

  // Test antigens
  hemi_antigens = ac_hemi_test_points(
    optimization.get_ag_base_coords(),
    optimization.get_sr_base_coords(),
    tabledists,
    titertypes,
    grid_spacing,
    stress_lim,
    options,
    dilution_stepsize
  );

  // Test sera
  hemi_sera = ac_hemi_test_points(
    optimization.get_sr_base_coords(),
    optimization.get_ag_base_coords(),
    tabledists.t(),
    titertypes.t(),
    grid_spacing,
    stress_lim,
    options,
    dilution_stepsize
  );

  // Update optimization diagnostic info
  for (auto &hemidata : hemi_antigens) {
    optimization.ag_diagnostics[hemidata.index].hemi = hemidata.diagnoses;
  }
  for (auto &hemidata : hemi_sera) {
    optimization.sr_diagnostics[hemidata.index].hemi = hemidata.diagnoses;
  }
  return optimization;

}


# ================================================
# FILE: src/ac_hemi_test.h
# ================================================


#include <RcppArmadillo.h>
#include "acmap_titers.h"
#include "ac_optimizer_options.h"

#ifndef Racmacs__ac_hemi_test__h
#define Racmacs__ac_hemi_test__h

class HemiDiagnosis
{

public:
  std::string diagnosis;
  arma::vec coords;

};

class HemiData
{

public:
  arma::uword index;
  std::vector<HemiDiagnosis> diagnoses;

};

#endif


# ================================================
# FILE: src/ac_matching.cpp
# ================================================


#include <RcppArmadillo.h>
#include "acmap_map.h"

template <typename T>
arma::ivec ac_match_points(
  T const& points1,
  T const& points2
){

  arma::ivec matches(points1.size());
  matches.fill(-1);

  for(arma::uword i=0; i<points1.size(); i++){
    for(arma::uword j=0; j<points2.size(); j++){

      std::string id1 = points1[i].get_match_id();
      std::string id2 = points2[j].get_match_id();

      if(id1 == id2){
        // Check we are replacing a -1 value
        if(matches(i) == -1){
          matches(i) = j;
        }
        // Otherwise throw an error
        else {
          Rcpp::stop("Multiple matches found for '"+id2+"'");
        }
      }

    }
  }
  return matches;

}

// [[Rcpp::export]]
arma::ivec ac_match_map_ags(
    AcMap const& map1,
    AcMap const& map2
){
  return ac_match_points( map1.antigens, map2.antigens );
}

// [[Rcpp::export]]
arma::ivec ac_match_map_sr(
    AcMap const& map1,
    AcMap const& map2
){
  return ac_match_points( map1.sera, map2.sera );
}


# ================================================
# FILE: src/ac_matching.h
# ================================================


#include <RcppArmadillo.h>

#ifndef Racmacs__ac_matching__h
#define Racmacs__ac_matching__h

template <typename T>
arma::ivec ac_match_points(
    T const& points1,
    T const& points2
);

#endif


# ================================================
# FILE: src/ac_merge.cpp
# ================================================


# include <RcppArmadillo.h>
# include "ac_optim_map_stress.h"
# include "ac_merge.h"
# include "ac_titers.h"
# include "ac_matching.h"
# include "ac_optimization.h"

// For merging character titers
// [[Rcpp::export]]
AcTiter ac_merge_titers(
    const std::vector<AcTiter>& titers,
    const AcMergeOptions& options
){

  // Use the user specified merge function if applicable
  if (options.method == "function") {

    // Convert AcTiter vector to Rcpp Character vector
    Rcpp::CharacterVector character_titers(titers.size());
    for (arma::uword i=0; i<titers.size(); i++) { character_titers[i] = titers[i].toString(); }

    // Pass to the function and recast output as AcTiter
    try {
      return(AcTiter(Rcpp::as<std::string>(options.merge_function(character_titers))));
    } catch(std::exception &ex) {
      std::string exstr = ex.what();
      ac_error("Could not parse results from user-defined titer merge function, error was '" + exstr + "'");
    } catch(...) {
      ac_error("Could not parse results from user-defined titer merge function");
    }

  }

  // Return the titer if size 1
  if (titers.size() == 1) {
    return titers[0];
  }

  // Get vectors of numeric titers and titer types
  arma::vec numtiters = numeric_titers(titers);
  arma::ivec ttypes = titer_types_int(titers);
  arma::uvec nona = arma::find(ttypes > 0);

  // 1. If there are > and < titers, result is "*"
  if (arma::any(ttypes == 2) && arma::any(ttypes == 3)) {

    return AcTiter();

  } else
  // 2a. If there are just ".", result is "."
  if (arma::all(ttypes == -1)) {

    return AcTiter(0, -1);

  } else
  // 2. If there are just "*" or ".", result is "*"
  if (arma::all(ttypes <= 0)) {

    return AcTiter();

  } else
  // 3. If there are just lessthan titers, result is min of them, keeping lessthan
  if (arma::all(ttypes.elem(nona) == 2)) {

    return AcTiter(
      arma::min(numtiters),
      2 // Less than type
    );

  } else
  // 4. If there are just morethan titers, result is max of them, keeping morethan
  if (arma::all(ttypes.elem(nona) == 3)) {

    return AcTiter(
      arma::max(numtiters),
      3 // More than type
    );

  } else {

    // 5. Convert > and < titers to their next values, i.e. <40 to 20, >10240 to 20480, etc. and take the log
    arma::vec logtiters = log_titers(titers, options.dilution_stepsize);

    // 6. Compute SD, if SD > options.sd_limit, result is *, otherwise return the mean
    if (
      options.sd_limit == options.sd_limit && // Check sd_limit not set to NA
      arma::stddev(logtiters.elem(nona), options.method == "lispmds") > options.sd_limit
    ) {

      return AcTiter();

    } else {

      // Special case for conservative / lispmds method
      // If there is a mix of < values and others then return convert to log and return the largest less than
      if (options.method != "likelihood" && arma::any(ttypes == 2)) {

        return AcTiter(
          std::pow(2.0, arma::max(logtiters.elem(nona)) + options.dilution_stepsize)*10,
          2 // Set lessthan type
        );

      }

      return AcTiter(
        std::pow(2.0, arma::mean(logtiters.elem(nona)))*10,
        1 // Set measurable type
      );

    }

  }

}

// For merging titer layers
// [[Rcpp::export]]
AcTiterTable ac_merge_titer_layers(
    const std::vector<AcTiterTable>& titer_layers,
    const AcMergeOptions& options
){

  int num_ags = titer_layers.at(0).nags();
  int num_sr  = titer_layers.at(0).nsr();
  int num_layers = titer_layers.size();

  AcTiterTable merged_table = AcTiterTable(
    num_ags,
    num_sr
  );

  std::vector<AcTiter> titers(num_layers, AcTiter());

  for(int ag=0; ag<num_ags; ag++){
    for(int sr=0; sr<num_sr; sr++){
      for(int i=0; i<num_layers; i++){
        titers[i] = titer_layers.at(i).get_titer(ag,sr);
      }
      merged_table.set_titer(
        ag, sr,
        ac_merge_titers(
          titers,
          options
        )
      );
    }
  }

  return merged_table;

}


// Check if point already in points
template <typename T>
int pt_match(
    const T& pt,
    const std::vector<T>& pts
){

  for (arma::uword i=0; i<pts.size(); i++) {
    if (pts[i].get_match_id() == pt.get_match_id()) {
      return i;
    }
  }
  return -1;

}


// Construct another titer table based on a subset of indices
AcTiterTable subset_titer_table(
  const AcTiterTable& titer_table,
  const arma::ivec& agsubset,
  const arma::ivec& srsubset
){

  AcTiterTable titer_table_subset(
    agsubset.n_elem,
    srsubset.n_elem
  );

  for (arma::uword ag=0; ag<agsubset.n_elem; ag++) {
    for (arma::uword sr=0; sr<srsubset.n_elem; sr++) {
      if (agsubset(ag) != -1 && srsubset(sr) != -1) {
        titer_table_subset.set_titer(
          ag, sr,
          titer_table.get_titer(
            agsubset(ag),
            srsubset(sr)
          )
        );
      } else {
        titer_table_subset.set_titer(
          ag, sr,
          AcTiter(".")
        );
      }
    }
  }

  return titer_table_subset;

}


// Helper function for merging coordinates
template <typename T>
arma::mat merge_matching_pt_coords(
    const std::vector<T>& merged_points,
    const std::vector<T>& points1,
    const std::vector<T>& points2,
    const arma::mat& coords1,
    const arma::mat& coords2
){

  // Check input
  if(coords1.n_cols != coords2.n_cols){
    Rf_error("Dimensions do not match");
  }

  // Create the merged coords
  arma::mat merged_coords( merged_points.size(), coords1.n_cols );

  // Get point matches
  arma::ivec matches1 = ac_match_points(merged_points, points1);
  arma::ivec matches2 = ac_match_points(merged_points, points2);

  // Set coordinates
  for(arma::uword i=0; i<merged_points.size(); i++){
    if(matches1(i) > -1 && matches2(i) > -1){
      // Both match
      merged_coords.row(i) = (coords1.row(matches1(i)) + coords2.row(matches2(i))) / 2;
    } else if(matches1(i) > -1){
      // 1 matches
      merged_coords.row(i) = coords1.row(matches1(i));
    } else if(matches2(i) > -1){
      // 2 matches
      merged_coords.row(i) = coords2.row(matches2(i));
    } else {
      // No matches
      Rf_error("No matches");
    }
  }

  // Return the averaged coordinates
  return merged_coords;

}

// Merging min column basis
std::string merge_min_column_basis(
    const std::vector<AcMap>& maps
){

  std::string min_col_basis = maps[0].optimizations.at(0).get_min_column_basis();
  for(arma::uword i=1; i<maps.size(); i++){
    if(min_col_basis != maps[i].optimizations.at(0).get_min_column_basis()){
      Rcpp::Rcerr << "\nMinimum column basis of merged maps do not match, they will be taken from the first map";
    }
  }
  return min_col_basis;

}


// Merging fixed column bases
arma::vec merge_fixed_column_bases(
    const std::vector<AcMap>& maps,
    const std::vector<AcSerum>& merged_sera
){

  // Create the merged column bases
  arma::vec merged_fixed_colbases( merged_sera.size() );
  merged_fixed_colbases.fill( arma::datum::nan );

  // Fetch column bases from maps
  for(arma::uword i=0; i<maps.size(); i++){

    arma::ivec matches = ac_match_points( maps[i].sera, merged_sera );
    for(arma::uword j=0; j<matches.n_elem; j++){

      double merged_colbase = merged_fixed_colbases( matches(j) );
      double map_colbase = maps[i].optimizations.at(0).get_fixed_column_bases(j);

      if(std::isfinite(merged_colbase) && merged_colbase != map_colbase){
        // Warn if different fixed column bases used
        Rcpp::Rcerr << "\nFixed column basis of merged maps do not match, they will be taken from the first map";
      } else {
        // Otherwise apply the fixed column base to the merge
        merged_fixed_colbases( matches(j) ) = map_colbase;
      }

    }

  }

  // Return the fixed column basis
  return merged_fixed_colbases;

}


// Merging antigen reacitivity adjustments
arma::vec merge_ag_reactivity_adjustments(
    const std::vector<AcMap>& maps,
    const std::vector<AcAntigen>& merged_antigens
){

  // Create the merged column bases
  arma::vec merged_ag_reactivity_adjustments( merged_antigens.size() );
  merged_ag_reactivity_adjustments.fill( arma::datum::nan );

  // Fetch ag reactivity adjustments from maps
  for(arma::uword i=0; i<maps.size(); i++){

    arma::ivec matches = ac_match_points( maps[i].antigens, merged_antigens );
    for(arma::uword j=0; j<matches.n_elem; j++){

      double merged_ag_reactivity_adjustment = merged_ag_reactivity_adjustments( matches(j) );
      double map_ag_reactivity_adjustment = maps[i].get_ag_reactivity_adjustments(j);

      if(std::isfinite(merged_ag_reactivity_adjustment) && merged_ag_reactivity_adjustment != map_ag_reactivity_adjustment) {
        // Warn if different ag reactivity adjustments used
        Rcpp::Rcerr << "\nAntigen reactivity adjustments of merged maps do not match, they will be taken from the first map";
      } else {
        // Otherwise apply the fixed column base to the merge
        merged_ag_reactivity_adjustments( matches(j) ) = map_ag_reactivity_adjustment;
      }

    }

  }

  // Return the fixed column basis
  return merged_ag_reactivity_adjustments;

}



// == TABLE MERGE ======
// Just merge the map tables, any optimizations are lost. This function forms the basis
// for all of the other merging functions
// [[Rcpp::export]]
AcMap ac_merge_tables(
  std::vector<AcMap> maps,
  const AcMergeOptions& merge_options
){

  // Setup for output
  std::vector<AcAntigen> merged_antigens;
  std::vector<AcSerum> merged_sera;
  std::vector<AcTiterTable> merged_layers;

  // Record how each antigen and sera maps its index to the merged map
  std::vector<arma::uvec> mapped_ag_indices(maps.size());
  std::vector<arma::uvec> mapped_sr_indices(maps.size());

  // Add antigens and sera
  for(arma::uword i=0; i<maps.size(); i++){

    mapped_ag_indices[i].set_size(maps[i].antigens.size());
    mapped_sr_indices[i].set_size(maps[i].sera.size());

    for(arma::uword ag=0; ag<maps[i].antigens.size(); ag++){
      int match = pt_match(maps[i].antigens[ag], merged_antigens);
      if (match == -1){
        merged_antigens.push_back(maps[i].antigens[ag]);
        mapped_ag_indices[i][ag] = merged_antigens.size() - 1;
      } else {
        mapped_ag_indices[i][ag] = match;
      }
    }

    for(arma::uword sr=0; sr<maps[i].sera.size(); sr++){
      int match = pt_match(maps[i].sera[sr], merged_sera);
      if(match == -1){
        merged_sera.push_back(maps[i].sera[sr]);
        mapped_sr_indices[i][sr] = merged_sera.size() - 1;
      } else{
        mapped_sr_indices[i][sr] = match;
      }
    }

  }

  // Remap sera homologous antigens
  for (auto &serum : merged_sera) {
    serum.homologous_ags.clear();
  }

  for (arma::uword i=0; i<maps.size(); i++) {
    for (arma::uword sr=0; sr<maps[i].sera.size(); sr++) {
      for (arma::uword j=0; j<maps[i].sera[sr].homologous_ags.n_elem; j++) {
        uvec_push(
          merged_sera[mapped_sr_indices[i][sr]].homologous_ags,
          mapped_ag_indices[i][maps[i].sera[sr].homologous_ags[j]]
        );
      }
    }
  }

  for (auto &serum : merged_sera) {
    serum.homologous_ags = arma::unique(serum.homologous_ags);
  }

  // Add titer table layers
  std::vector<std::string> layer_map_names;
  for(arma::uword i=0; i<maps.size(); i++){

    arma::ivec merged_map_ag_matches = ac_match_points(merged_antigens, maps[i].antigens);
    arma::ivec merged_map_sr_matches = ac_match_points(merged_sera, maps[i].sera);

    std::vector<AcTiterTable> titer_table_layers = maps[i].get_titer_table_layers();

    for(arma::uword layer=0; layer<titer_table_layers.size(); layer++){
      layer_map_names.push_back(maps[i].name);
      merged_layers.push_back(
        subset_titer_table(
          titer_table_layers[layer],
          merged_map_ag_matches,
          merged_map_sr_matches
        )
      );
    }

  }

  // Create the map
  AcMap merged_map = AcMap(
    merged_antigens.size(),
    merged_sera.size()
  );

  merged_map.antigens = merged_antigens;
  merged_map.sera = merged_sera;

  // Set the titer table layers
  merged_map.titer_table_layers = merged_layers;

  // Set the flat titer table
  merged_map.titer_table_flat = ac_merge_titer_layers(
    merged_layers,
    merge_options
  );

  // Set titer table names
  merged_map.layer_names.resize( merged_map.titer_table_layers.size() );
  for (arma::uword i = 0; i < merged_map.titer_table_layers.size(); i++) {
    merged_map.layer_names[i] = layer_map_names[i];
  }

  // Return the merged map
  return merged_map;

}


// == REOPTIMIZED MERGE ======
// Merge the tables then run some fresh optimizations
// [[Rcpp::export]]
AcMap ac_merge_reoptimized(
  std::vector<AcMap> maps,
  int num_dims,
  int num_optimizations,
  std::string min_col_basis,
  AcOptimizerOptions optimizer_options,
  AcMergeOptions merge_options
){

  // Merge the map tables
  AcMap merged_map = ac_merge_tables(maps, merge_options);

  // Merge antigen reactivity adjustments
  arma::vec ag_reactivity_adjustments = merge_ag_reactivity_adjustments( maps, merged_map.antigens );

  // Run the optimizations
  merged_map.optimize(
    num_dims,
    num_optimizations,
    min_col_basis,
    arma::vec(merged_map.sera.size(), arma::fill::value(arma::datum::nan)),
    ag_reactivity_adjustments,
    optimizer_options
  );

  // Return the map
  return merged_map;

}


// == FROZEN OVERLAY MERGE ======
// This fixes the positions of points in each map and tries to best match them simply through re-orientation.
// Once the best re-orientation is found, points that are in common between the maps are moved to the average
// position.
// [[Rcpp::export]]
AcMap ac_merge_frozen_overlay(
  std::vector<AcMap> maps,
  const AcMergeOptions& merge_options
){

  // Check input
  if(maps.size() > 2){
    Rf_error("This type of merge only works with 2 maps");
  }
  if(maps[0].num_optimizations() == 0 || maps[1].num_optimizations() == 0){
    Rf_error("Map does not have any optimizations to merge");
  }

  // Merge the map tables
  AcMap merged_map = ac_merge_tables(maps, merge_options);

  // Orient map 2 to map 1
  maps[1].realign_to_map( maps[0] );

  // Create a fresh optimization
  AcOptimization opt(
    maps[0].optimizations.at(0).dim(),
    merged_map.antigens.size(),
    merged_map.sera.size()
  );

  // Merge coordinates
  opt.set_ag_base_coords(
    merge_matching_pt_coords(
      merged_map.antigens,
      maps[0].antigens,
      maps[1].antigens,
      maps[0].optimizations.at(0).agCoords(),
      maps[1].optimizations.at(0).agCoords()
    )
  );

  opt.set_sr_base_coords(
    merge_matching_pt_coords(
      merged_map.sera,
      maps[0].sera,
      maps[1].sera,
      maps[0].optimizations.at(0).srCoords(),
      maps[1].optimizations.at(0).srCoords()
    )
  );

  // Merge column bases
  opt.set_min_column_basis( merge_min_column_basis(maps) );
  opt.set_fixed_column_bases( merge_fixed_column_bases(maps, merged_map.sera) );

  // Merge antigen reactivity adjustments
  opt.set_ag_reactivity_adjustments( merge_ag_reactivity_adjustments( maps, merged_map.antigens ) );

  // Calculate stress
  opt.update_stress(
    merged_map.titer_table_flat,
    maps[0].dilution_stepsize
  );

  // Add optimization
  merged_map.optimizations.push_back( opt );

  // Return the map
  return merged_map;

}


// == RELAXED OVERLAY MERGE ======
// This is the same as the frozen-overlay but points in the resulting map are
// then allowed to relax.
// [[Rcpp::export]]
AcMap ac_merge_relaxed_overlay(
    std::vector<AcMap> maps,
    AcOptimizerOptions optimizer_options,
    AcMergeOptions merge_options
){

  // Do the frozen overlay
  AcMap merged_map = ac_merge_frozen_overlay(
    maps,
    merge_options
  );

  // Relax the optimization
  merged_map.optimizations.at(0).relax_from_titer_table(
    merged_map.titer_table_flat,
    optimizer_options
  );

  // Return the result
  return merged_map;

}


// == FROZEN MERGE ======
// In this version, positions of all points in the first map are fixed and
// remain fixed, so the original map does not change. The second map is then
// realigned to the first as closely as possible and then all the new points
// appearing in the second map are allowed to relax into their new positions.
// [[Rcpp::export]]
AcMap ac_merge_frozen_merge(
    std::vector<AcMap> maps,
    const AcOptimizerOptions& optimizer_options,
    const AcMergeOptions& merge_options
){

  // Start with a frozen merge
  AcMap merged_map = ac_merge_frozen_overlay(maps, merge_options);

  // Find matching points from map 1
  arma::uvec map1_ag_matches = arma::conv_to< arma::uvec >::from( ac_match_points(maps[0].antigens, merged_map.antigens) );
  arma::uvec map1_sr_matches = arma::conv_to< arma::uvec >::from( ac_match_points(maps[0].sera, merged_map.sera) );

  // Move the matching points back to their position in map 1, undoing any averaging
  // done by ac_merge_frozen_overlay
  merged_map.optimizations.at(0).set_ag_base_coords( map1_ag_matches, maps[0].optimizations.at(0).get_ag_base_coords() );
  merged_map.optimizations.at(0).set_sr_base_coords( map1_sr_matches, maps[0].optimizations.at(0).get_sr_base_coords() );

  // Now relax the map while fixing points in map 1
  merged_map.optimizations.at(0).relax_from_titer_table(
      merged_map.titer_table_flat,
      optimizer_options,
      map1_ag_matches, // Fixed antigens
      map1_sr_matches  // Fixed sera
  );

  // Return the map
  return merged_map;

}


// == INCREMENTAL MERGE ======
AcMap ac_merge_incremental_single(
    const std::vector<AcMap>& maps,
    int num_dims,
    int num_optimizations,
    std::string min_colbasis,
    const AcOptimizerOptions& optimizer_options,
    const AcMergeOptions& merge_options
){

  // Check input
  if(maps.size() != 2) Rf_error("Expecting 2 maps");

  // Merge the maps
  AcMap merged_map = ac_merge_tables(maps, merge_options);

  // Setup default fixed column bases
  arma::vec fixed_colbases = arma::vec( merged_map.sera.size() );
  fixed_colbases.fill( arma::datum::nan );

  // Setup default ag reactivity adjustments
  arma::vec ag_reactivity_adjustments = arma::vec(
    merged_map.antigens.size(),
    arma::fill::zeros
  );

  // Get table distance matrix and titer type matrix
  arma::mat tabledist_matrix = merged_map.titer_table_flat.numeric_table_distances(
    min_colbasis,
    fixed_colbases,
    ag_reactivity_adjustments
  );
  arma::imat titertype_matrix = merged_map.titer_table_flat.get_titer_types();

  // Generate optimizations with random starting coords
  std::vector<AcOptimization> optimizations = ac_generateOptimizations(
    tabledist_matrix,
    titertype_matrix,
    min_colbasis,
    fixed_colbases,
    ag_reactivity_adjustments,
    num_dims,
    num_optimizations,
    optimizer_options
  );

  // Set coordinates of points found in map 1 back to their positions in map1
  arma::uvec map1_ag_matches = arma::conv_to<arma::uvec>::from( ac_match_points(maps[0].antigens, merged_map.antigens) );
  arma::uvec map1_sr_matches = arma::conv_to<arma::uvec>::from( ac_match_points(maps[0].sera, merged_map.sera) );

  for(auto &optimization : optimizations){
    arma::mat ag_base_coords = optimization.get_ag_base_coords();
    arma::mat sr_base_coords = optimization.get_sr_base_coords();
    ag_base_coords.rows( map1_ag_matches ) = maps[0].optimizations.at(0).get_ag_base_coords();
    sr_base_coords.rows( map1_sr_matches ) = maps[0].optimizations.at(0).get_sr_base_coords();
    optimization.set_ag_base_coords( ag_base_coords );
    optimization.set_sr_base_coords( sr_base_coords );
  }

  // Relax the optimizations
  ac_relaxOptimizations(
    optimizations,
    optimizations.at(0).dim(),
    tabledist_matrix,
    titertype_matrix,
    optimizer_options
  );

  // Sort the optimizations by stress
  sort_optimizations_by_stress(optimizations);

  // Realign optimizations to the first one
  align_optimizations(optimizations);

  // Set column bases
  for(auto &optimization : optimizations){
    optimization.set_min_column_basis(min_colbasis);
    optimization.set_fixed_column_bases(fixed_colbases);
  }

  // Add optimizations to merged map and return it
  merged_map.optimizations = optimizations;
  return merged_map;

}

// [[Rcpp::export]]
AcMap ac_merge_incremental(
    const std::vector<AcMap>& maps,
    int num_dims,
    int num_optimizations,
    std::string min_colbasis,
    const AcOptimizerOptions& optimizer_options,
    const AcMergeOptions& merge_options
){

  // Check input
  if(maps.size() < 2) Rf_error("Expected at least 2 maps");

  // Set the merged map
  AcMap merged_map = maps[0];

  // Set fixed column bases to all ignored, setting fixed colbases isn't
  // included in inc merge yet.
  arma::vec fixed_colbases = arma::vec( merged_map.sera.size() );
  fixed_colbases.fill( arma::datum::nan );

  // Set ag reactivity adjustments to all ignored, setting ag reactivity adjustments
  // isn't included in inc merge yet.
  arma::vec ag_reactivity_adjustments = arma::vec(
    merged_map.sera.size(),
    arma::fill::zeros
  );

  // Perform an optimization on the first map, if not done already
  if(merged_map.num_optimizations() == 0){
    merged_map.optimize(
      num_dims,
      num_optimizations,
      min_colbasis,
      fixed_colbases,
      ag_reactivity_adjustments,
      optimizer_options
    );
  }

  // Do an incremental merge for each map in turn
  for(arma::uword i=1; i < maps.size(); i++){
    merged_map = ac_merge_incremental_single(
      std::vector<AcMap> { merged_map, maps[i] },
      num_dims,
      num_optimizations,
      min_colbasis,
      optimizer_options,
      merge_options
    );
  }

  // Return the merged map
  return merged_map;

}


// [[Rcpp::export]]
int ac_titer_merge_type(
    const std::vector<AcTiter>& titers
) {

  // Determine titer types
  arma::ivec ttypes = titer_types_int(titers);

  // Case -1: All .
  if (arma::all(ttypes == -1)) {
    return(-1);
  } else
  // Case 0: Nothing measured
  if (arma::all(ttypes <= 0)) {
    return(0);
  } else
  // Case 1: Only detectable
  if (arma::all(ttypes == 1)) {
    return(1);
  } else
  // Case 2: Only <
  if (arma::all(ttypes == 2)) {
    return(2);
  } else
  // Case 3: Only >
  if (arma::all(ttypes == 3)) {
    return(3);
  } else
  // Case 4: Contains some mixture of <, > and detectable values
  {
    return(4);
  }

}


// Determing the type of titer merge happening in tables
// [[Rcpp::export]]
arma::imat ac_titer_layer_merge_types(
    const std::vector<AcTiterTable>& titer_layers
){

  int num_ags = titer_layers.at(0).nags();
  int num_sr  = titer_layers.at(0).nsr();
  int num_layers = titer_layers.size();

  arma::imat merge_types(num_ags, num_sr);
  std::vector<AcTiter> titers(num_layers, AcTiter());

  for (int ag=0; ag<num_ags; ag++) {
    for (int sr=0; sr<num_sr; sr++) {
      for (int i=0; i<num_layers; i++) {
        titers[i] = titer_layers.at(i).get_titer(ag,sr);
      }
      merge_types(ag, sr) = ac_titer_merge_type(titers);
    }
  }

  return merge_types;

}


// Determing the type of titer merge happening in tables
// [[Rcpp::export]]
arma::mat ac_titer_layer_sd(
    const std::vector<AcTiterTable>& titer_layers,
    const double dilution_stepsize
){

  int num_ags = titer_layers.at(0).nags();
  int num_sr  = titer_layers.at(0).nsr();
  int num_layers = titer_layers.size();

  arma::mat merge_sd(num_ags, num_sr);
  std::vector<AcTiter> titers(num_layers, AcTiter());

  for (int ag=0; ag<num_ags; ag++) {
    for (int sr=0; sr<num_sr; sr++) {
      for (int i=0; i<num_layers; i++) {
        titers[i] = titer_layers.at(i).get_titer(ag,sr);
      }
      merge_sd(ag, sr) = arma::stddev(log_titers(titers, dilution_stepsize));
    }
  }

  return merge_sd;

}


# ================================================
# FILE: src/ac_merge.h
# ================================================


#include "acmap_titers.h"

#ifndef Racmacs__ac_merge__h
#define Racmacs__ac_merge__h


// Merge options
struct AcMergeOptions {
  double sd_limit;
  double dilution_stepsize;
  Rcpp::Function merge_function;
  std::string method;
};


// Merge titers
AcTiter ac_merge_titers(
    const std::vector<AcTiter>& titers,
    const AcMergeOptions& options
);


// Merge titer layers
AcTiterTable ac_merge_titer_layers(
    const std::vector<AcTiterTable>& titer_layers,
    const AcMergeOptions& options
);

#endif


# ================================================
# FILE: src/ac_move_trapped_points.cpp
# ================================================


#include <RcppArmadillo.h>

#ifdef _OPENMP
#include <omp.h>
#endif
// [[Rcpp::plugins(openmp)]]

#include "acmap_optimization.h"
#include "ac_stress_blobs.h"
#include "ac_optimizer_options.h"

// Check for trapped antigens
arma::mat check_ag_trapped_points(
    const AcOptimization &optimization,
    const arma::mat &tabledists,
    const arma::imat &titertypes,
    const double &grid_spacing,
    AcOptimizerOptions options
){

  // Variables
  double stress_lim = 0;
  int num_ags = optimization.num_ags();
  arma::mat ag_coords = optimization.get_ag_base_coords();
  arma::mat sr_coords = optimization.get_sr_base_coords();

  arma::mat trapped_ag_improved_coords(arma::size(ag_coords));
  trapped_ag_improved_coords.fill(arma::datum::nan);

  // Check trapped antigens
  #pragma omp parallel for schedule(dynamic) num_threads(options.num_cores)
  for(int ag=0; ag<num_ags; ag++){

    // Do a grid search
    StressBlobGrid grid_results = ac_stress_blob_grid(
      ag_coords.row(ag).as_col(),
      sr_coords,
      tabledists.row(ag).as_col(),
      titertypes.row(ag).as_col(),
      stress_lim,
      grid_spacing
    );

    // Check if any grid points have lower stress than the minimum
    if(grid_results.grid.min() < 0.0){
      arma::uword index = grid_results.grid.index_min();
      arma::uvec sub = arma::ind2sub( arma::size(grid_results.grid), index );
      trapped_ag_improved_coords(ag,0) = grid_results.xcoords( sub(0) );
      trapped_ag_improved_coords(ag,1) = grid_results.ycoords( sub(1) );
    }

  }

  // Return trapped point information
  return trapped_ag_improved_coords;

}


// Check for trapped sera
arma::mat check_sr_trapped_points(
    const AcOptimization &optimization,
    const arma::mat &tabledists,
    const arma::imat &titertypes,
    const double &grid_spacing,
    AcOptimizerOptions options
){

  // Variables
  double stress_lim = 0;
  int num_sr = optimization.num_sr();
  arma::mat ag_coords = optimization.get_ag_base_coords();
  arma::mat sr_coords = optimization.get_sr_base_coords();

  arma::mat trapped_sr_improved_coords(arma::size(sr_coords));
  trapped_sr_improved_coords.fill(arma::datum::nan);

  // Check trapped sera
  #pragma omp parallel for schedule(dynamic) num_threads(options.num_cores)
  for(int sr=0; sr<num_sr; sr++){

    // Do a grid search
    StressBlobGrid grid_results = ac_stress_blob_grid(
      sr_coords.row(sr).as_col(),
      ag_coords,
      tabledists.col(sr),
      titertypes.col(sr),
      stress_lim,
      grid_spacing
    );

    // Check if any grid points have lower stress than the minimum
    if(grid_results.grid.min() < 0.0){
      arma::uword index = grid_results.grid.index_min();
      arma::uvec sub = arma::ind2sub( arma::size(grid_results.grid), index );
      trapped_sr_improved_coords(sr,0) = grid_results.xcoords( sub(0) );
      trapped_sr_improved_coords(sr,1) = grid_results.ycoords( sub(1) );
    }

  }

  // Return trapped point information
  return trapped_sr_improved_coords;

}


// Function to find and move trapped coordinates
// [[Rcpp::export]]
AcOptimization ac_move_trapped_points(
  AcOptimization optimization,
  AcTiterTable titertable,
  double grid_spacing,
  AcOptimizerOptions options,
  int max_iterations = 10,
  double dilution_stepsize = 1.0
){


  // Check antigen and sera trapped points recursively
  if(options.report_progress) REprintf("Checking for trapped points recursively:");

  arma::imat titertypes = titertable.get_titer_types();
  arma::mat tabledists = titertable.numeric_table_distances(
    optimization.get_min_column_basis(),
    optimization.get_fixed_column_bases(),
    optimization.get_ag_reactivity_adjustments()
  );

  int num_iterations = 0;
  while(num_iterations < max_iterations){

    // Variables
    arma::mat ag_coords = optimization.get_ag_base_coords();
    arma::mat sr_coords = optimization.get_sr_base_coords();

    // Check for any improved coordinates
    arma::mat ag_trapped_improved_coords = check_ag_trapped_points(optimization, tabledists, titertypes, grid_spacing, options);
    arma::mat sr_trapped_improved_coords = check_sr_trapped_points(optimization, tabledists, titertypes, grid_spacing, options);

    // Get any improved indices
    arma::uvec ag_trapped_coord_indices = arma::find_finite(ag_trapped_improved_coords);
    arma::uvec sr_trapped_coord_indices = arma::find_finite(sr_trapped_improved_coords);

    // Break if no improvements found
    if((ag_trapped_coord_indices.n_elem == 0) && (sr_trapped_coord_indices.n_elem == 0)){
      break;
    }

    // Move antigen and serum coordinates to improved positions
    ag_coords.elem(ag_trapped_coord_indices) = ag_trapped_improved_coords.elem(ag_trapped_coord_indices);
    sr_coords.elem(sr_trapped_coord_indices) = sr_trapped_improved_coords.elem(sr_trapped_coord_indices);

    optimization.set_ag_base_coords(ag_coords);
    optimization.set_sr_base_coords(sr_coords);

    // Relax the optimization
    optimization.relax_from_raw_matrices(
      tabledists,
      titertypes,
      options,
      arma::uvec(),
      arma::uvec(),
      arma::mat(),
      dilution_stepsize
    );

    // Increment loop num
    if(options.report_progress) REprintf(".");
    num_iterations++;

  }

  // Output message indicating if some were found
  if(options.report_progress){
    if(num_iterations == 0){
      REprintf(" no trapped points found.\n");
    } else if(num_iterations == max_iterations){
      REprintf(" maximum iteration number reached.\n");
    } else {
      REprintf(" all trapped points moved.\n");
    }
  }

  // Return the improved optimization
  return optimization;

}



# ================================================
# FILE: src/ac_optim_map_stress.cpp
# ================================================

// src/ac_optim_map_stress.cpp
// CORRECTED VERSION - Fixed forward declarations and removed duplicate functions

#include <math.h>
#include <RcppArmadillo.h>
#include <RcppEnsmallen.h>

#ifdef _OPENMP
#include <omp.h>
#endif
// [[Rcpp::plugins(openmp)]]
// [[Rcpp::depends(RcppProgress)]]

#include "utils.h"
#include "utils_error.h"
#include "utils_progress.h"
#include "acmap_map.h"
#include "ac_stress.h"
#include "ac_optim_map_stress.h"
#include "ac_optimization.h"
#include "ac_optimizer_options.h"
#include "acmap_optimization.h"
#include "acmap_titers.h"


// ============================================================================
// FORWARD DECLARATIONS (must come before they are used)
// ============================================================================

arma::mat create_initial_pars(
    const arma::mat &ag_coords,
    const arma::mat &sr_coords,
    const arma::uvec &moveable_ags,
    const arma::uvec &moveable_sr,
    const arma::vec &colbases,
    const arma::uvec &moveable_colbases,
    bool optimize_colbases
);

void ac_relaxOptimizations(
  std::vector<AcOptimization>& optimizations,
  arma::uword num_dims,
  const arma::mat &tabledist_matrix,
  const arma::imat &titertype_matrix,
  const AcOptimizerOptions &options,
  const arma::mat &titer_weights,
  const double &dilution_stepsize
);

void ac_relaxOptimizations_with_colbases(
  std::vector<AcOptimization>& optimizations,
  arma::uword num_dims,
  const arma::mat &logtiter_matrix,
  const arma::imat &titertype_matrix,
  const arma::vec &initial_colbases,
  const AcOptimizerOptions &options,
  const arma::mat &titer_weights,
  const double &dilution_stepsize
);

void sort_optimizations_by_stress(
    std::vector<AcOptimization>& optimizations
);

void align_optimizations(
  std::vector<AcOptimization>& optimizations
);


// ============================================================================
// MapOptimizer CLASS
// ============================================================================

class MapOptimizer {

  public:

    // > ATTRIBUTES

    // - Coordinate matrices
    arma::mat ag_coords;
    arma::mat sr_coords;

    // - Distance matrices
    arma::mat mapdist_matrix;      // Distances from coordinates (computed)
    arma::mat tabledist_matrix;    // Distances from titers (now computed dynamically)

    // - NEW: Store log titers separately (constant throughout optimization)
    arma::mat logtiter_matrix;     // FIXED - the log titers (constant)

    // - NEW: Column bases (optimizable when optimize_colbases = true)
    arma::vec colbases;            // OPTIMIZABLE - column bases
    arma::vec colbase_gradients;
    arma::uvec moveable_colbases;  // Indices of colbases to optimize

    // NEW: Flag to control column base optimization
    bool optimize_colbases;

    // Titer information
    arma::imat titertype_matrix;
    
    // Dimensions
    arma::uword num_dims;
    arma::uword num_ags;
    arma::uword num_sr;
    
    // Point tracking
    arma::uvec moveable_ags;
    arma::uvec moveable_sr;
    arma::uvec included_ags;
    arma::uvec included_srs;
    arma::uvec::iterator agi;
    arma::uvec::iterator agi_end;
    arma::uvec::iterator sri;
    arma::uvec::iterator sri_end;
    
    // Weights and gradients
    arma::mat titer_weights;
    arma::mat ag_gradients;
    arma::mat sr_gradients;
    
    // Other parameters
    double dilution_stepsize;
    double gradient;
    double stress;

    // ========================================================================
    // CONSTRUCTOR 1: Basic constructor (backward compatible, no colbase optimization)
    // ========================================================================
    MapOptimizer(
      arma::mat ag_start_coords,
      arma::mat sr_start_coords,
      arma::mat tabledist,           // Pre-computed table distances
      arma::imat titertype,
      arma::uword dims,
      double dilution_stepsize_in
    )
      :ag_coords(ag_start_coords),
       sr_coords(sr_start_coords),
       tabledist_matrix(tabledist),
       titertype_matrix(titertype),
       num_dims(dims),
       num_ags(tabledist.n_rows),
       num_sr(tabledist.n_cols),
       dilution_stepsize(dilution_stepsize_in),
       optimize_colbases(false)
    {
      // Set default moveable antigens and sera to all
      moveable_ags = arma::regspace<arma::uvec>(0, num_ags - 1);
      moveable_sr = arma::regspace<arma::uvec>(0, num_sr - 1);

      // Set included antigens and sera
      included_ags = arma::find_finite(ag_start_coords.col(0));
      included_srs = arma::find_finite(sr_start_coords.col(0));
      agi_end = included_ags.end();
      sri_end = included_srs.end();

      // Set default weights to 1
      titer_weights.ones(num_ags, num_sr);

      // Setup map dist matrices
      mapdist_matrix = arma::mat(num_ags, num_sr, arma::fill::zeros);

      // Setup the gradient vectors
      ag_gradients.zeros(num_ags, num_dims);
      sr_gradients.zeros(num_sr, num_dims);

      // Update the map distance matrix according to coordinates
      update_map_dist_matrix();
    }

    // ========================================================================
    // CONSTRUCTOR 2: With fixed points (backward compatible)
    // ========================================================================
    MapOptimizer(
      arma::mat ag_start_coords,
      arma::mat sr_start_coords,
      arma::mat tabledist,
      arma::imat titertype,
      arma::uword dims,
      arma::uvec ag_fixed,
      arma::uvec sr_fixed,
      arma::mat titer_weights_in,
      double dilution_stepsize_in
    )
      :ag_coords(ag_start_coords),
       sr_coords(sr_start_coords),
       tabledist_matrix(tabledist),
       titertype_matrix(titertype),
       num_dims(dims),
       num_ags(tabledist.n_rows),
       num_sr(tabledist.n_cols),
       dilution_stepsize(dilution_stepsize_in),
       optimize_colbases(false)
    {
      // Set default weights to 1 if missing
      if (titer_weights_in.n_elem == 0) titer_weights.ones(num_ags, num_sr);
      else                              titer_weights = titer_weights_in;

      // Set moveable antigens
      moveable_ags = arma::find(ag_fixed == 0);
      moveable_sr = arma::find(sr_fixed == 0);

      // Set included antigens and sera
      included_ags = arma::find_finite(ag_start_coords.col(0));
      included_srs = arma::find_finite(sr_start_coords.col(0));
      agi_end = included_ags.end();
      sri_end = included_srs.end();

      // Setup map dist matrices
      mapdist_matrix = arma::mat(num_ags, num_sr, arma::fill::zeros);

      // Setup the gradient vectors
      ag_gradients.zeros(num_ags, num_dims);
      sr_gradients.zeros(num_sr, num_dims);

      // Update the map distance matrix according to coordinates
      update_map_dist_matrix();
    }

    // ========================================================================
    // CONSTRUCTOR 3: NEW - With column base optimization support
    // ========================================================================
    MapOptimizer(
      arma::mat ag_start_coords,
      arma::mat sr_start_coords,
      arma::mat logtiter_matrix_in,
      arma::imat titertype,
      arma::vec initial_colbases,
      arma::uword dims,
      arma::uvec ag_fixed,
      arma::uvec sr_fixed,
      arma::mat titer_weights_in,
      double dilution_stepsize_in,
      bool optimize_colbases_in
    )
      :ag_coords(ag_start_coords),
       sr_coords(sr_start_coords),
       logtiter_matrix(logtiter_matrix_in),
       colbases(initial_colbases),
       titertype_matrix(titertype),
       num_dims(dims),
       num_ags(logtiter_matrix_in.n_rows),
       num_sr(logtiter_matrix_in.n_cols),
       dilution_stepsize(dilution_stepsize_in),
       optimize_colbases(optimize_colbases_in)
    {
      // Set default weights
      if (titer_weights_in.n_elem == 0) titer_weights.ones(num_ags, num_sr);
      else                              titer_weights = titer_weights_in;

      // Set moveable antigens and sera
      moveable_ags = arma::find(ag_fixed == 0);
      moveable_sr = arma::find(sr_fixed == 0);

      // Set included antigens and sera
      included_ags = arma::find_finite(ag_start_coords.col(0));
      included_srs = arma::find_finite(sr_start_coords.col(0));
      agi_end = included_ags.end();
      sri_end = included_srs.end();

      // All column bases are moveable when optimize_colbases is true
      if (optimize_colbases) {
        moveable_colbases = arma::regspace<arma::uvec>(0, num_sr - 1);
        colbase_gradients.zeros(num_sr);
      }

      // Setup distance matrices
      mapdist_matrix = arma::mat(num_ags, num_sr, arma::fill::zeros);
      tabledist_matrix = arma::mat(num_ags, num_sr, arma::fill::zeros);

      // Setup the gradient vectors
      ag_gradients.zeros(num_ags, num_dims);
      sr_gradients.zeros(num_sr, num_dims);

      // Initialize table distances from log titers and initial colbases
      update_table_dist_matrix();

      // Update the map distance matrix according to coordinates
      update_map_dist_matrix();
    }

    // ========================================================================
    // EVALUATE OBJECTIVE FUNCTION
    // ========================================================================
    double Evaluate(const arma::mat &pars) {
      update_parameters(pars);
      if (optimize_colbases) {
        update_table_dist_matrix();
      }
      update_map_dist_matrix();
      return calculate_stress();
    }

    // ========================================================================
    // EVALUATE WITH GRADIENT
    // ========================================================================
    double EvaluateWithGradient(const arma::mat &pars, arma::mat &grad) {
      update_parameters(pars);

      if (optimize_colbases) {
        update_table_dist_matrix();
      }

      update_map_dist_matrix();
      update_gradients();
      
      if (optimize_colbases) {
        update_colbase_gradients();
      }

      arma::uword coord_rows = moveable_ags.n_elem + moveable_sr.n_elem;
      arma::uword total_rows = coord_rows;
      if (optimize_colbases) {
        total_rows += moveable_colbases.n_elem;
      }
      grad.set_size(total_rows, num_dims);
      
      for (arma::uword i = 0; i < moveable_ags.n_elem; ++i) {
        grad.row(i) = ag_gradients.row(moveable_ags(i));
      }
      for (arma::uword i = 0; i < moveable_sr.n_elem; ++i) {
        grad.row(i + moveable_ags.n_elem) = sr_gradients.row(moveable_sr(i));
      }

      if (optimize_colbases) {
        for (arma::uword i = 0; i < moveable_colbases.n_elem; ++i) {
          grad.at(coord_rows + i, 0) = colbase_gradients(moveable_colbases(i));
          for (arma::uword j = 1; j < num_dims; ++j) {
            grad.at(coord_rows + i, j) = 0.0;
          }
        }
      }

      return calculate_stress();
    }

    // ========================================================================
    // UPDATE GRADIENTS (for coordinates)
    // ========================================================================
    void update_gradients() {
      ag_gradients.zeros();
      sr_gradients.zeros();

      for(sri = included_srs.begin(); sri != sri_end; ++sri) {
        for(agi = included_ags.begin(); agi != agi_end; ++agi) {
          if(titertype_matrix.at(*agi, *sri) <= 0) continue;

          double ibase = titer_weights.at(*agi,*sri) * inc_base(
            mapdist_matrix.at(*agi, *sri),
            tabledist_matrix.at(*agi, *sri),
            titertype_matrix.at(*agi, *sri),
            dilution_stepsize
          );

          for(arma::uword i = 0; i < num_dims; ++i) {
            gradient = ibase*(ag_coords.at(*agi, i) - sr_coords.at(*sri, i));
            ag_gradients.at(*agi, i) -= gradient;
            sr_gradients.at(*sri, i) += gradient;
          }
        }
      }
    }

    // ========================================================================
    // UPDATE COLUMN BASE GRADIENTS
    // ========================================================================
    void update_colbase_gradients() {
      colbase_gradients.zeros();

      for (arma::uword sr = 0; sr < num_sr; ++sr) {
        for (arma::uword ag = 0; ag < num_ags; ++ag) {
          arma::sword titer_type = titertype_matrix.at(ag, sr);
          if (titer_type <= 0) continue;

          double table_dist = tabledist_matrix(ag, sr);
          double map_dist = mapdist_matrix(ag, sr);
          double weight = titer_weights(ag, sr);

          if (titer_type == 1) {
            colbase_gradients(sr) += weight * 2.0 * (table_dist - map_dist);
          }
          else if (titer_type == 2) {
            double x = table_dist - map_dist + dilution_stepsize;
            double sig = 1.0 / (1.0 + std::exp(-10.0 * x));
            double d_sig = sig * (1.0 - sig) * 10.0;
            double grad = 2.0 * x * sig + x * x * d_sig;
            colbase_gradients(sr) += weight * grad;
          }
        }
      }
    }

    // ========================================================================
    // UPDATE TABLE DISTANCE MATRIX
    // ========================================================================
    void update_table_dist_matrix() {
      for (arma::uword sr = 0; sr < num_sr; ++sr) {
        for (arma::uword ag = 0; ag < num_ags; ++ag) {
          if (titertype_matrix.at(ag, sr) > 0) {
            tabledist_matrix(ag, sr) = colbases(sr) - logtiter_matrix(ag, sr);
          } else {
            tabledist_matrix(ag, sr) = arma::datum::nan;
          }
        }
      }
    }

    // ========================================================================
    // UPDATE PARAMETERS (coordinates and optionally column bases)
    // ========================================================================
    void update_parameters(const arma::mat &pars) {
      for (arma::uword j = 0; j < num_dims; ++j) {
        for (arma::uword i = 0; i < moveable_ags.n_elem; ++i) {
          ag_coords.at(moveable_ags(i), j) = pars.at(i, j);
        }
      }

      for (arma::uword j = 0; j < num_dims; ++j) {
        for (arma::uword i = 0; i < moveable_sr.n_elem; ++i) {
          sr_coords.at(moveable_sr(i), j) = pars.at(i + moveable_ags.n_elem, j);
        }
      }

      if (optimize_colbases) {
        arma::uword coord_rows = moveable_ags.n_elem + moveable_sr.n_elem;
        for (arma::uword i = 0; i < moveable_colbases.n_elem; ++i) {
          colbases(moveable_colbases(i)) = pars.at(coord_rows + i, 0);
        }
      }
    }

    // ========================================================================
    // CALCULATE STRESS
    // ========================================================================
    double calculate_stress(){
      stress = 0;

      for(sri = included_srs.begin(); sri != sri_end; ++sri) {
        for(agi = included_ags.begin(); agi != agi_end; ++agi) {
          if(titertype_matrix.at(*agi,*sri) <= 0) continue;

          stress += titer_weights.at(*agi,*sri) * ac_ptStress(
            mapdist_matrix.at(*agi,*sri),
            tabledist_matrix.at(*agi,*sri),
            titertype_matrix.at(*agi,*sri),
            dilution_stepsize
          );
        }
      }

      return stress;
    }

    // ========================================================================
    // UPDATE MAP DISTANCE MATRIX
    // ========================================================================
    void update_map_dist_matrix(){
      for(sri = included_srs.begin(); sri != sri_end; ++sri) {
        for(agi = included_ags.begin(); agi != agi_end; ++agi) {
          if(titertype_matrix.at(*agi,*sri) <= 0) continue;

          mapdist_matrix.at(*agi,*sri) = sqrt(arma::accu(arma::square(
            ag_coords.row(*agi) - sr_coords.row(*sri)
          )));
        }
      }
    }

    // ========================================================================
    // GET COLUMN BASES
    // ========================================================================
    arma::vec get_colbases() const {
      return colbases;
    }

};


// ============================================================================
// HELPER FUNCTION: Create initial parameter matrix
// ============================================================================
arma::mat create_initial_pars(
    const arma::mat &ag_coords,
    const arma::mat &sr_coords,
    const arma::uvec &moveable_ags,
    const arma::uvec &moveable_sr,
    const arma::vec &colbases,
    const arma::uvec &moveable_colbases,
    bool optimize_colbases
) {
  arma::uword num_dims = ag_coords.n_cols;
  arma::uword coord_rows = moveable_ags.n_elem + moveable_sr.n_elem;
  arma::uword total_rows = coord_rows;
  
  if (optimize_colbases) {
    total_rows += moveable_colbases.n_elem;
  }
  
  arma::mat pars(total_rows, num_dims, arma::fill::zeros);
  
  for (arma::uword i = 0; i < moveable_ags.n_elem; ++i) {
    pars.row(i) = ag_coords.row(moveable_ags(i));
  }
  
  for (arma::uword i = 0; i < moveable_sr.n_elem; ++i) {
    pars.row(i + moveable_ags.n_elem) = sr_coords.row(moveable_sr(i));
  }
  
  if (optimize_colbases) {
    for (arma::uword i = 0; i < moveable_colbases.n_elem; ++i) {
      pars.at(coord_rows + i, 0) = colbases(moveable_colbases(i));
    }
  }
  
  return pars;
}


// ============================================================================
// EXPORTED FUNCTIONS
// ============================================================================

// [[Rcpp::export]]
double ac_coords_stress(
    const AcTiterTable &titers,
    const std::string &min_colbasis,
    const arma::vec &fixed_colbases,
    const arma::vec &ag_reactivity_adjustments,
    arma::mat &ag_coords,
    arma::mat &sr_coords,
    double dilution_stepsize
){
  int num_dims = ag_coords.n_cols;

  MapOptimizer map(
      ag_coords,
      sr_coords,
      titers.numeric_table_distances(
        min_colbasis,
        fixed_colbases,
        ag_reactivity_adjustments
      ),
      titers.get_titer_types(),
      num_dims,
      dilution_stepsize
  );

  return map.calculate_stress();
}

// [[Rcpp::export]]
arma::mat ac_point_stresses(
    AcTiterTable titer_table,
    std::string min_colbasis,
    arma::vec fixed_colbases,
    arma::vec ag_reactivity_adjustments,
    arma::mat map_dists,
    double dilution_stepsize
){
  arma::uword num_ags = map_dists.n_rows;
  arma::uword num_sr  = map_dists.n_cols;
  arma::mat numeric_table_dists = titer_table.numeric_table_distances(
    min_colbasis,
    fixed_colbases,
    ag_reactivity_adjustments
  );
  arma::imat titer_types = titer_table.get_titer_types();

  arma::mat stress_table(num_ags, num_sr);

  for (arma::uword ag = 0; ag < num_ags; ag++) {
    for (arma::uword sr = 0; sr < num_sr; sr++) {
      if (std::isnan(map_dists(ag, sr))) {
        stress_table(ag, sr) = arma::datum::nan;
      } else {
        stress_table(ag, sr) = ac_ptStress(
          map_dists(ag, sr),
          numeric_table_dists(ag, sr),
          titer_types(ag, sr),
          dilution_stepsize
        );
      }
    }
  }

  return(stress_table);
}


// [[Rcpp::export]]
arma::mat ac_point_residuals(
    const AcMap &map,
    const arma::uword &optimization_number
){
  arma::uword num_ags = map.antigens.size();
  arma::uword num_sr  = map.sera.size();
  arma::mat numeric_table_dists = map.optimizations.at(optimization_number).numeric_table_distances(
    map.titer_table_flat
  );
  arma::imat titer_types = map.titer_table_flat.get_titer_types();
  arma::mat map_dists = map.optimizations.at(optimization_number).distance_matrix();
  double dilution_stepsize = map.dilution_stepsize;

  arma::mat residual_table(num_ags, num_sr);

  for (arma::uword ag = 0; ag < num_ags; ag++) {
    for (arma::uword sr = 0; sr < num_sr; sr++) {
      if (std::isnan(map_dists(ag, sr))) {
        residual_table(ag, sr) = arma::datum::nan;
      } else {
        residual_table(ag, sr) = ac_ptResidual(
          map_dists(ag, sr),
          numeric_table_dists(ag, sr),
          titer_types(ag, sr),
          dilution_stepsize
        );
      }
    }
  }

  return(residual_table);
}


// [[Rcpp::export]]
double ac_relax_coords(
    const arma::mat &tabledist_matrix,
    const arma::imat &titertype_matrix,
    arma::mat &ag_coords,
    arma::mat &sr_coords,
    const AcOptimizerOptions &options,
    const arma::uvec &fixed_antigens,
    const arma::uvec &fixed_sera,
    const arma::mat &titer_weights,
    const double &dilution_stepsize
){
  arma::uvec ag_fixed(ag_coords.n_rows, arma::fill::zeros);
  arma::uvec sr_fixed(sr_coords.n_rows, arma::fill::zeros);
  ag_fixed.elem(fixed_antigens).ones();
  sr_fixed.elem(fixed_sera).ones();
  ag_fixed.elem(arma::find_nonfinite(ag_coords.col(0))).ones();
  sr_fixed.elem(arma::find_nonfinite(sr_coords.col(0))).ones();

  MapOptimizer map(
    ag_coords,
    sr_coords,
    tabledist_matrix,
    titertype_matrix,
    ag_coords.n_cols,
    ag_fixed,
    sr_fixed,
    titer_weights,
    dilution_stepsize
  );

  arma::mat pars = arma::join_cols(
    ag_coords.rows(arma::find(ag_fixed == 0)),
    sr_coords.rows(arma::find(sr_fixed == 0))
  );

  ens::L_BFGS lbfgs(
    options.num_basis,
    options.maxit,
    options.armijo_constant,
    options.wolfe,
    options.min_gradient_norm,
    options.factr,
    options.max_line_search_trials,
    options.min_step,
    options.max_step
  );

  lbfgs.Optimize(map, pars);

  ag_coords = map.ag_coords;
  sr_coords = map.sr_coords;
  return map.calculate_stress();
}


// [[Rcpp::export]]
Rcpp::List ac_relax_coords_with_colbases(
    const arma::mat &logtiter_matrix,
    const arma::imat &titertype_matrix,
    arma::mat &ag_coords,
    arma::mat &sr_coords,
    arma::vec &colbases,
    const AcOptimizerOptions &options,
    const arma::uvec &fixed_antigens,
    const arma::uvec &fixed_sera,
    const arma::mat &titer_weights,
    const double &dilution_stepsize
){
  arma::uword num_dims = ag_coords.n_cols;
  arma::uword num_ags = ag_coords.n_rows;
  arma::uword num_sr = sr_coords.n_rows;
  
  arma::uvec ag_fixed(num_ags, arma::fill::zeros);
  arma::uvec sr_fixed(num_sr, arma::fill::zeros);
  ag_fixed.elem(fixed_antigens).ones();
  sr_fixed.elem(fixed_sera).ones();
  ag_fixed.elem(arma::find_nonfinite(ag_coords.col(0))).ones();
  sr_fixed.elem(arma::find_nonfinite(sr_coords.col(0))).ones();

  MapOptimizer map(
    ag_coords,
    sr_coords,
    logtiter_matrix,
    titertype_matrix,
    colbases,
    num_dims,
    ag_fixed,
    sr_fixed,
    titer_weights,
    dilution_stepsize,
    true
  );

  arma::mat pars = create_initial_pars(
    ag_coords,
    sr_coords,
    map.moveable_ags,
    map.moveable_sr,
    colbases,
    map.moveable_colbases,
    true
  );

  ens::L_BFGS lbfgs(
    options.num_basis,
    options.maxit,
    options.armijo_constant,
    options.wolfe,
    options.min_gradient_norm,
    options.factr,
    options.max_line_search_trials,
    options.min_step,
    options.max_step
  );

  lbfgs.Optimize(map, pars);

  ag_coords = map.ag_coords;
  sr_coords = map.sr_coords;
  colbases = map.get_colbases();
  double final_stress = map.calculate_stress();

  return Rcpp::List::create(
    Rcpp::Named("stress") = final_stress,
    Rcpp::Named("ag_coords") = ag_coords,
    Rcpp::Named("sr_coords") = sr_coords,
    Rcpp::Named("colbases") = colbases
  );
}


// ============================================================================
// GENERATE OPTIMIZATIONS
// ============================================================================

std::vector<AcOptimization> ac_generateOptimizations(
    const arma::mat &tabledist_matrix,
    const arma::imat &titertype_matrix,
    const std::string &min_colbasis,
    const arma::vec &fixed_colbases,
    const arma::vec &ag_reactivity_adjustments,
    const int &num_dims,
    const int &num_optimizations,
    const AcOptimizerOptions &options,
    const double &dilution_stepsize
){
  int num_ags = tabledist_matrix.n_rows;
  int num_sr = tabledist_matrix.n_cols;

  AcOptimization initial_optim = AcOptimization(
    num_dims,
    num_ags,
    num_sr,
    min_colbasis,
    fixed_colbases,
    ag_reactivity_adjustments
  );

  initial_optim.randomizeCoords( tabledist_matrix.max() );
  initial_optim.relax_from_raw_matrices(
    tabledist_matrix,
    titertype_matrix,
    options,
    arma::uvec(),
    arma::uvec(),
    arma::mat(),
    dilution_stepsize
  );

  arma::mat distmat = initial_optim.distance_matrix();
  double coord_maxdist = distmat.max();
  double coord_boxsize = coord_maxdist*2;

  std::vector<AcOptimization> optimizations;
  for(int i=0; i<num_optimizations; i++){
    AcOptimization optimization(
        num_dims,
        num_ags,
        num_sr,
        min_colbasis,
        fixed_colbases,
        ag_reactivity_adjustments
    );
    optimization.randomizeCoords(coord_boxsize);
    optimizations.push_back(optimization);
  }

  return optimizations;
}


// ============================================================================
// RELAX OPTIMIZATIONS (original - fixed column bases)
// ============================================================================

void ac_relaxOptimizations(
  std::vector<AcOptimization>& optimizations,
  arma::uword num_dims,
  const arma::mat &tabledist_matrix,
  const arma::imat &titertype_matrix,
  const AcOptimizerOptions &options,
  const arma::mat &titer_weights,
  const double &dilution_stepsize
){
  int num_optimizations = optimizations.size();

  if(options.report_progress) REprintf("Performing %d optimizations\n", num_optimizations);
  AcProgressBar pb(options.progress_bar_length, options.report_progress);
  Progress p(num_optimizations, true, pb);

  arma::uvec dim_set { num_dims };
  if (options.dim_annealing) {
    dim_set.set_size(2);
    dim_set(0) = 5;
    dim_set(1) = num_dims;
  }

  #pragma omp parallel for schedule(dynamic) num_threads(options.num_cores)
  for (int i=0; i<num_optimizations; i++) {
    if (!p.check_abort()) {
      p.increment();

      for (arma::uword j=0; j<dim_set.n_elem; j++) {
        optimizations.at(i).relax_from_raw_matrices(
            tabledist_matrix,
            titertype_matrix,
            options,
            arma::uvec(),
            arma::uvec(),
            titer_weights,
            dilution_stepsize
        );

        if (dim_set(j) != num_dims) {
          optimizations.at(i).reduceDimensions(dim_set(j + 1));
        }
      }
    }
  }

  if (p.is_aborted()) {
    ac_error("Optimization runs interrupted");
  } else {
    pb.complete("Optimization runs complete");
  }
}


// ============================================================================
// RELAX OPTIMIZATIONS WITH COLUMN BASES
// ============================================================================

void ac_relaxOptimizations_with_colbases(
  std::vector<AcOptimization>& optimizations,
  arma::uword num_dims,
  const arma::mat &logtiter_matrix,
  const arma::imat &titertype_matrix,
  const arma::vec &initial_colbases,
  const AcOptimizerOptions &options,
  const arma::mat &titer_weights,
  const double &dilution_stepsize
){
  int num_optimizations = optimizations.size();

  if(options.report_progress) REprintf("Performing %d optimizations (with colbase optimization)\n", num_optimizations);
  AcProgressBar pb(options.progress_bar_length, options.report_progress);
  Progress p(num_optimizations, true, pb);

  arma::uvec dim_set { num_dims };
  if (options.dim_annealing) {
    dim_set.set_size(2);
    dim_set(0) = 5;
    dim_set(1) = num_dims;
  }

  #pragma omp parallel for schedule(dynamic) num_threads(options.num_cores)
  for (int i = 0; i < num_optimizations; i++) {
    if (!p.check_abort()) {
      p.increment();

      arma::vec opt_colbases = initial_colbases;

      for (arma::uword j = 0; j < dim_set.n_elem; j++) {
        arma::mat ag_coords = optimizations.at(i).agCoords();
        arma::mat sr_coords = optimizations.at(i).srCoords();

        Rcpp::List result = ac_relax_coords_with_colbases(
          logtiter_matrix,
          titertype_matrix,
          ag_coords,
          sr_coords,
          opt_colbases,
          options,
          arma::uvec(),
          arma::uvec(),
          titer_weights,
          dilution_stepsize
        );

        optimizations.at(i).set_ag_base_coords(Rcpp::as<arma::mat>(result["ag_coords"]));
        optimizations.at(i).set_sr_base_coords(Rcpp::as<arma::mat>(result["sr_coords"]));
        optimizations.at(i).set_stress(Rcpp::as<double>(result["stress"]));
        
        opt_colbases = Rcpp::as<arma::vec>(result["colbases"]);
        optimizations.at(i).set_fixed_column_bases(opt_colbases, false);

        if (dim_set(j) != num_dims) {
          optimizations.at(i).reduceDimensions(dim_set(j + 1));
        }
      }
    }
  }

  if (p.is_aborted()) {
    ac_error("Optimization runs interrupted");
  } else {
    pb.complete("Optimization runs complete");
  }
}


// ============================================================================
// RUN OPTIMIZATIONS (main entry point) - ONLY ONE VERSION
// ============================================================================

// [[Rcpp::export]]
std::vector<AcOptimization> ac_runOptimizations(
    const AcTiterTable &titertable,
    const std::string &minimum_col_basis,
    const arma::vec &fixed_colbases,
    const arma::vec &ag_reactivity_adjustments,
    const arma::uword &num_dims,
    const arma::uword &num_optimizations,
    const AcOptimizerOptions &options,
    const arma::mat &titer_weights,
    const double &dilution_stepsize
){
  arma::uword num_ags = titertable.nags();
  arma::uword num_sr = titertable.nsr();

  // Check if we should optimize column bases
  bool optimize_colbases = options.optimize_colbases;

  // Calculate log titer matrix
  arma::mat logtiter_matrix = arma::log2(titertable.get_numeric_titers() / 10.0);
  logtiter_matrix.each_col() += ag_reactivity_adjustments;
  
  arma::imat titertype_matrix = titertable.get_titer_types();

  // Set initial column bases
  arma::vec initial_colbases = titertable.calc_colbases(
    minimum_col_basis,
    fixed_colbases,
    ag_reactivity_adjustments
  );

  // Compute initial table distance matrix
  arma::mat tabledist_matrix(num_ags, num_sr);
  for (arma::uword sr = 0; sr < num_sr; ++sr) {
    for (arma::uword ag = 0; ag < num_ags; ++ag) {
      if (titertype_matrix(ag, sr) > 0) {
        tabledist_matrix(ag, sr) = initial_colbases(sr) - logtiter_matrix(ag, sr);
      } else {
        tabledist_matrix(ag, sr) = arma::datum::nan;
      }
    }
  }

  // Determine starting dimensions
  arma::uword start_dims;
  if (options.dim_annealing && num_dims < 5) {
    start_dims = 5;
  } else {
    start_dims = num_dims;
  }

  // Generate optimizations
  std::vector<AcOptimization> optimizations = ac_generateOptimizations(
    tabledist_matrix,
    titertype_matrix,
    minimum_col_basis,
    fixed_colbases,
    ag_reactivity_adjustments,
    start_dims,
    num_optimizations,
    options,
    dilution_stepsize
  );

  // Relax optimizations
  if (optimize_colbases) {
    ac_relaxOptimizations_with_colbases(
      optimizations,
      num_dims,
      logtiter_matrix,
      titertype_matrix,
      initial_colbases,
      options,
      titer_weights,
      dilution_stepsize
    );
  } else {
    ac_relaxOptimizations(
      optimizations,
      num_dims,
      tabledist_matrix,
      titertype_matrix,
      options,
      titer_weights,
      dilution_stepsize
    );
  }

  // Sort and align
  sort_optimizations_by_stress(optimizations);
  align_optimizations(optimizations);

  return optimizations;
}


# ================================================
# FILE: src/ac_optim_map_stress.h
# ================================================


# include <RcppArmadillo.h>
# include "acmap_map.h"
# include "ac_optimizer_options.h"

#ifndef Racmacs__ac_optim_map_stress__h
#define Racmacs__ac_optim_map_stress__h

// Generating optimizations with randomised coords
std::vector<AcOptimization> ac_generateOptimizations(
    const arma::mat &tabledist_matrix,
    const arma::imat &titertype_matrix,
    const std::string &min_colbasis,
    const arma::vec &fixed_colbases,
    const arma::vec &ag_reactivity_adjustments,
    const int &num_dims,
    const int &num_optimizations,
    const AcOptimizerOptions &options,
    const double &dilution_stepsize = 1.0
);

// Relaxing optimizations
void ac_relaxOptimizations(
    std::vector<AcOptimization>& optimizations,
    arma::uword num_dims,
    const arma::mat &tabledist_matrix,
    const arma::imat &titertype_matrix,
    const AcOptimizerOptions &options,
    const arma::mat &titer_weights = arma::mat(),
    const double &dilution_stepsize = 1.0
);

// Running optimizations
std::vector<AcOptimization> ac_runOptimizations(
    const AcTiterTable &titertable,
    const std::string &min_colbasis,
    const arma::vec &fixed_colbases,
    const arma::vec &ag_reactivity_adjustments,
    const arma::uword &num_dims,
    const arma::uword &num_optimizations,
    const AcOptimizerOptions &options,
    const arma::mat &titer_weights = arma::mat(),
    const double &dilution_stepsize = 1.0
);

// Sorting optimizations by stress
void sort_optimizations_by_stress(
    std::vector<AcOptimization> &optimizations
);

// Calculating residual error
arma::mat ac_point_residuals(
    const AcMap &map,
    const arma::uword &optimization_number
);

#endif


# ================================================
# FILE: src/ac_optimization.cpp
# ================================================


#include <RcppArmadillo.h>
#include "acmap_optimization.h"

// For optimization sorting
bool compare_optimization_stress(
    AcOptimization opt1,
    AcOptimization opt2
){
  if(!std::isfinite(opt1.stress)){
    return false;
  }
  if(!std::isfinite(opt2.stress)){
    return true;
  }
  return (opt1.stress < opt2.stress);
}

void sort_optimizations_by_stress(
    std::vector<AcOptimization>& optimizations
){
  std::sort(
    optimizations.begin(),
    optimizations.end(),
    [](const AcOptimization& a, const AcOptimization& b) {
      return a.stress < b.stress;
    }
  );
}


// For optimization alignment
void align_optimizations(
    std::vector<AcOptimization> &optimizations
){

  if(optimizations.size() > 1){
    for(arma::uword i=1; i<optimizations.size(); i++){
      optimizations.at(i).alignToOptimization(optimizations.at(0));
    }
  }

}



# ================================================
# FILE: src/ac_optimization.h
# ================================================


#include <RcppArmadillo.h>
#include "acmap_optimization.h"

#ifndef Racmacs__ac_optimization__h
#define Racmacs__ac_optimization__h

void sort_optimizations_by_stress(
    std::vector<AcOptimization> &optimizations
);


// For optimization alignment
void align_optimizations(
    std::vector<AcOptimization> &optimizations
);

#endif


# ================================================
# FILE: src/ac_optimize_ag_reactivity.cpp
# ================================================


#include <RcppArmadillo.h>
#include "acmap_optimization.h"
#include "acmap_titers.h"
#include "ac_optimization.h"
#include "ac_optim_map_stress.h"

// [[Rcpp::export]]
double ac_reactivity_adjustment_stress(
    const arma::vec &par,
    const arma::vec &fixed_ag_reactivities,
    const std::string &minimum_column_basis,
    const arma::vec &fixed_column_bases,
    const AcTiterTable &titertable,
    arma::mat ag_coords,
    arma::mat sr_coords,
    AcOptimizerOptions &options,
    const arma::uvec &fixed_antigens,
    const arma::uvec &fixed_sera,
    const arma::mat &titer_weights,
    const double &reactivity_stress_weighting,
    const bool reoptimize,
    const arma::uword num_optimizations,
    const double &dilution_stepsize
) {

  // Update reactivities with values from par
  arma::vec ag_reactivity_adjustments = fixed_ag_reactivities;
  ag_reactivity_adjustments.elem(arma::find_nonfinite(ag_reactivity_adjustments)) = par;

  // Get adjusted map stress
  double stress;
  if (reoptimize) {

    // Do not report progress
    options.report_progress = false;

    // Run the optimization
    std::vector<AcOptimization> optimizations;
    optimizations = ac_runOptimizations(
      titertable,
      minimum_column_basis,
      fixed_column_bases,
      ag_reactivity_adjustments,
      ag_coords.n_cols,
      num_optimizations,
      options,
      titer_weights,
      dilution_stepsize
    );

    // Sort by stress and keep lowest stress
    sort_optimizations_by_stress(optimizations);
    stress = optimizations.at(0).stress;

  } else {

    stress = ac_relax_coords(
      titertable.numeric_table_distances(
        minimum_column_basis,
        fixed_column_bases,
        ag_reactivity_adjustments
      ),
      titertable.get_titer_types(),
      ag_coords,
      sr_coords,
      options,
      fixed_antigens,
      fixed_sera,
      titer_weights
    );

  }

  // Increase map stress according to adjustment applied
  for (arma::uword i=0; i<ag_reactivity_adjustments.n_elem; i++) {
    stress += std::pow(ag_reactivity_adjustments(i) * reactivity_stress_weighting, 2);
  }
  return(stress);

}


# ================================================
# FILE: src/ac_optimizer_options.h
# ================================================


#ifndef Racmacs__ac_optimizer_options__h
#define Racmacs__ac_optimizer_options__h

// Optimizer options
struct AcOptimizerOptions {

  bool dim_annealing;
  std::string method;
  int maxit;
  int num_basis;
  double armijo_constant;
  double wolfe;
  double min_gradient_norm;
  double factr;
  int max_line_search_trials;
  double min_step;
  double max_step;
  int num_cores;
  bool report_progress;
  int progress_bar_length;

  // NEW: Toggle for optimizing column bases
  // When true, column bases become parameters to optimize alongside coordinates
  // When false (default), column bases are fixed at 0 (current behavior)
  bool optimize_colbases = false;
};

#endif


# ================================================
# FILE: src/ac_relax_coords.h
# ================================================


# include <RcppArmadillo.h>
# include "ac_optimizer_options.h"

#ifndef Racmacs__ac_relax_coords__h
#define Racmacs__ac_relax_coords__h

double ac_relax_coords(
    const arma::mat &tabledist_matrix,
    const arma::imat &titertype_matrix,
    arma::mat &ag_coords,
    arma::mat &sr_coords,
    const AcOptimizerOptions &options,
    const arma::uvec &fixed_antigens = arma::uvec(),
    const arma::uvec &fixed_sera = arma::uvec(),
    const arma::mat &titer_weights = arma::mat(),
    const double &dilution_stepsize = 1.0
);

#endif


# ================================================
# FILE: src/ac_stress_blobs.cpp
# ================================================


#include <RcppArmadillo.h>
#include "acmap_titers.h"
#include "ac_stress.h"
#include "ac_stress_blobs.h"

// For calculating the point stress at each grid point
double point_stress(
    arma::vec &mapdists,
    arma::vec &tabledists,
    arma::ivec &titertypes,
    double &dilution_stepsize
) {

  double stress = 0;

  for(arma::uword i=0; i<mapdists.n_elem; i++){

    // Skip unmeasured titers
    if(titertypes(i) == 0){
      continue;
    }

    // Now calculate the stress
    stress += ac_ptStress(
      mapdists(i),
      tabledists(i),
      titertypes(i),
      dilution_stepsize
    );

  }

  return stress;

}

// For updating the map distances
void update_map_dists(
    arma::vec &mapdists,
    arma::vec &testcoords,
    arma::mat &coords
){

  for(arma::uword n=0; n<mapdists.n_elem; n++){
    double dist = 0;
    for(arma::uword i = 0; i < coords.n_cols; ++i) {
      dist += pow(testcoords(i) - coords(n, i), 2);
    }
    mapdists(n) = sqrt(dist);
  }

}

// [[Rcpp::export]]
StressBlobGrid ac_stress_blob_grid(
    arma::vec testcoords,
    arma::mat coords,
    arma::vec tabledists,
    arma::ivec titertypes,
    double stress_lim,
    double grid_spacing,
    double dilution_stepsize
){

  // Get the map dimensions
  arma::uword mapdims = coords.n_cols;

  // Set grid coordinates
  double xmin = arma::min(coords.col(0) - tabledists - stress_lim);
  double xmax = arma::max(coords.col(0) + tabledists + stress_lim);
  arma::vec xcoords = arma::regspace<arma::vec>( xmin, grid_spacing, xmax );

  double ymin = arma::min(coords.col(1) - tabledists - stress_lim);
  double ymax = arma::max(coords.col(1) + tabledists + stress_lim);
  arma::vec ycoords = arma::regspace<arma::vec>( ymin, grid_spacing, ymax );

  arma::vec zcoords;
  if(mapdims == 3){
    double zmin = arma::min(coords.col(2) - tabledists - stress_lim);
    double zmax = arma::max(coords.col(2) + tabledists + stress_lim);
    zcoords = arma::regspace<arma::vec>( zmin, grid_spacing, zmax );
  } else {
    zcoords = arma::vec{0};
  }

  // Calculate the initial point stress
  arma::vec mapdists(coords.n_rows);
  update_map_dists(mapdists, testcoords, coords);
  double base_stress = point_stress(
    mapdists,
    tabledists,
    titertypes,
    dilution_stepsize
  );

  // Setup results grid
  arma::cube stressmat(xcoords.n_elem, ycoords.n_elem, zcoords.n_elem);
  for(arma::uword i=0; i<xcoords.n_elem; i++){
    for(arma::uword j=0; j<ycoords.n_elem; j++){
      for(arma::uword k=0; k<zcoords.n_elem; k++){

        // Update map distances
        testcoords(0) = xcoords(i);
        testcoords(1) = ycoords(j);
        if(mapdims == 3){
          testcoords(2) = zcoords(k);
        }
        update_map_dists(mapdists, testcoords, coords);

        // Calculate point stress
        stressmat(i,j,k) = point_stress(
          mapdists,
          tabledists,
          titertypes,
          dilution_stepsize
        );

      }
    }
  }

  // Setup for output
  struct StressBlobGrid results{
    stressmat - base_stress,
    xcoords,
    ycoords,
    zcoords,
    stress_lim
  };

  // Return the matrix result
  return results;

}





# ================================================
# FILE: src/ac_stress_blobs.h
# ================================================


#include <RcppArmadillo.h>

#ifndef Racmacs__ac_stress_blobs__h
#define Racmacs__ac_stress_blobs__h

struct StressBlobGrid {
  arma::cube grid;
  arma::vec xcoords;
  arma::vec ycoords;
  arma::vec zcoords;
  double stress_lim;
};

StressBlobGrid ac_stress_blob_grid(
    arma::vec testcoords,
    arma::mat coords,
    arma::vec tabledists,
    arma::ivec titertypes,
    double stress_lim = 1.0,
    double grid_spacing = 0.1,
    double dilution_stepsize = 1.0
);

#endif


# ================================================
# FILE: src/ac_stress.cpp
# ================================================


#include <RcppArmadillo.h>

// The threshold penalty function
double sigmoid(double &x){

  return(1/(1+exp(-10*x)));

}

// The derivative of the threshold penalty function
double d_sigmoid(double &x){

  return(sigmoid(x)*(1-sigmoid(x)));

}

// This is the point stress function
double ac_ptStress(
    double &map_dist,
    double &table_dist,
    arma::sword &titer_type,
    double &dilution_stepsize
  ){

  double x;
  double stress;

  switch(titer_type) {
  case 1:
    // Measurable titer
    stress = pow((table_dist - map_dist), 2);
    break;
  case 2:
    // Less than titer
    x = table_dist - map_dist + dilution_stepsize;
    stress = pow(x,2)*sigmoid(x);
    break;
  case 3:
    // More than titer
    stress = 0;
    break;
  default:
    // Missing titer
    stress = 0;
  }

  // Return the stress result
  return stress;

}

// This is the point residual function
double ac_ptResidual(
    double &map_dist,
    double &table_dist,
    arma::sword &titer_type,
    double &dilution_stepsize
){

  double x;
  double residual;

  switch(titer_type) {
  case 1:
    // Measurable titer
    residual = table_dist - map_dist;
    break;
  case 2:
    // Less than titer
    x = table_dist - map_dist + dilution_stepsize;
    residual = x*sigmoid(x);
    break;
  case 3:
    // More than titer
    residual = 0;
    break;
  default:
    // Missing titer
    residual = 0;
  }

  // Return the residual result
  return -residual;

}


// This is for calculating the inc_base part of the stress gradient function
double inc_base(
    double &map_dist,
    double &table_dist,
    arma::sword &titer_type,
    double &dilution_stepsize
  ){

  double ibase;
  double x;

  // Deal with 0 map distance
  if (map_dist == 0) {
    map_dist = 1e-5;
  }

  switch(titer_type) {
  case 1:
    // Measurable titer
    ibase = (2*(table_dist - map_dist)) / map_dist;
    break;
  case 2:
    // Less than titer
    x = table_dist - map_dist + dilution_stepsize;
    ibase = (10*x*x*d_sigmoid(x) + 2*x*sigmoid(x)) / map_dist;
    break;
  case 3:
    // More than titer
    ibase = 0;
    break;
  default:
    // Missing titer
    ibase = 0;
  }

  // Return the stress result
  return ibase;

}




# ================================================
# FILE: src/ac_stress.h
# ================================================


#include <RcppArmadillo.h>

#ifndef Racmacs__ac_stress__h
#define Racmacs__ac_stress__h

// The threshold penalty function
double sigmoid(double &x);

// The derivative of the threshold penalty function
double d_sigmoid(double &x);

// This is the point stress function
double ac_ptStress(
  double &map_dist,
  double &table_dist,
  arma::sword &titer_type,
  double &dilution_stepsize
);

// This is the point residual function
double ac_ptResidual(
    double &map_dist,
    double &table_dist,
    arma::sword &titer_type,
    double &dilution_stepsize
);

// This is the inc_base function used in the stress gradient function
double inc_base(
  double &map_dist,
  double &table_dist,
  arma::sword &titer_type,
  double &dilution_stepsize
);

#endif


# ================================================
# FILE: src/ac_titers.cpp
# ================================================


# include <RcppArmadillo.h>
# include "acmap_titers.h"

// Check titer validity
void check_valid_titer(
  std::string titer
){

  // Skip if titer at 0
  if(titer.at(0) != '*' || titer.length() != 1){

    // Remove first
    if(titer.at(0) == '<' || titer.at(0) == '>'){
      titer.erase(0,1);
    }

    // Check remaining values are valid numeric
    if(
      titer.at(0) == '0'
      || titer.find_first_not_of("0123456789") != std::string::npos
      ) {

      std::string msg = "Invalid titer '"+titer+"'";
      Rf_error("%s", msg.c_str());

    }

  }

}

// Get numeric titers from a vector of titers
// [[Rcpp::export]]
arma::vec numeric_titers(
    std::vector<AcTiter> titers
){

  arma::vec numerictiters(titers.size());
  for(arma::uword i=0; i<titers.size(); i++){
    if(titers[i].type <= 0){
      numerictiters[i] = arma::datum::nan;
    } else {
      numerictiters[i] = titers[i].numeric;
    }
  }
  return numerictiters;

}

// Get log titers from a vector of titers
// [[Rcpp::export]]
arma::vec log_titers(
    std::vector<AcTiter> titers,
    double dilution_stepsize
){

  arma::vec logtiters(titers.size());
  for(arma::uword i=0; i<titers.size(); i++){
    logtiters[i] = titers[i].logTiter(dilution_stepsize);
  }
  return logtiters;

}

// Get titer types from a vector of titers
// [[Rcpp::export]]
arma::ivec titer_types_int(
    std::vector<AcTiter> titers
){

  arma::ivec titertypes(titers.size());
  for(arma::uword i=0; i<titers.size(); i++){
    titertypes[i] = titers[i].type;
  }
  return titertypes;

}

// Make titers from numeric and titer types
// [[Rcpp::export]]
std::vector<AcTiter> make_titers(
    arma::vec numeric_titers,
    arma::ivec titer_types_int
){

  std::vector<AcTiter> titers(numeric_titers.n_elem);
  for(arma::uword i=0; i<numeric_titers.n_elem; i++){
    titers[i] = AcTiter(numeric_titers[i], titer_types_int[i]);
  }
  return titers;

}





# ================================================
# FILE: src/ac_titers.h
# ================================================


#include "acmap_titers.h"

#ifndef Racmacs__ac_titers__h
#define Racmacs__ac_titers__h

arma::vec numeric_titers(
    std::vector<AcTiter> titers
);

arma::vec log_titers(
    std::vector<AcTiter> titers,
    double dilution_stepsize
);

arma::ivec titer_types_int(
    std::vector<AcTiter> titers
);

void check_valid_titer(
    std::string titer
);

#endif


# ================================================
# FILE: src/ac_utils.cpp
# ================================================


#include <RcppArmadillo.h>

// Use principle component analysis to reduce coordinates to lower dimensions
// [[Rcpp::export]]
arma::mat reduce_matrix_dimensions(
    arma::mat m,
    int dim
){

  arma::mat coeff = arma::princomp(m);
  return m*coeff.cols(0, dim);

}



# ================================================
# FILE: src/acmap_diagnostics.h
# ================================================


#include <RcppArmadillo.h>
#include "ac_hemi_test.h"

#ifndef Racmacs__acmap_diagnostics__h
#define Racmacs__acmap_diagnostics__h

class AcDiagnostics {

  public:
    std::vector<HemiDiagnosis> hemi;

};

#endif


# ================================================
# FILE: src/acmap_map.cpp
# ================================================


#include "acmap_optimization.h"
#include "acmap_titers.h"
#include "acmap_point.h"
#include "acmap_map.h"
#include "ac_merge.h"
#include "ac_matching.h"
#include "ac_optim_map_stress.h"
#include "utils.h"

// AcMap
AcMap::AcMap(
  int num_ags,
  int num_sr
):
  titer_table_flat(num_ags, num_sr){

  // Set antigens
  antigens.resize(num_ags);
  for(int i=0; i<num_ags; i++){
    antigens[i].set_name("ANTIGEN "+std::to_string(i));
  }

  // Set sera
  sera.resize(num_sr);
  for(int i=0; i<num_sr; i++){
    sera[i].set_name("SERA "+std::to_string(i));
  }

  // Set point drawing order
  pt_drawing_order = arma::regspace<arma::uvec>(0, num_ags + num_sr - 1);

  // Set dilution stepsize
  dilution_stepsize = 1.0;

  // Set ag and sr group levels
  ag_group_levels.resize(0);
  sr_group_levels.resize(0);

  // Set ag reactivity adjustments
  ag_reactivity_adjustments.zeros(num_ags);

}

// Invalidate all calculated optimization stresses, for example when titers are changed
void AcMap::update_stresses() {
  for(auto &optimization : optimizations){
    optimization.update_stress(
      titer_table_flat,
      dilution_stepsize
    );
  }
};

// Get and set ag and sr group levels
std::vector<std::string> AcMap::get_ag_group_levels() const { return ag_group_levels; }
std::vector<std::string> AcMap::get_sr_group_levels() const { return sr_group_levels; }
void AcMap::set_ag_group_levels( std::vector<std::string> levels ){ ag_group_levels = levels; }
void AcMap::set_sr_group_levels( std::vector<std::string> levels ){ sr_group_levels = levels; }

// Get and set antigen reactivity adjustments
arma::vec AcMap::get_ag_reactivity_adjustments() const { return ag_reactivity_adjustments; }
double AcMap::get_ag_reactivity_adjustments(arma::uword i) const { return ag_reactivity_adjustments(i); }
void AcMap::set_ag_reactivity_adjustments( arma::vec ag_reactivity_adjustments_in ) {
  ag_reactivity_adjustments = ag_reactivity_adjustments_in;
}

// Get and set titers from a single titer table, resetting any layers
AcTiterTable AcMap::get_titer_table() const {
  return titer_table_flat;
}

void AcMap::set_titer_table(
    AcTiterTable titers
){
  titer_table_flat = titers;
  titer_table_layers.clear();
  update_stresses();
}

// Get and set the flat version of the titer table directly
AcTiterTable AcMap::get_titer_table_flat() const {
  return titer_table_flat;
}

void AcMap::set_titer_table_flat(
    AcTiterTable titers
){
  titer_table_flat = titers;
  update_stresses();
}

// Get and set titers from vector of titer layers
std::vector<AcTiterTable> AcMap::get_titer_table_layers() const {
  if(titer_table_layers.size() == 0){
    return std::vector<AcTiterTable>{ titer_table_flat };
  } else {
    return titer_table_layers;
  }
}

void AcMap::set_titer_table_layers(
    const std::vector<AcTiterTable> titers,
    const AcMergeOptions& merge_options
){
  titer_table_flat = ac_merge_titer_layers(titers, merge_options);
  titer_table_layers = titers;
  update_stresses();
}

// Remove antigen(s)
void AcMap::remove_antigen(int agnum){

  // Deal with homologous serum records
  arma::uvec ag_indices = arma::regspace<arma::uvec>(0, antigens.size() - 1);
  ag_indices.shed_row(agnum);
  for (auto &serum : sera) {
    arma::uvec new_indices;
    for (arma::uword i=0; i<serum.homologous_ags.n_elem; i++) {
      for (arma::uword j=0; j<ag_indices.n_elem; j++) {
        if (serum.homologous_ags[i] == ag_indices[j]) {
          uvec_push(new_indices, j);
        }
      }
    }
    serum.homologous_ags = new_indices;
  }

  // Deal with titers
  titer_table_flat.remove_antigen(agnum);
  for(auto &titer_table_layer : titer_table_layers){
    titer_table_layer.remove_antigen(agnum);
  }

  // Deal with optimizations
  for(auto &optimization : optimizations){
    optimization.remove_antigen(agnum);
  }

  // Finally remove the antigen
  antigens.erase(antigens.begin()+agnum);

}

void AcMap::remove_antigens(arma::uvec agnums){

  for(arma::uword i=0; i<agnums.n_elem; i++){
    remove_antigen(agnums[i]);
  }

}

// Remove serum(s)
void AcMap::remove_serum(int srnum){
  sera.erase(sera.begin()+srnum);
  titer_table_flat.remove_serum(srnum);
  for(auto &titer_table_layer : titer_table_layers){
    titer_table_layer.remove_serum(srnum);
  }
  for(auto &optimization : optimizations){
    optimization.remove_serum(srnum);
  }
}

void AcMap::remove_sera(arma::uvec srnums){
  for(arma::uword i=0; i<srnums.n_elem; i++){
    remove_serum(srnums[i]);
  }
}

// Subsetting
void AcMap::subset(
    arma::uvec ags,
    arma::uvec sr
){

  // Check inputs
  if(ags.max() >= antigens.size()){
    Rcpp::stop("Antigen index out of range");
  }
  if(sr.max() >= sera.size()){
    Rcpp::stop("Sera index out of range");
  }

  // Deal with homologous serum records
  arma::uvec ag_indices = arma::regspace<arma::uvec>(0, antigens.size() - 1);
  ag_indices = ag_indices.elem(ags);
  for (auto &serum : sera) {
    arma::uvec new_indices;
    for (arma::uword i=0; i<serum.homologous_ags.n_elem; i++) {
      for (arma::uword j=0; j<ag_indices.n_elem; j++) {
        if (serum.homologous_ags[i] == ag_indices[j]) {
          uvec_push(new_indices, j);
        }
      }
    }
    serum.homologous_ags = new_indices;
  }

  // Define point indices of the subset
  arma::uvec pts = arma::join_cols(ags, sr + antigens.size());

  // Subset antigens
  std::vector<AcAntigen> new_antigens;
  for(arma::uword i=0; i<ags.size(); i++){
    arma::uword agnum = ags[i];
    new_antigens.push_back(antigens[agnum]);
  }
  antigens.swap(new_antigens);

  // Subset sera
  std::vector<AcSerum> new_sera;
  for(arma::uword i=0; i<sr.size(); i++){
    arma::uword srnum = sr[i];
    new_sera.push_back(sera[srnum]);
  }
  sera.swap(new_sera);

  // Subset titers
  titer_table_flat.subset(ags, sr);
  for(auto &titer_table_layer : titer_table_layers){
    titer_table_layer.subset(ags, sr);
  }

  // Subset optimizations
  for(auto &optimization : optimizations){
    optimization.subset(ags, sr);
  }

  // Subset antigen reactivity adjustments
  ag_reactivity_adjustments = ag_reactivity_adjustments.elem(ags);

  // Subset drawing order
  pt_drawing_order = pt_drawing_order.elem(pts); // Subset
  pt_drawing_order = arma::sort_index(pt_drawing_order); // Ordering twice means you retrieve
  pt_drawing_order = arma::sort_index(pt_drawing_order); // 1:nPoints numeric sequence

  // Update stresses
  update_stresses();

}

// Optimizations
int AcMap::num_optimizations(){
  return optimizations.size();
}

arma::mat AcMap::agCoords(
    int opt_num
) const {
  return optimizations.at(opt_num).agCoords();
}

arma::mat AcMap::srCoords(
    int opt_num
) const {
  return optimizations.at(opt_num).srCoords();
}

arma::mat AcMap::ptCoords(
    int opt_num
) const {
  return optimizations.at(opt_num).ptCoords();
}

// Antigen characteristics
std::vector<std::string> AcMap::agNames() const {
  int num_ags = antigens.size();
  std::vector<std::string> names(num_ags);
  for(arma::uword i=0; i<antigens.size(); i++){
    names[i] = antigens[i].get_name();
  }
  return names;
}

// Optimization
void AcMap::optimize(
    int num_dims,
    int num_optimizations,
    std::string min_col_basis,
    arma::vec fixed_col_bases,
    arma::vec ag_reactivity_adjustments,
    const AcOptimizerOptions &options,
    const arma::mat &titer_weights
){

  // Run optimizations
  optimizations = ac_runOptimizations(
    titer_table_flat,
    min_col_basis,
    fixed_col_bases,
    ag_reactivity_adjustments,
    num_dims,
    num_optimizations,
    options,
    titer_weights,
    dilution_stepsize
  );

}

// Shuffling optimizations
void AcMap::keepSingleOptimization(
    int i
){
  AcOptimization opt = optimizations.at(i);
  optimizations.clear();
  optimizations.push_back(opt);
}

// Aligning to other maps
void AcMap::realign_to_map(
    AcMap targetmap,
    int targetmap_optnum,
    bool translation,
    bool scaling,
    bool align_to_base_coords
){

  // Get matching antigens and sera
  arma::ivec matched_ags = ac_match_points( antigens, targetmap.antigens );
  arma::ivec matched_sr  = ac_match_points( sera, targetmap.sera );

  // Get the target map coords
  arma::mat target_ag_coords;
  arma::mat target_sr_coords;
  AcOptimization targetopt = targetmap.optimizations.at(targetmap_optnum);

  if(align_to_base_coords){
    target_ag_coords = subset_rows(targetopt.get_ag_base_coords(), matched_ags);
    target_sr_coords = subset_rows(targetopt.get_sr_base_coords(), matched_sr);
  } else {
    target_ag_coords = subset_rows(targetopt.agCoords(), matched_ags);
    target_sr_coords = subset_rows(targetopt.srCoords(), matched_sr);
  }
  arma::mat target_coords = arma::join_cols(target_ag_coords, target_sr_coords);

  // Realign each optimization
  for (auto &optimization : optimizations) {

    // Get the source map base coords
    arma::mat source_ag_coords = optimization.get_ag_base_coords();
    arma::mat source_sr_coords = optimization.get_sr_base_coords();
    arma::mat source_coords = arma::join_cols( source_ag_coords, source_sr_coords );

    // Calculate the procrustes
    Procrustes pc = ac_procrustes(
      source_coords,
      target_coords,
      translation,
      scaling
    );

    // Apply it to the optimization
    optimization.set_transformation( pc.R );
    optimization.set_translation( pc.tt );
    optimization.set_scaling( pc.s );

  }

}

// Point drawing order
arma::uvec AcMap::get_pt_drawing_order() const {
  return pt_drawing_order;
}

void AcMap::set_pt_drawing_order( const arma::uvec& order ){
  pt_drawing_order = order;
}

// Get and set layer names
std::vector<std::string> AcMap::get_layer_names() const {
  return layer_names;
}

void AcMap::set_layer_names( const std::vector<std::string> layer_names_in ){
  layer_names = layer_names_in;
}

// Determine if setting are defaults, useful when outputting to json
bool AcMap::isdefault(
    std::string attribute
) {

  if (attribute == "ag_group_levels") {
    return(ag_group_levels.size() == 0);
  }
  else if (attribute == "sr_group_levels") {
    return(sr_group_levels.size() == 0);
  }
  else if (attribute == "description") {
    return(description == "");
  }
  else if (attribute == "layer_names") {
    int i = 0;
    for(auto &layer_name : layer_names){
      if (layer_name != "") i++;
    }
    return(i == 0);
  } else if (attribute == "ag_reactivity") {
    return(
      arma::approx_equal(
        ag_reactivity_adjustments,
        arma::vec(antigens.size(), arma::fill::zeros),
        "absdiff", 0.0001
      )
    );
  } else if (attribute == "dilution_stepsize") {
    return(dilution_stepsize == 1);
  } else {
    return(false);
  }

}


# ================================================
# FILE: src/acmap_map.h
# ================================================


#include "acmap_optimization.h"
#include "acmap_titers.h"
#include "acmap_point.h"
#include "ac_merge.h"
#include "ac_matching.h"
#include "utils.h"

#ifndef Racmacs__acmap_map__h
#define Racmacs__acmap_map__h

// Define the acmap class
class AcMap {

  private:
    // EXTRAS
    std::vector<std::string> ag_group_levels;
    std::vector<std::string> sr_group_levels;
    arma::uvec pt_drawing_order;

  public:
    // ATTRIBUTES
    std::string name;
    std::string description;
    double dilution_stepsize;
    std::vector<AcOptimization> optimizations;
    std::vector<AcAntigen> antigens;
    std::vector<AcSerum> sera;
    AcTiterTable titer_table_flat;
    std::vector<AcTiterTable> titer_table_layers;
    std::vector<std::string> layer_names;
    arma::vec ag_reactivity_adjustments;

    // Getters
    arma::vec get_ag_reactivity_adjustments() const;
    double get_ag_reactivity_adjustments(arma::uword i) const;

    // Setters
    void set_ag_reactivity_adjustments( arma::vec ag_reactivity_adjustments_in );

    // Construct a new acmap
    AcMap(
      int num_ags,
      int num_sr
    );

    // Invalidate all calculated optimization stresses, for example when titers are changed
    void update_stresses();

    // Get and set ag and sr group levels
    std::vector<std::string> get_ag_group_levels() const;
    std::vector<std::string> get_sr_group_levels() const;
    void set_ag_group_levels( std::vector<std::string> levels );
    void set_sr_group_levels( std::vector<std::string> levels );

    // Get and set titers from a single titer table, resetting any layers
    AcTiterTable get_titer_table() const;

    void set_titer_table(
      AcTiterTable titers
    );

    // Get and set the flat version of the titer table directly
    AcTiterTable get_titer_table_flat() const;

    void set_titer_table_flat(
      AcTiterTable titers
    );

    // Get and set titers from vector of titer layers
    std::vector<AcTiterTable> get_titer_table_layers() const;

    void set_titer_table_layers(
      const std::vector<AcTiterTable> titers,
      const AcMergeOptions& merge_options
    );

    // Get and set layer names
    std::vector<std::string> get_layer_names() const;
    void set_layer_names(
      const std::vector<std::string> layer_names_in
    );

    // Remove antigen(s)
    void remove_antigen(int agnum);
    void remove_antigens(arma::uvec agnums);

    // Remove serum(s)
    void remove_serum(int srnum);
    void remove_sera(arma::uvec srnums);

    // Subsetting
    void subset(
      arma::uvec ags,
      arma::uvec sr
    );

    // Optimizations
    int num_optimizations();
    arma::mat agCoords(
      int opt_num = 0
    ) const;

    arma::mat srCoords(
        int opt_num = 0
    ) const;

    arma::mat ptCoords(
        int opt_num = 0
    ) const;

    // Antigen characteristics
    std::vector<std::string> agNames() const;

    // Optimization
    void optimize(
      int num_dims,
      int num_optimizations,
      std::string min_col_basis,
      arma::vec fixed_col_bases,
      arma::vec ag_reactivity_adjustments,
      const AcOptimizerOptions &options,
      const arma::mat &titer_weights = arma::mat()
    );

    // Shuffling optimizations
    void keepSingleOptimization(
      int i
    );

    // Aligning to other maps
    void realign_to_map(
      AcMap targetmap,
      int targetmap_optnum = 0,
      bool translation = true,
      bool scaling = false,
      bool align_to_base_coords = false
    );

    // Point drawing order
    arma::uvec get_pt_drawing_order() const;
    void set_pt_drawing_order( const arma::uvec& order );

    // Determine if setting are defaults, useful when outputting to json
    bool isdefault(
        std::string attribute
    );

};

#endif


# ================================================
# FILE: src/acmap_optimization.cpp
# ================================================


#include <RcppArmadillo.h>
#include "procrustes.h"
#include "utils.h"
#include "utils_error.h"
#include "utils_transformation.h"
#include "ac_titers.h"
#include "acmap_titers.h"
#include "acmap_diagnostics.h"
#include "ac_optimizer_options.h"
#include "ac_relax_coords.h"
#include "ac_coords_stress.h"
#include "ac_bootstrap_output.h"
#include "acmap_optimization.h"

// Constructors
AcOptimization::AcOptimization(
  const int &dimensions,
  const int &num_antigens,
  const int &num_sera
) {

  ag_base_coords = arma::mat(num_antigens, dimensions, arma::fill::zeros);
  sr_base_coords = arma::mat(num_sera, dimensions, arma::fill::zeros);
  transformation = arma::mat(dimensions, dimensions, arma::fill::eye);
  translation    = arma::mat(dimensions, 1, arma::fill::zeros);
  ag_diagnostics.resize(num_antigens);
  sr_diagnostics.resize(num_sera);

  min_column_basis = "none";
  fixed_column_bases = arma::vec(num_sera);
  fixed_column_bases.fill(arma::datum::nan);
  ag_reactivity_adjustments = arma::vec(num_antigens, arma::fill::zeros);

}

AcOptimization::AcOptimization(
  const int &dimensions,
  const int &num_antigens,
  const int &num_sera,
  const std::string &min_column_basis,
  const arma::vec &fixed_column_bases,
  const arma::vec &ag_reactivity_adjustments
)
  :min_column_basis(min_column_basis),
   fixed_column_bases(fixed_column_bases),
   ag_reactivity_adjustments(ag_reactivity_adjustments)
{

  ag_base_coords = arma::mat(num_antigens, dimensions, arma::fill::zeros);
  sr_base_coords = arma::mat(num_sera, dimensions, arma::fill::zeros);
  transformation = arma::mat(dimensions, dimensions, arma::fill::eye);
  translation    = arma::mat(dimensions, 1, arma::fill::zeros);
  ag_diagnostics.resize(num_antigens);
  sr_diagnostics.resize(num_sera);

}

// Getters
std::string AcOptimization::get_min_column_basis() const { return min_column_basis; }
arma::vec AcOptimization::get_fixed_column_bases() const { return fixed_column_bases; }
double AcOptimization::get_fixed_column_bases(arma::uword i) const { return fixed_column_bases(i); }
arma::vec AcOptimization::get_ag_reactivity_adjustments() const { return ag_reactivity_adjustments; }
double AcOptimization::get_ag_reactivity_adjustments(arma::uword i) const { return ag_reactivity_adjustments(i); }
std::string AcOptimization::get_comment() const { return comment; }
arma::mat AcOptimization::get_transformation() const { return transformation; }
arma::mat AcOptimization::get_translation() const { return translation; }
double AcOptimization::get_stress() const { return stress; }
int AcOptimization::get_dimensions() const { return ag_base_coords.n_cols; }

// Setters
void AcOptimization::set_comment( std::string comment_in ) { comment = comment_in; }
void AcOptimization::set_transformation( arma::mat transformation_in ) { transformation = transformation_in; }
void AcOptimization::set_translation( arma::mat translation_in ) { translation = translation_in; }
void AcOptimization::set_stress( double stress_in ) { stress = stress_in; }
void AcOptimization::set_ag_reactivity_adjustments( arma::vec ag_reactivity_adjustments_in ) {
  ag_reactivity_adjustments = ag_reactivity_adjustments_in;
}

void AcOptimization::set_fixed_column_bases(
    arma::vec fixed_column_bases_in,
    bool reset_stress
) {

  // Check fixed col bases validity
  if (fixed_column_bases_in.n_elem != sr_base_coords.n_rows) {
    Rf_error("Fixed column base length does not match the number of sera");
  }
  fixed_column_bases = fixed_column_bases_in;

  // Invalidate stress
  if (reset_stress) invalidate_stress();

}

void AcOptimization::set_min_column_basis(
    const std::string min_column_basis_in,
    bool reset_stress
) {

  // Check min col basis validity
  if (min_column_basis_in != "none") {
    check_valid_titer(min_column_basis_in);
  }

  // Set min col basis
  min_column_basis = min_column_basis_in;

  // Invalidate stress
  if (reset_stress) invalidate_stress();

}

// Update the currently calculated stress
void AcOptimization::update_stress(
    AcTiterTable titertable,
    double dilution_stepsize
) {

  stress = ac_coords_stress(
    titertable,
    min_column_basis,
    fixed_column_bases,
    ag_reactivity_adjustments,
    ag_base_coords,
    sr_base_coords,
    dilution_stepsize
  );

}

// Invalidate the currently calculated stress, for example when points are moved
void AcOptimization::invalidate_stress() { stress = arma::datum::nan; }

// Getting antigen base coords
arma::mat AcOptimization::get_ag_base_coords() const { return ag_base_coords; }
arma::vec AcOptimization::get_ag_base_coords( arma::uword& ag ) const {
  return arma::vectorise(
    ag_base_coords.row(ag)
  );
}

// Getting sera base coords
arma::mat AcOptimization::get_sr_base_coords() const { return sr_base_coords; }
arma::vec AcOptimization::get_sr_base_coords( arma::uword& sr ) const {
  return arma::vectorise(
    sr_base_coords.row(sr)
  );
}


// Setting antigen base coords
void AcOptimization::set_ag_base_coords( arma::mat ag_base_coords_in ) {
  // Check input
  if (ag_base_coords_in.n_rows != ag_base_coords.n_rows) {
    ac_error(
      "ag_base_coords rows (" + std::to_string(ag_base_coords.n_rows) + ")" +
      "does not match input rows (" + std::to_string(ag_base_coords_in.n_rows) + ")"
    );
  }
  // Update coords
  ag_base_coords = ag_base_coords_in;
  invalidate_stress();
}


// Setting sera base coords
void AcOptimization::set_sr_base_coords( arma::mat sr_base_coords_in ) {
  // Check input
  if (sr_base_coords_in.n_rows != sr_base_coords.n_rows) {
    ac_error(
      "sr_base_coords rows (" + std::to_string(sr_base_coords.n_rows) + ")" +
      "does not match input rows (" + std::to_string(sr_base_coords_in.n_rows) + ")"
    );
  }
  // Update coords
  sr_base_coords = sr_base_coords_in;
  invalidate_stress();
}


// Setting coords of a specific ag
void AcOptimization::set_ag_base_coords(
    arma::uword ag_index,
    arma::vec ag_base_coords_in
) {
  // Check input
  if (ag_base_coords_in.n_elem != ag_base_coords.n_cols) {
    ac_error(
      "antigen coords length (" + std::to_string(ag_base_coords_in.n_elem) + ")" +
      "exceeds antigen coords dimensions (" + std::to_string(ag_base_coords.n_cols) + ")"
    );
  }
  // Update coords
  for(arma::uword i=0; i<ag_base_coords.n_cols; i++) {
    ag_base_coords( ag_index, i ) = ag_base_coords_in(i);
  }
  invalidate_stress();
}


// Setting coords of a specific sr
void AcOptimization::set_sr_base_coords(
    arma::uword sr_index,
    arma::vec sr_base_coords_in
) {
  // Check input
  if (sr_base_coords_in.n_elem != sr_base_coords.n_cols) {
    ac_error(
      "sera coords length (" + std::to_string(sr_base_coords_in.n_elem) + ")" +
      "exceeds sera coords dimensions (" + std::to_string(sr_base_coords.n_cols) + ")"
    );
  }
  // Update coords
  for(arma::uword i=0; i<sr_base_coords.n_cols; i++) {
    ag_base_coords( sr_index, i ) = sr_base_coords_in(i);
  }
  invalidate_stress();
}


// Setting coords of a subset of ags
void AcOptimization::set_ag_base_coords(
    arma::uvec ag_indices,
    arma::mat ag_base_coords_in
) {
  // Check input
  if (ag_base_coords_in.n_rows != ag_indices.n_elem) {
    ac_error(
      "ag_indices length (" + std::to_string(ag_indices.n_elem) + ")" +
      "does not match input rows (" + std::to_string(ag_base_coords_in.n_rows) + ")"
    );
  }
  if (ag_indices.max() > ag_base_coords.n_rows - 1) {
    ac_error(
      "ag_indices max (" + std::to_string(ag_indices.max()) + ")" +
      "exceeds max antigen index (" + std::to_string(ag_base_coords.n_rows - 1) + ")"
    );
  }
  // Update coords
  ag_base_coords.rows( ag_indices ) = ag_base_coords_in;
  invalidate_stress();
}


// Setting coords of a subset of sr
void AcOptimization::set_sr_base_coords(
    arma::uvec sr_indices,
    arma::mat sr_base_coords_in
) {
  // Check input
  if (sr_base_coords_in.n_rows != sr_indices.n_elem) {
    ac_error(
      "sr_indices length (" + std::to_string(sr_indices.n_elem) + ")" +
      "does not match input rows (" + std::to_string(sr_base_coords_in.n_rows) + ")"
    );
  }
  if (sr_indices.max() > sr_base_coords.n_rows - 1) {
    ac_error(
      "sr_indices max (" + std::to_string(sr_indices.max()) + ")" +
      "exceeds max serum index (" + std::to_string(sr_base_coords.n_rows - 1) + ")"
    );
  }
  // Update coords
  sr_base_coords.rows( sr_indices ) = sr_base_coords_in;
  invalidate_stress();
}


// Get dimensions
int AcOptimization::dim() const {
  return ag_base_coords.n_cols;
}

int AcOptimization::num_ags() const {
  return ag_base_coords.n_rows;
}

int AcOptimization::num_sr() const {
  return sr_base_coords.n_rows;
}

// Retrieve point base coordinates (ag then sera)
arma::mat AcOptimization::ptBaseCoords() const {
  return arma::join_cols(
    ag_base_coords,
    sr_base_coords
  );
}

// Retrieve antigen coordinates
arma::mat AcOptimization::agCoords() const {
  return transform_coords(
    ag_base_coords,
    transformation,
    translation
  );
}

// Retrieve sera coordinates
arma::mat AcOptimization::srCoords() const {
  return transform_coords(
    sr_base_coords,
    transformation,
    translation
  );
}

// Retrieve point coordinates (ags then sr)
arma::mat AcOptimization::ptCoords() const {
  return arma::join_cols(
    agCoords(),
    srCoords()
  );
}

// Apply the optimization transform to an arbitrary set of coordinates
arma::mat AcOptimization::applyTransformation(
    arma::mat coords
) const {
  return transform_coords(
    coords,
    transformation,
    translation
  );
}

// Bake in the current transformation into the base coordinates
void AcOptimization::bake_transformation() {

  // Set the base coordinates
  ag_base_coords = agCoords();
  sr_base_coords = srCoords();

  // Reset transformation and translation
  set_transformation(
    arma::mat(dim(), dim(), arma::fill::eye)
  );
  set_translation(
    arma::mat(dim(), 1, arma::fill::zeros)
  );

}

// Set ag coordinates
void AcOptimization::set_ag_coords(
    arma::mat coords
) {
  bake_transformation();
  set_ag_base_coords(coords);
}

// Set sr coordinates
void AcOptimization::set_sr_coords(
    arma::mat coords
) {
  bake_transformation();
  set_sr_base_coords(coords);
}

// Align to another optimization
void AcOptimization::alignToOptimization(
    AcOptimization target
) {

  // Get coordinates
  arma::mat source_coords = ptBaseCoords();
  arma::mat target_coords = target.ptBaseCoords();

  // Perform procrustes
  Procrustes pc = ac_procrustes(
    source_coords,
    target_coords
  );

  // Set transformation
  transformation = pc.R;
  translation = pc.tt;

}

// Calculate the distance matrix
arma::mat AcOptimization::distance_matrix(
) const {

  int nags = num_ags();
  int nsr = num_sr();

  arma::mat distmat( nags, nsr );
  for(int ag=0; ag<nags; ag++) {
    for(int sr=0; sr<nsr; sr++) {
      distmat(ag, sr) = ptDist(ag, sr);
    }
  }

  return distmat;

}

// Calculate point distance
double AcOptimization::ptDist(
    int ag,
    int sr
) const {

  return euc_dist(
    arma::vectorise(ag_base_coords.row(ag)),
    arma::vectorise(sr_base_coords.row(sr))
  );

}

// Calculate the column bases
arma::vec AcOptimization::calc_colbases(
    AcTiterTable titers
) const {
  return titers.calc_colbases(
    min_column_basis,
    fixed_column_bases,
    ag_reactivity_adjustments
  );
}

// Reduce dimensions of optimization through principle component analysis
void AcOptimization::reduceDimensions(
    arma::uword dims
) {

  // Reduce coordinate dimensions
  arma::mat coords = arma::join_cols(
    ag_base_coords,
    sr_base_coords
  );
  arma::mat coeff = arma::princomp(coords);
  ag_base_coords = ag_base_coords * coeff.cols(0, dims - 1);
  sr_base_coords = sr_base_coords * coeff.cols(0, dims - 1);

  transformation.resize(dims, dims);
  translation.resize(dims, 1);

  invalidate_stress();

}

// Randomise coordinates
void AcOptimization::randomizeCoords(
    double boxsize
) {

  double min = -boxsize/2.0;
  double max = boxsize/2.0;
  ag_base_coords.randu();
  sr_base_coords.randu();
  ag_base_coords = ag_base_coords*(max-min) + min;
  sr_base_coords = sr_base_coords*(max-min) + min;
  invalidate_stress();

}

// Get table distances
arma::mat AcOptimization::numeric_table_distances(
    const AcTiterTable &titers
) const {

  return(
    titers.numeric_table_distances(
      min_column_basis,
      fixed_column_bases,
      ag_reactivity_adjustments
    )
  );

}

// Relax the optimization
void AcOptimization::relax_from_raw_matrices(
    const arma::mat &tabledist_matrix,
    const arma::imat &titertype_matrix,
    const AcOptimizerOptions options,
    const arma::uvec &fixed_antigens,
    const arma::uvec &fixed_sera,
    const arma::mat &titer_weights,
    const double &dilution_stepsize
) {

  stress = ac_relax_coords(
    tabledist_matrix,
    titertype_matrix,
    ag_base_coords,
    sr_base_coords,
    options,
    fixed_antigens,
    fixed_sera,
    titer_weights,
    dilution_stepsize
  );

}

void AcOptimization::relax_from_titer_table(
    AcTiterTable titers,
    const AcOptimizerOptions options,
    const arma::uvec &fixed_antigens,
    const arma::uvec &fixed_sera,
    const arma::mat &titer_weights,
    const double &dilution_stepsize
) {

  relax_from_raw_matrices(
    titers.numeric_table_distances(
      min_column_basis,
      fixed_column_bases,
      ag_reactivity_adjustments
    ),
    titers.get_titer_types(),
    options,
    fixed_antigens,
    fixed_sera,
    titer_weights,
    dilution_stepsize
  );

}

// Removing antigens and sera
void AcOptimization::remove_antigen(
    arma::uword ag
) {
  ag_base_coords.shed_row(ag);
  ag_diagnostics.erase(ag_diagnostics.begin() + ag);
  ag_reactivity_adjustments.shed_row(ag);
}

void AcOptimization::remove_serum(
    arma::uword sr
) {
  sr_base_coords.shed_row(sr);
  sr_diagnostics.erase(sr_diagnostics.begin() + sr);
  fixed_column_bases.shed_row(sr);
}

// Subsetting
void AcOptimization::subset(
    arma::uvec ags,
    arma::uvec sr
) {

  ag_base_coords = ag_base_coords.rows(ags);
  sr_base_coords = sr_base_coords.rows(sr);
  fixed_column_bases = fixed_column_bases.elem(sr);
  ag_reactivity_adjustments = ag_reactivity_adjustments.elem(ags);
  ag_diagnostics = subset_vector(ag_diagnostics, ags);
  sr_diagnostics = subset_vector(sr_diagnostics, sr);
  invalidate_stress();

}

// Transformation
void AcOptimization::transform(
    arma::mat transform_matrix
) {

  ac_transform_translation(
    translation,
    transform_matrix
  );

  ac_transform_transformation(
    transformation,
    transform_matrix
  );

}

// Translation
void AcOptimization::translate(
    arma::mat translation_matrix
) {

  ac_translate_translation(
    translation,
    translation_matrix
  );

}

// Rotation
void AcOptimization::rotate(
    double degrees,
    arma::uword axis_num
) {

  transform(
    ac_rotation_matrix(
      degrees,
      dim(),
      axis_num
    )
  );

}

// Reflection
void AcOptimization::reflect(
    arma::uword axis_num
) {

  transform(
    ac_reflection_matrix(
      dim(),
      axis_num
    )
  );

}

// Scale
void AcOptimization::scale(
    double scaling
) {

  transform(
    ac_scaling_matrix(
      dim(),
      scaling
    )
  );

}

// Set scaling
void AcOptimization::set_scaling(
    double scaling
) {

  double current_scaling = fabs(arma::det(transformation));
  double scaling_diff = scaling / current_scaling;
  scale(scaling_diff);

}

// Check if values are still the default (used when outputting to json)
bool AcOptimization::isdefault(
    std::string attribute
) {

  if (attribute == "fixed_column_bases") {

    return(
      arma::accu(arma::find_finite(fixed_column_bases)) == 0
    );

  } else if (attribute == "minimum_column_basis") {

    return(
      min_column_basis == "none"
    );

  } else if (attribute == "comment") {

    return(
      comment == ""
    );

  } else if (attribute == "transformation") {

    return(
      arma::approx_equal(
        transformation,
        arma::mat(ag_base_coords.n_cols, ag_base_coords.n_cols, arma::fill::eye),
        "absdiff", 0.0001
      )
    );

  } else if (attribute == "translation") {

    return(
      arma::approx_equal(
        translation,
        arma::mat(ag_base_coords.n_cols, 1, arma::fill::zeros),
        "absdiff", 0.0001
      )
    );

  } else if (attribute == "ag_reactivity") {

    return(
      arma::approx_equal(
        ag_reactivity_adjustments,
        arma::vec(ag_base_coords.n_rows, arma::fill::zeros),
        "absdiff", 0.0001
      )
    );

  } else if (attribute == "bootstrap") {

    return(
      bootstrap.size() == 0
    );

  } else {

    return(false);

  }

}




# ================================================
# FILE: src/acmap_optimization.h
# ================================================


#include <RcppArmadillo.h>
#include "procrustes.h"
#include "utils.h"
#include "utils_error.h"
#include "utils_transformation.h"
#include "ac_titers.h"
#include "acmap_titers.h"
#include "acmap_diagnostics.h"
#include "ac_optimizer_options.h"
#include "ac_relax_coords.h"
#include "ac_coords_stress.h"
#include "ac_bootstrap_output.h"

#ifndef Racmacs__acmap_optimization__h
#define Racmacs__acmap_optimization__h

// Define the optimization class
class AcOptimization {

  private:

    std::string min_column_basis;
    arma::vec fixed_column_bases;
    arma::vec ag_reactivity_adjustments;
    arma::mat ag_base_coords;
    arma::mat sr_base_coords;
    std::string comment;
    arma::mat transformation;
    arma::mat translation;

  public:

    std::vector<AcDiagnostics> ag_diagnostics;
    std::vector<AcDiagnostics> sr_diagnostics;
    std::vector<BootstrapOutput> bootstrap;
    double stress = arma::datum::nan;

    // Constructors
    AcOptimization(
      const int &dimensions,
      const int &num_antigens,
      const int &num_sera
    );

    AcOptimization(
      const int &dimensions,
      const int &num_antigens,
      const int &num_sera,
      const std::string &min_column_basis,
      const arma::vec &fixed_column_bases,
      const arma::vec &ag_reactivity_adjustments
    );

    // Getters
    std::string get_min_column_basis() const;
    arma::vec get_fixed_column_bases() const;
    double get_fixed_column_bases(arma::uword i) const;
    arma::vec get_ag_reactivity_adjustments() const;
    double get_ag_reactivity_adjustments(arma::uword i) const;
    std::string get_comment() const;
    arma::mat get_transformation() const;
    arma::mat get_translation() const;
    double get_stress() const;
    int get_dimensions() const;

    // Setters
    void set_comment( std::string comment_in );
    void set_transformation( arma::mat transformation_in );
    void set_translation( arma::mat translation_in );
    void set_stress( double stress_in );
    void set_ag_reactivity_adjustments( arma::vec ag_reactivity_adjustments_in );

    void set_fixed_column_bases(
      arma::vec fixed_column_bases_in,
      bool reset_stress = true
    );

    void set_min_column_basis(
      const std::string min_column_basis_in,
      bool reset_stress = true
    );

    // Update the currently calculated stress
    void update_stress(
      AcTiterTable titertable,
      double dilution_stepsize
    );

    // Invalidate the currently calculated stress, for example when points are moved
    void invalidate_stress();

    // Getting antigen base coords
    arma::mat get_ag_base_coords() const;
    arma::vec get_ag_base_coords( arma::uword& ag ) const;

    // Getting sera base coords
    arma::mat get_sr_base_coords() const;
    arma::vec get_sr_base_coords( arma::uword& sr ) const;

    // Setting antigen base coords
    void set_ag_base_coords( arma::mat ag_base_coords_in );

    // Setting sera base coords
    void set_sr_base_coords( arma::mat sr_base_coords_in );

    // Setting coords of a specific ag
    void set_ag_base_coords(
        arma::uword ag_index,
        arma::vec ag_base_coords_in
    );

    // Setting coords of a specific sr
    void set_sr_base_coords(
        arma::uword sr_index,
        arma::vec sr_base_coords_in
    );

    // Setting coords of a subset of ags
    void set_ag_base_coords(
        arma::uvec ag_indices,
        arma::mat ag_base_coords_in
    );

    // Setting coords of a subset of sr
    void set_sr_base_coords(
        arma::uvec sr_indices,
        arma::mat sr_base_coords_in
    );

    // Get dimensions
    int dim() const;
    int num_ags() const;
    int num_sr() const;

    // Retrieve point base coordinates (ag then sera)
    arma::mat ptBaseCoords() const;

    // Retrieve antigen coordinates
    arma::mat agCoords() const;

    // Retrieve sera coordinates
    arma::mat srCoords() const;

    // Retrieve point coordinates (ags then sr)
    arma::mat ptCoords() const;

    // Apply the optimization transform to an arbitrary set of coordinates
    arma::mat applyTransformation(
      arma::mat coords
    ) const;

    // Bake in the current transformation into the base coordinates
    void bake_transformation();

    // Set ag coordinates
    void set_ag_coords(
      arma::mat coords
    );

    // Set sr coordinates
    void set_sr_coords(
        arma::mat coords
    );

    // Align to another optimization
    void alignToOptimization(
      AcOptimization target
    );

    // Calculate the distance matrix
    arma::mat distance_matrix() const;

    // Calculate point distance
    double ptDist(
      int ag,
      int sr
    ) const;

    // Calculate the column bases
    arma::vec calc_colbases(
       AcTiterTable titers
    ) const;

    // Reduce dimensions of optimization through principle component analysis
    void reduceDimensions(
      arma::uword dims
    );

    // Randomise coordinates
    void randomizeCoords(
      double boxsize
    );

    // Get table distances
    arma::mat numeric_table_distances(
      const AcTiterTable &titers
    ) const;

    // Relax the optimization
    void relax_from_raw_matrices(
      const arma::mat &tabledist_matrix,
      const arma::imat &titertype_matrix,
      const AcOptimizerOptions options,
      const arma::uvec &fixed_antigens = arma::uvec(),
      const arma::uvec &fixed_sera = arma::uvec(),
      const arma::mat &titer_weights = arma::mat(),
      const double &dilution_stepsize = 1.0
    );

    void relax_from_titer_table(
      AcTiterTable titers,
      const AcOptimizerOptions options,
      const arma::uvec &fixed_antigens = arma::uvec(),
      const arma::uvec &fixed_sera = arma::uvec(),
      const arma::mat &titer_weights = arma::mat(),
      const double &dilution_stepsize = 1.0
    );

    // Removing antigens and sera
    void remove_antigen(
        arma::uword ag
    );

    void remove_serum(
        arma::uword sr
    );

    // Subsetting
    void subset(
        arma::uvec ags,
        arma::uvec sr
    );

    // Transformation
    void transform(
      arma::mat transform_matrix
    );

    // Translation
    void translate(
      arma::mat translation_matrix
    );

    // Rotation
    void rotate(
      double degrees,
      arma::uword axis_num = 2
    );

    // Reflection
    void reflect(
      arma::uword axis_num = 0
    );

    // Scale
    void scale(
        double scaling
    );

    // Set scaling
    void set_scaling(
        double scaling
    );

    // Check if values are still the default (used when outputting to json)
    bool isdefault(
        std::string attribute
    );

};

#endif


# ================================================
# FILE: src/acmap_plotspec.h
# ================================================


#ifndef Racmacs__acmap_plotspec__h
#define Racmacs__acmap_plotspec__h

class AcPlotspec {

  protected:

    bool shown = true;
    double size = 5.0;
    std::string shape = "CIRCLE";
    std::string fill = "green";
    std::string outline = "black";
    double outline_width = 1.0;
    double rotation = 0.0;
    double aspect = 1.0;

  public:

    // Plotspec details
    bool get_shown() const { return shown; };
    double get_size() const { return size; };
    std::string get_fill() const { return fill; };
    std::string get_outline() const { return outline; };
    double get_outline_width() const { return outline_width; };
    double get_rotation() const { return rotation; };
    double get_aspect() const { return aspect; };
    std::string get_shape() const { return shape; };

    void set_shown(bool shown_in){ shown = shown_in; };
    void set_size(double size_in){ size = size_in; };
    void set_fill(std::string fill_in){ fill = fill_in; };
    void set_outline(std::string outline_in){ outline = outline_in; }
    void set_outline_width(double outline_width_in){ outline_width = outline_width_in; };
    void set_rotation(double rotation_in){ rotation = rotation_in; };
    void set_aspect(double aspect_in){ aspect = aspect_in; };
    void set_shape(std::string shape_in){ shape = shape_in; };

};

#endif


# ================================================
# FILE: src/acmap_point.cpp
# ================================================


#include "acmap_optimization.h"
#include "acmap_titers.h"
#include "acmap_plotspec.h"
#include "acmap_point.h"
#include "acmap_sequences.h"

// Regular details
std::string AcPoint::get_type() const { return type; }
std::string AcPoint::get_name() const { return name; }
std::string AcPoint::get_extra() const { return extra; }
std::string AcPoint::get_date() const { return date; }
bool AcPoint::get_reference() const { return reference; }
std::string AcPoint::get_passage() const { return passage; }
std::string AcPoint::get_id() const { return id; }
std::string AcPoint::get_species() const { return species; }
int AcPoint::get_group() const { return group; }
std::string AcPoint::get_sequence() const { return sequence; }
std::vector<SeqInsertion> AcPoint::get_sequence_insertions() const { return sequence_insertions; }
std::vector<std::string> AcPoint::get_clade() const { return clade; }
std::vector<std::string> AcPoint::get_annotations() const { return annotations; }
std::vector<std::string> AcPoint::get_labids() const { return labids; }
std::string AcPoint::get_lineage() const { return lineage; }
std::string AcPoint::get_reassortant() const { return reassortant; }
std::string AcPoint::get_strings() const { return strings; }
std::string AcPoint::get_continent() const { return continent; }
std::string AcPoint::get_nucleotidesequence() const { return nucleotidesequence; }

void AcPoint::set_type( std::string value ){ type = value; }
void AcPoint::set_name( std::string value ){ name = value; }
void AcPoint::set_extra( std::string value ){ extra = value; }
void AcPoint::set_date( std::string value ){ date = value; }
void AcPoint::set_reference( bool value ){ reference = value; }
void AcPoint::set_passage( std::string value ){ passage = value; }
void AcPoint::set_id( std::string value ){ id = value; }
void AcPoint::set_species( std::string value ){ species = value; }
void AcPoint::set_group( int value ){ group = value; }
void AcPoint::set_sequence( std::string value ){ sequence = value; }
void AcPoint::set_sequence_insertions( std::vector<SeqInsertion> value ){ sequence_insertions = value; }
void AcPoint::set_clade( std::vector<std::string> value ){ clade = value; }
void AcPoint::set_annotations( std::vector<std::string> value ){ annotations = value; }
void AcPoint::set_labids( std::vector<std::string> value ){ labids = value; }
void AcPoint::set_lineage( std::string value ){ lineage = value; }
void AcPoint::set_reassortant( std::string value ){ reassortant = value; }
void AcPoint::set_strings( std::string value ){ strings = value; }
void AcPoint::set_continent( std::string value ){ continent = value; }
void AcPoint::set_nucleotidesequence( std::string value ){ nucleotidesequence = value; }

// Get IDs for matching
std::string AcPoint::get_match_id() const {
  if(id == ""){
    return name;
  } else {
    return id;
  }
}

// Check if values are defaults
bool AcPoint::isdefault(std::string attribute) {

  if (attribute == "passage") {
    return(passage == "");
  } else if (attribute == "clade") {
    return(clade.size() == 0);
  } else if (attribute == "annotations") {
    return(annotations.size() == 0);
  } else if (attribute == "labids") {
    return(labids.size() == 0);
  } else if (attribute == "group") {
    return(group == 0);
  } else if (attribute == "sequence") {
    return(sequence == "");
  } else if (attribute == "sequence_insertions") {
    return(sequence_insertions.size() == 0);
  } else if (attribute == "id") {
    return(id == "");
  } else if (attribute == "extra") {
    return(extra == "");
  } else if (attribute == "species") {
    return(species == "");
  } else if (attribute == "date") {
    return(date == "");
  } else if (attribute == "lineage") {
    return(lineage == "");
  } else if (attribute == "reassortant") {
    return(reassortant == "");
  } else if (attribute == "strings") {
    return(strings == "");
  } else if (attribute == "continent") {
    return(continent == "");
  } else if (attribute == "nucleotidesequence") {
    return(nucleotidesequence == "");
  } else {
    return(false);
  }

}

// Define the antigen class
AcAntigen::AcAntigen(){
  set_type("ag");
}

// Define the sera class
AcSerum::AcSerum(){
  set_type("sr");
  plotspec.set_shape("BOX");
  plotspec.set_fill("transparent");
}

arma::uvec AcSerum::get_homologous_ags() const { return homologous_ags; }
void AcSerum::set_homologous_ags( arma::uvec value ){ homologous_ags = value; }



# ================================================
# FILE: src/acmap_point.h
# ================================================


#include "acmap_optimization.h"
#include "acmap_titers.h"
#include "acmap_plotspec.h"
#include "acmap_sequences.h"

#ifndef Racmacs__acmap_point__h
#define Racmacs__acmap_point__h

// Define the generic point class
class AcPoint {

  protected:

    // Regular details
    std::string type;
    std::string name;
    std::string extra;
    std::string date;
    bool reference = false;
    std::string id = "";
    int group = 0;
    std::string sequence;
    std::vector<SeqInsertion> sequence_insertions;
    std::string passage;
    std::string species;
    std::vector<std::string> clade;
    std::vector<std::string> annotations;
    std::vector<std::string> labids;
    std::string lineage;
    std::string reassortant;
    std::string strings;
    std::string continent;
    std::string nucleotidesequence;

  public:

    // Plotspec details
    AcPlotspec plotspec;

    // Public attributes
    arma::uvec homologous_ags;

    // Regular details
    std::string get_type() const;
    std::string get_name() const;
    std::string get_extra() const;
    std::string get_date() const;
    bool get_reference() const;
    std::string get_passage() const;
    std::string get_id() const;
    std::string get_species() const;
    int get_group() const;
    std::string get_sequence() const;
    std::vector<SeqInsertion> get_sequence_insertions() const;
    std::vector<std::string> get_clade() const;
    std::vector<std::string> get_annotations() const;
    std::vector<std::string> get_labids() const;
    std::string get_lineage() const;
    std::string get_reassortant() const;
    std::string get_strings() const;
    std::string get_continent() const;
    std::string get_nucleotidesequence() const;

    void set_type( std::string value );
    void set_name( std::string value );
    void set_extra( std::string value );
    void set_date( std::string value );
    void set_reference( bool value );
    void set_passage( std::string value );
    void set_id( std::string value );
    void set_species( std::string value );
    void set_group( int value );
    void set_sequence( std::string value );
    void set_sequence_insertions( std::vector<SeqInsertion> );
    void set_clade( std::vector<std::string> value );
    void set_annotations( std::vector<std::string> value );
    void set_labids( std::vector<std::string> value );
    void set_lineage( std::string value );
    void set_reassortant( std::string value );
    void set_strings( std::string value );
    void set_continent( std::string value );
    void set_nucleotidesequence( std::string value );

    // Get IDs for matching
    std::string get_match_id() const;

    // Check if values are defaults
    bool isdefault(std::string attribute);

};

// Define the antigen class
class AcAntigen: public AcPoint {

  public:
    AcAntigen();

};

// Define the sera class
class AcSerum: public AcPoint {

  public:
    AcSerum();

    arma::uvec get_homologous_ags() const;
    void set_homologous_ags( arma::uvec value );

};

#endif


# ================================================
# FILE: src/acmap_sequences.h
# ================================================


#include "acmap_optimization.h"
#include "acmap_titers.h"
#include "acmap_plotspec.h"

#ifndef Racmacs__acmap_sequences__h
#define Racmacs__acmap_sequences__h

// Define the generic point class
class SeqInsertion {

  public:
    arma::uword position;
    std::string insertion;

};

#endif


# ================================================
# FILE: src/acmap_titers.cpp
# ================================================


#include <RcppArmadillo.h>
#include "acmap_titers.h"
#include "utils_error.h"

// AcTiter
AcTiter::AcTiter(){
  numeric = 0;
  type = 0;
}

AcTiter::AcTiter(
  double numeric_titer,
  int titer_type
){
  numeric = numeric_titer;
  type = titer_type;
}

AcTiter::AcTiter(
  double numeric_titer
){
  numeric = numeric_titer;
  type = 1;
}

AcTiter::AcTiter(
  std::string titer
){

  switch(titer.at(0)){
  case '<':
    // Less than titer
    titer.erase(0,1);
    type = 2;
    numeric = std::stod(titer);
    break;
  case '>':
    // Greater than titer
    titer.erase(0,1);
    type = 3;
    numeric = std::stod(titer);
    break;
  case '*':
    // Unmeasured or ignored titer
    type = 0;
    numeric = arma::datum::nan;
    break;
  case '.':
    // Omitted titer (relevant for merges)
    type = -1;
    numeric = arma::datum::nan;
    break;
  default:
    // Measurable titer
    type = 1;
    numeric = std::stod(titer);
  }

}

// Conversion back to a string
std::string AcTiter::toString() const {

  // Get the titer as a string
  std::ostringstream ss;
  ss << numeric;
  std::string titer = ss.str();

  // Append lessthan signs etc depending on type
  switch(type) {
  case 0:
    // Unmeasured titer
    titer = "*";
    break;
  case 1:
    // Measurable titer
    break;
  case 2:
    // Less than titer
    titer = "<"+titer;
    break;
  case 3:
    // More than titer
    titer = ">"+titer;
    break;
  default:
    // Omitted titer
    titer = ".";
  }

  // Return the titer
  return titer;

}

// Conversion to log titer
double AcTiter::logTiter(
    double dilution_stepsize
){
  switch(type){
  case 1:
    return std::log2(numeric/10.0);
    break;
  case 2:
    return std::log2(numeric/10.0) - dilution_stepsize;
    break;
  case 3:
    return std::log2(numeric/10.0) + dilution_stepsize;
    break;
  default:
    return arma::datum::nan;
  }
}

// Round the titer
void AcTiter::roundTiter() {
  numeric = round(numeric);
}


// AcTiterTable
AcTiterTable::AcTiterTable(
  int nags,
  int nsr
):
numeric_titers(nags, nsr, arma::fill::zeros),
titer_types(nags, nsr, arma::fill::zeros){};

// Get dimensions
arma::uword AcTiterTable::nags() const { return numeric_titers.n_rows; }
arma::uword AcTiterTable::nsr() const { return numeric_titers.n_cols; }
arma::SizeMat AcTiterTable::size() const { return arma::size(numeric_titers); }

// Get and set numeric_titers and titer types
arma::mat AcTiterTable::get_numeric_titers() const { return numeric_titers; }
void AcTiterTable::set_numeric_titers(arma::mat numeric_titers_in){ numeric_titers = numeric_titers_in; }

arma::imat AcTiterTable::get_titer_types() const { return titer_types; }
void AcTiterTable::set_titer_types(arma::imat titer_types_in){ titer_types = titer_types_in; }

// Get a given titer
AcTiter AcTiterTable::get_titer(
    int agnum,
    int srnum
) const {

  return AcTiter(
    numeric_titers(agnum, srnum),
    titer_types(agnum, srnum)
  );

}

// Set a given titer
void AcTiterTable::set_titer(
    arma::uword agnum,
    arma::uword srnum,
    AcTiter titer
){

  // Error if out of range
  if(agnum >= nags() || srnum >= nsr() || agnum < 0 || srnum < 0){
    Rcpp::stop("Titer selection out of range");
  }

  // Set the titer
  numeric_titers(agnum, srnum) = titer.numeric;
  titer_types(agnum, srnum) = titer.type;

}

// Getting and setting by string
std::string AcTiterTable::get_titer_string(
    arma::uword agnum,
    arma::uword srnum
) const {

  AcTiter titer = get_titer(agnum, srnum);
  return titer.toString();

}

void AcTiterTable::set_titer_string(
    arma::uword agnum,
    arma::uword srnum,
    std::string titerstring
){

  AcTiter titer = AcTiter(titerstring);
  set_titer(agnum, srnum, titer);

}

void AcTiterTable::set_titer_double(
    arma::uword agnum,
    arma::uword srnum,
    double titerdouble
){

  AcTiter titer = AcTiter(titerdouble);
  set_titer(agnum, srnum, titer);

}

// Get vector of titers for a given antigen
std::vector<AcTiter> AcTiterTable::agTiters(
    arma::uword agnum
){

  const arma::uword num_sr = nsr();
  std::vector<AcTiter> ag_titers(num_sr);
  for(arma::uword srnum=0; srnum<num_sr; srnum++){
    ag_titers[srnum] = get_titer(agnum, srnum);
  }
  return ag_titers;
}

// Get vector of titers for a given serum
std::vector<AcTiter> AcTiterTable::srTiters(
    arma::uword srnum
){

  const arma::uword num_ags = nags();
  std::vector<AcTiter> sr_titers(num_ags);
  for(arma::uword agnum=0; agnum<num_ags; agnum++){
    sr_titers[agnum] = get_titer(agnum, srnum);
  }
  return sr_titers;
}

// Remove an antigen
void AcTiterTable::remove_antigen(
    arma::uword agnum
){
  numeric_titers.shed_row(agnum);
  titer_types.shed_row(agnum);
}

// Remove a serum
void AcTiterTable::remove_serum(
    arma::uword srnum
){
  numeric_titers.shed_col(srnum);
  titer_types.shed_col(srnum);
}

// Subsetting
void AcTiterTable::subset_antigens(
    arma::uvec ags
){

  numeric_titers = numeric_titers.rows(ags);
  titer_types = titer_types.rows(ags);

}

void AcTiterTable::subset_sera(
    arma::uvec sr
){

  numeric_titers = numeric_titers.cols(sr);
  titer_types = titer_types.cols(sr);

}

void AcTiterTable::subset(
    arma::uvec ags,
    arma::uvec sr
){

  numeric_titers = numeric_titers.submat(ags, sr);
  titer_types = titer_types.submat(ags, sr);

}

// Counting titers
int AcTiterTable::num_measured(
) const {
  return arma::accu(titer_types > 0);
}

int AcTiterTable::num_unmeasured(
) const {
  return arma::accu(titer_types <= 0);
}

// Check if a titer is measured
bool AcTiterTable::titer_measured(
    const int& ag,
    const int& sr
) const {
  return titer_types(ag, sr) > 0;
}

// Setting unmeasured titers
void AcTiterTable::set_unmeasured(
    arma::uvec indices
){
  titer_types.elem(indices).zeros();
  numeric_titers.elem(indices).zeros();
}

// Getting indices of titers
arma::uvec AcTiterTable::vec_indices_measured(
) const {

  int n_measured = arma::accu(titer_types > 0);
  arma::uvec indices(n_measured);

  int vec_i = 0;
  for(arma::uword i=0; i<titer_types.n_elem; i++){
    if(titer_types(i) > 0){
      indices(vec_i) = i;
      vec_i++;
    }
  }

  return indices;

}

// Calculate column bases
arma::vec AcTiterTable::calc_colbases(
    const std::string &min_colbasis,
    const arma::vec &fixed_colbases,
    const arma::vec &ag_reactivity_adjustments
) const {

  // Check input
  if(fixed_colbases.n_elem != nsr()) {
    ac_error(
      "fixed_colbases length (" + std::to_string(fixed_colbases.n_elem) + ")" +
      "does not match number of sera (" + std::to_string(nsr()) + ")"
    );
  }
  if(ag_reactivity_adjustments.n_elem != nags()) {
    ac_error(
      "ag_reactivity_adjustments length (" + std::to_string(ag_reactivity_adjustments.n_elem) + ")" +
      "does not match number of antigens (" + std::to_string(nags()) + ")"
    );
  }
  if(arma::accu(titer_types > 0) == 0) return fixed_colbases;

  // Get log titers
  arma::mat num_titers = numeric_titers;
  arma::mat log_titers = arma::log2(num_titers / 10.0);

  // Apply antigen reactivity adjustments
  log_titers.each_col() += ag_reactivity_adjustments;

  // Calculate column bases
  log_titers.replace(arma::datum::nan, log_titers.min());
  arma::vec colbases = arma::max(log_titers.t(), 1);

  // Apply any minimum column bases
  if(min_colbasis != "none"){

    double log_min_colbasis = AcTiter(min_colbasis).logTiter(1.0);
    double max_colbasis = colbases.max();

    colbases = arma::clamp(
      colbases,
      log_min_colbasis,
      std::max(max_colbasis, log_min_colbasis)
    );

  }

  // Apply any fixed column bases
  if(fixed_colbases.size() > 0){
    if(fixed_colbases.size() != colbases.n_elem){
      Rcpp::stop("Length of fixed column bases does not match the length of the column bases");
    }
    arma::uvec nonan = arma::find_finite(fixed_colbases);
    colbases.elem( nonan ) = fixed_colbases.elem( nonan );
  }

  // Return the column bases
  return colbases;

}

// Calculate table distances
arma::mat AcTiterTable::numeric_table_distances(
    const std::string &minimum_col_basis,
    const arma::vec &fixed_colbases,
    const arma::vec &ag_reactivity_adjustments
) const {

  // Calculate column bases
  arma::vec colbases = calc_colbases(
    minimum_col_basis,
    fixed_colbases,
    ag_reactivity_adjustments
  );

  // Set distances as log titers
  arma::mat dists = arma::log2(numeric_titers / 10.0);

  // Apply antigen reactivity adjustments
  dists.each_col() += ag_reactivity_adjustments;

  // Subtract each log titer row from colbases to arrive at distance
  for(arma::uword i=0; i<dists.n_rows; i++){
    dists.row(i) = colbases.as_row() - dists.row(i);
  }

  // Do not allow distances < 0
  // if (std::isfinite(dists.max())) {
  //   dists = arma::clamp(dists, 0, dists.max());
  // }

  // Replace na titers with na dists
  dists.elem( arma::find(titer_types <= 0) ).fill( arma::datum::nan );

  // Return distance matrix
  return dists;

}

// Add log titers to the titer table
void AcTiterTable::add_log_titers(
    arma::mat log_titers_to_add
){

  arma::mat logtiters = arma::log2(numeric_titers / 10.0);
  logtiters += log_titers_to_add;
  numeric_titers = arma::exp2(logtiters)*10.0;

}

// Round the titers
void AcTiterTable::roundTiters() {
  numeric_titers = arma::round(numeric_titers);
}


# ================================================
# FILE: src/acmap_titers.h
# ================================================


#include <RcppArmadillo.h>

#ifndef Racmacs__acmap_titers__h
#define Racmacs__acmap_titers__h

// For converting from numeric to string titers
class AcTiter {

  public:
    double numeric;
    int type;

    AcTiter();
    AcTiter(
      double numeric_titer,
      int titer_type
    );

    AcTiter(
      double numeric_titer
    );

    AcTiter(
      std::string titer
    );

    // Conversion back to a string
    std::string toString() const;

    // Conversion to log titer
    double logTiter(
        double dilution_stepsize
    );

    // Round the titer
    void roundTiter();

};


// Define the titertable class
class AcTiterTable {

  private:
    // The titers are stored as a matrix of numeric forms and one of titer types
    // Types:
    // 0 = not measured
    // 1 = measured detectable e.g. "40"
    // 2 = measured lessthan e.g. "<10"
    // 3 = measured morethan e.g. ">1280"
    arma::mat numeric_titers;
    arma::imat titer_types;

  public:

    // Constructor
    AcTiterTable(
      int nags,
      int nsr
    );

    // Get dimensions
    arma::uword nags() const;
    arma::uword nsr() const;
    arma::SizeMat size() const;

    // Get and set numeric_titers and titer types
    arma::mat get_numeric_titers() const;
    void set_numeric_titers(arma::mat numeric_titers_in);

    arma::imat get_titer_types() const;
    void set_titer_types(arma::imat titer_types_in);

    // Get a given titer
    AcTiter get_titer(
        int agnum,
        int srnum
    ) const;

    // Set a given titer
    void set_titer(
        arma::uword agnum,
        arma::uword srnum,
        AcTiter titer
    );

    // Getting and setting by string
    std::string get_titer_string(
      arma::uword agnum,
      arma::uword srnum
    ) const;

    void set_titer_string(
      arma::uword agnum,
      arma::uword srnum,
      std::string titerstring
    );

    void set_titer_double(
        arma::uword agnum,
        arma::uword srnum,
        double titerdouble
    );

    // Get vector of titers for a given antigen
    std::vector<AcTiter> agTiters(
      arma::uword agnum
    );

    // Get vector of titers for a given serum
    std::vector<AcTiter> srTiters(
        arma::uword srnum
    );

    // Remove an antigen
    void remove_antigen(
      arma::uword agnum
    );

    // Remove a serum
    void remove_serum(
      arma::uword srnum
    );

    // Subsetting
    void subset_antigens(
      arma::uvec ags
    );

    void subset_sera(
        arma::uvec sr
    );

    void subset(
        arma::uvec ags,
        arma::uvec sr
    );

    // Counting titers
    int num_measured() const;
    int num_unmeasured() const;

    // Check if a titer is measured
    bool titer_measured(
      const int& ag,
      const int& sr
    ) const;

    // Setting unmeasured titers
    void set_unmeasured(
        arma::uvec indices
    );

    // Getting indices of titers
    arma::uvec vec_indices_measured(
    ) const;

    // Calculate column bases
    arma::vec calc_colbases(
        const std::string &min_colbasis,
        const arma::vec &fixed_colbases,
        const arma::vec &ag_reactivity_adjustments
    ) const;

    // Calculate table distances
    arma::mat numeric_table_distances(
      const std::string &minimum_col_basis,
      const arma::vec &fixed_colbases,
      const arma::vec &ag_reactivity_adjustments
    ) const;

    // Add log titers to the titer table
    void add_log_titers(
      arma::mat log_titers_to_add
    );

    // Round the titers
    void roundTiters();

};

#endif




# ================================================
# FILE: src/json_assert.cpp
# ================================================


#include <RcppArmadillo.h>

void ac_assert(bool x){
  if(!x) Rf_error("Parsing failed");
}



# ================================================
# FILE: src/json_assert.h
# ================================================


#ifndef Racmacs__json_assert__h
#define Racmacs__json_assert__h

// Define the rapid json assert macro
void ac_assert(bool x);
#define RAPIDJSON_ASSERT(x) ac_assert(x)

#endif



# ================================================
# FILE: src/json_read_to_acmap.cpp
# ================================================


#include "json_read_to_acmap.h"

// Function for setting point style
template <typename T>
void set_style_from_json(
  T& pt,
  const Value& style
){

  if(style.HasMember("+")) pt.plotspec.set_shown( style["+"].GetBool() );           // Point shown
  if(style.HasMember("F")) pt.plotspec.set_fill( style["F"].GetString() );          // Fill color
  if(style.HasMember("O")) pt.plotspec.set_outline( style["O"].GetString() );       // Outline color
  if(style.HasMember("o")) pt.plotspec.set_outline_width( style["o"].GetDouble() ); // Outline width
  if(style.HasMember("S")) pt.plotspec.set_shape( style["S"].GetString() );         // Shape
  if(style.HasMember("s")) pt.plotspec.set_size( style["s"].GetDouble() );          // Size
  if(style.HasMember("r")) pt.plotspec.set_rotation( style["r"].GetDouble() );      // Rotation
  if(style.HasMember("a")) pt.plotspec.set_aspect( style["a"].GetDouble() );        // Aspect

}


// Function for setting titers
void set_titers_from_json(
  AcTiterTable& titer_table,
  const Value& td
){

  for (SizeType ag = 0; ag < td.Size(); ag++){
    for (auto& sr : td[ag].GetObject()){
      titer_table.set_titer_string(
        ag, strtoimax( sr.name.GetString(), NULL, 10 ),
        sr.value.GetString()
      );
    }
  }

}


// [[Rcpp::export]]
AcMap json_to_acmap(
  std::string json
){

  // FILE* fp = fopen(filepath.c_str(), "rb"); // non-Windows use "r"
  //
  // char readBuffer[65536];
  // FileReadStream is(fp, readBuffer, sizeof(readBuffer));

  // Parse the json
  Document doc;
  // doc.ParseStream(is);
  doc.Parse<kParseFullPrecisionFlag>(json.c_str());

  // Perform some checks
  if(!doc.IsObject()){
    Rf_error("Could not parse file");
  };


  // == SETUP ==========================
  // Get map data
  const Value& c = doc["c"];

  // Get antigen and sera info and make map
  const Value& a = c["a"]; // antigens
  const Value& s = c["s"]; // sera
  int num_antigens = a.Size();
  int num_sera = s.Size();
  int num_points = num_antigens + num_sera;
  AcMap map(num_antigens, num_sera);


  // == INFO ============================
  if(c.HasMember("i")){
    const Value& i = c["i"]; // map info

    if(i.HasMember("N")){ map.name = i["N"].GetString(); }

  }


  // == ANTIGENS ========================
  // Rcpp::Rcout << "\n" << "ANTIGENS";
  for( int i=0; i<num_antigens; i++ ){

    const Value& ag = a[i];
    if(ag.HasMember("N")) map.antigens[i].set_name( ag["N"].GetString() );
    if(ag.HasMember("P")) map.antigens[i].set_passage( ag["P"].GetString() );
    if(ag.HasMember("c")) map.antigens[i].set_clade( parse<std::vector<std::string>>(ag["c"]) );
    if(ag.HasMember("a")) map.antigens[i].set_annotations( parse<std::vector<std::string>>(ag["a"]) );
    if(ag.HasMember("l")) map.antigens[i].set_labids( parse<std::vector<std::string>>(ag["l"]) );
    if(ag.HasMember("A")) map.antigens[i].set_sequence( ag["A"].GetString() );
    if(ag.HasMember("Ai")) map.antigens[i].set_sequence_insertions(parse<std::vector<SeqInsertion>>(ag["Ai"]));
    if(ag.HasMember("D")) map.antigens[i].set_date( ag["D"].GetString() );
    if(ag.HasMember("L")) map.antigens[i].set_lineage( ag["L"].GetString() );
    if(ag.HasMember("R")) map.antigens[i].set_reassortant( ag["R"].GetString() );
    if(ag.HasMember("S")) map.antigens[i].set_strings( ag["S"].GetString() );
    if(ag.HasMember("C")) map.antigens[i].set_continent( ag["C"].GetString() );
    if(ag.HasMember("B")) map.antigens[i].set_nucleotidesequence( ag["B"].GetString() );

    // set_reference
    // set_name_full
    // set_name_abbreviated

  }


  // == SERA ============================
  // Rcpp::Rcout << "\n" << "SERA";
  for( int i=0; i<num_sera; i++ ){

    const Value& sr = s[i];
    if(sr.HasMember("N")) map.sera[i].set_name( sr["N"].GetString() );
    if(sr.HasMember("P")) map.sera[i].set_passage( sr["P"].GetString() );
    if(sr.HasMember("c")) map.sera[i].set_clade( parse<std::vector<std::string>>(sr["c"]) );
    if(sr.HasMember("a")) map.sera[i].set_annotations( parse<std::vector<std::string>>(sr["a"]) );
    if(sr.HasMember("A")) map.sera[i].set_sequence( sr["A"].GetString() );
    if(sr.HasMember("Ai")) map.sera[i].set_sequence_insertions(parse<std::vector<SeqInsertion>>(sr["Ai"]));
    if(sr.HasMember("D")) map.sera[i].set_date( sr["D"].GetString() );
    if(sr.HasMember("I")) map.sera[i].set_id( sr["I"].GetString() );
    if(sr.HasMember("s")) map.sera[i].set_species( sr["s"].GetString() );
    if(sr.HasMember("h")) map.sera[i].set_homologous_ags( parse<arma::uvec>(sr["h"]) );
    if(sr.HasMember("L")) map.sera[i].set_lineage( sr["L"].GetString() );
    if(sr.HasMember("R")) map.sera[i].set_reassortant( sr["R"].GetString() );
    if(sr.HasMember("S")) map.sera[i].set_strings( sr["S"].GetString() );
    if(sr.HasMember("C")) map.sera[i].set_continent( sr["C"].GetString() );
    if(sr.HasMember("B")) map.sera[i].set_nucleotidesequence( sr["B"].GetString() );

    // set_reference
    // set_name_full
    // set_name_abbreviated

  }


  // == TITERS ==========================
  // Rcpp::Rcout << "\n" << "TITERS";
  if(c.HasMember("t")){
    const Value& t = c["t"];

    if(t.HasMember("l")){

      // This is for the case that titers are stored simply as a matrix
      for (int ag = 0; ag < num_antigens; ag++){
        for (int sr = 0; sr < num_sera; sr++){
          map.titer_table_flat.set_titer_string(
            ag, sr,
            t["l"][ag][sr].GetString()
          );
        }
      }

    } else if (t.HasMember("d")){

      // This is for the case that titers are stored as a series of objects, each with names relating to the serum number
      set_titers_from_json( map.titer_table_flat, t["d"] );

    } else {

      // If none of the above this is an error
      Rf_error("There was a problem parsing the map");

    }

    // Titer layers
    // Rcpp::Rcout << "\n" << "TITER LAYERS";
    if (t.HasMember("L")){

      // Setup titer table layers
      int num_layers = t["L"].Size();
      std::vector<AcTiterTable> titer_table_layers(
          num_layers,
          AcTiterTable( num_antigens, num_sera )
      );

      // Parse layers
      for (int layer = 0; layer < num_layers; layer++){
        set_titers_from_json( titer_table_layers[layer], t["L"][layer] );
      }

      // Add layers to map
      map.titer_table_layers = titer_table_layers;

    }

  }

  // == PLOTSPEC =====================
  // Rcpp::Rcout << "\n" << "PLOTSPEC";
  if(c.HasMember("p")){

    const Value& p = c["p"]; // plotspec
    const Value& pindices = p["p"];
    const Value& pstyles = p["P"];

    // Set drawing order
    if(p.HasMember("d")){
      map.set_pt_drawing_order( parse<arma::uvec>(p["d"]) );
    }

    // Style antigens
    for(int i=0; i<num_antigens; i++){
      set_style_from_json( map.antigens[i], pstyles[pindices[i].GetInt()]);
    }

    // Style sera
    for(int i=0; i<num_sera; i++){
      set_style_from_json( map.sera[i], pstyles[pindices[i + num_antigens].GetInt()]);
    }

  }

  // == OPTIMIZATION RUNS ======================
  // Rcpp::Rcout << "\n" << "OPTIMIZATIONS";
  if(c.HasMember("P")){

    const Value& P = c["P"]; // optimizations aka "projections"

    // Setup optimizations
    std::vector<AcOptimization> optimizations;
    for ( SizeType i=0; i<P.Size(); i++ ){
      const Value& Opt = P[i];

      // Create optimization
      arma::uword num_dims = 0;
      for (int pt=0; pt < num_points; pt++) {
        if (Opt["l"][pt].Size() > num_dims) {
          num_dims = Opt["l"][pt].Size();
        }
      }
      AcOptimization optimization( num_dims, num_antigens, num_sera );

      // Set coords
      arma::mat coords( num_points, num_dims );
      coords.fill( arma::datum::nan );
      for( int pt=0; pt < num_points; pt++){
        for( SizeType dim=0; dim < Opt["l"][pt].Size(); dim++){
          coords(pt, dim) = parse<double>(Opt["l"][pt][dim]);
        }
      }

      optimization.set_ag_base_coords(coords.rows(0, num_antigens - 1));
      optimization.set_sr_base_coords(coords.rows(num_antigens, num_points - 1));

      // Set details
      if(Opt.HasMember("c")) optimization.set_comment(Opt["c"].GetString());
      if(Opt.HasMember("m")) optimization.set_min_column_basis(Opt["m"].GetString());
      if(Opt.HasMember("C")){
        optimization.set_fixed_column_bases( parse<arma::vec>(Opt["C"]));
      }
      if(Opt.HasMember("t")){
        arma::vec transformation = parse<arma::vec>(Opt["t"]);
        int dim = sqrt(transformation.n_elem);
        optimization.set_transformation(
          arma::reshape( transformation, dim, dim)
        );
      }
      if(Opt.HasMember("T")){
        optimization.set_translation( parse<arma::vec>(Opt["T"]));
      }
      if(Opt.HasMember("s")) optimization.set_stress(parse<double>(Opt["s"]));

      // Add to optimizations
      optimizations.push_back(optimization);

    }

    // Add optimizations to the map
    map.optimizations = optimizations;

  }

  // == EXTRAS =====================
  // Rcpp::Rcout << "\n" << "EXTRAS";
  if(c.HasMember("x")){
    const Value& x = c["x"]; // extra items

    // = AGS =
    if(x.HasMember("a")){
      const Value& xa = x["a"];
      for(SizeType i=0; i<xa.Size(); i++){
        const Value& xai = xa[i];
        if(xai.HasMember("g")) map.antigens[i].set_group( xai["g"].GetInt() );
        if(xai.HasMember("q")) map.antigens[i].set_sequence( xai["q"].GetString() ); // For backwards compatibility
        if(xai.HasMember("i")) map.antigens[i].set_id( xai["i"].GetString() );
        if(xai.HasMember("x")) map.antigens[i].set_extra( xai["x"].GetString() );
      }
    }

    // = SR =
    if(x.HasMember("s")){
      const Value& xs = x["s"];
      for(SizeType i=0; i<xs.Size(); i++){
        const Value& xsi = xs[i];
        if(xsi.HasMember("g")) map.sera[i].set_group( xsi["g"].GetInt() );
        if(xsi.HasMember("q")) map.sera[i].set_sequence( xsi["q"].GetString() ); // For backwards compatibility
        if(xsi.HasMember("i")) map.sera[i].set_id( xsi["i"].GetString() ); // For backwards compatibility
        if(xsi.HasMember("x")) map.sera[i].set_extra( xsi["x"].GetString() );
      }
    }

    // = OPTIMIZATIONS =
    if(x.HasMember("p")){
      const Value& xp = x["p"];
      for(SizeType i=0; i<xp.Size(); i++){
        const Value& xpi = xp[i];
        if(xpi.HasMember("t")) map.optimizations.at(i).set_translation(parse<arma::mat>(xpi["t"]));
        if(xpi.HasMember("r")) {
          map.optimizations.at(i).set_ag_reactivity_adjustments(parse<arma::vec>(xpi["r"]));

          if (i == 0) {
            // For backwards compatibility before reactivity adjustments were an
            // attribute of the map not the optimization
            map.set_ag_reactivity_adjustments(parse<arma::vec>(xpi["r"]));
          }

        }
        if(xpi.HasMember("b")) map.optimizations.at(i).bootstrap = parse<std::vector<BootstrapOutput>>(xpi["b"]);
      }
    }

    // = OTHER =
    if(x.HasMember("agv")) map.set_ag_group_levels( parse<std::vector<std::string>>(x["agv"]) );
    if(x.HasMember("srv")) map.set_sr_group_levels( parse<std::vector<std::string>>(x["srv"]) );
    if(x.HasMember("ds"))  map.dilution_stepsize = x["ds"].GetDouble();
    if(x.HasMember("ln"))  map.set_layer_names( parse<std::vector<std::string>>(x["ln"]) );
    if(x.HasMember("r"))   map.set_ag_reactivity_adjustments( parse<arma::vec>(x["r"]) );
    if(x.HasMember("D"))   map.description = x["D"].GetString();

  }

  // Return the map
  // Rcpp::Rcout << "\n" << "DONE";
  return map;

}



# ================================================
# FILE: src/json_read_to_acmap.h
# ================================================


// #include <cstdio>
#include <RcppArmadillo.h>
#include "acmap_map.h"
#include "acmap_point.h"
#include "acmap_optimization.h"
#include "json_assert.h"

// [[Rcpp::depends(rapidjsonr)]]
#include <rapidjson/document.h>
// #include <rapidjson/filereadstream.h>
using namespace rapidjson;

#ifndef Racmacs__json_read_to_acmap__h
#define Racmacs__json_read_to_acmap__h

// Generic template for parsing
template <typename T> T parse(const Value& v);

// To double
template <>
double parse(
    const Value& v
){
  double x;
  if(v.IsNull()){
    x = arma::datum::nan;
  } else {
    x = v.GetDouble();
  }
  return x;
}

// To vector
template <>
arma::vec parse(
    const Value& v
){

  arma::vec out(v.Size());
  for (SizeType i = 0; i < v.Size(); i++) {
    out(i) = parse<double>(v[i]);
  }
  return out;

}

template <>
arma::uvec parse(
    const Value& v
){

  arma::uvec out(v.Size());
  for (SizeType i = 0; i < v.Size(); i++) {
    out(i) = v[i].GetInt();
  }
  return out;

}

// To string vector
template <>
std::vector<std::string> parse(
    const Value& v
){

  std::vector<std::string> out(v.Size());
  for(SizeType i=0; i<v.Size(); i++){
    out[i] = v[i].GetString();
  }
  return out;

}

// To matrix
template <>
arma::mat parse(
    const Value& v
){

  SizeType nrows;
  SizeType ncols;

  nrows = v.Size();
  if (v[0].IsArray()) ncols = v[0].Size();
  else                ncols = 1;

  arma::mat out(nrows, ncols);

  if (v[0].IsArray()) {
    for (SizeType i = 0; i < nrows; i++) {
      for (SizeType j = 0; j < ncols; j++) {
        out(i,j) = parse<double>(v[i][j]);
      }
    }
  } else {
    for (SizeType i = 0; i < nrows; i++) {
      out(i,0) = parse<double>(v[i]);
    }
  }

  return out;

}

// To bootstrap
template <>
BootstrapOutput parse(
    const Value& v
){

  BootstrapOutput out;
  out.coords = parse<arma::mat>(v["coords"]);
  if (v.HasMember("sampling")) {
    out.sampling = parse<arma::vec>(v["sampling"]);
  }
  return out;

}

template <>
std::vector<BootstrapOutput> parse(
    const Value& v
){

  const Value& coords = v["coords"];
  arma::uword num_bootstrap = coords.Size();

  std::vector<BootstrapOutput> out(num_bootstrap);
  for (SizeType i = 0; i < num_bootstrap; i++) {
    out[i].coords = parse<arma::mat>(coords[i]);
  }

  if (v.HasMember("sampling")) {
    const Value& sampling = v["sampling"];
    for (SizeType i = 0; i < num_bootstrap; i++) {
      out[i].sampling = parse<arma::vec>(sampling[i]);
    }
  }

  return out;

}

template <>
std::vector<SeqInsertion> parse(
    const Value& v
){

  std::vector<SeqInsertion> out(v.Size());
  for (SizeType i = 0; i < v.Size(); i++) {
    SeqInsertion s;
    s.position = v[i][0].GetUint();
    s.insertion = v[i][1].GetString();
    out[i] = s;
  }
  return out;

}

#endif


# ================================================
# FILE: src/json_write_from_acmap.cpp
# ================================================


// #in// #include <cstdio>
#include <string.h>
#include <RcppArmadillo.h>
#include "acmap_map.h"
#include "acmap_point.h"
#include "acmap_optimization.h"
#include "json_write_from_acmap.h"
using namespace rapidjson;

// [[Rcpp::export]]
std::string acmap_to_json(
    AcMap map,
    std::string version,
    bool pretty,
    bool round_titers
){

  // Round titers if requested
  if (round_titers) {
    map.titer_table_flat.roundTiters();
    for(auto &titer_table : map.titer_table_layers){
      titer_table.roundTiters();
    }
  }

  // Setup the document
  Document doc;
  doc.SetObject();
  Document::AllocatorType& allocator = doc.GetAllocator();

  // Add basic info
  doc.AddMember("_", "-*- js-indent-level: 2 -*-", allocator);  // json info..?
  doc.AddMember("  version", "acmacs-ace-v1", allocator);       // Version info
  doc.AddMember("?created", "", allocator);                     // Comment field

  // Map information
  Value c(kObjectType);
  Value i(kObjectType);
  int num_antigens = map.antigens.size();
  int num_sera = map.sera.size();
  int num_points = num_antigens + num_sera;

  // == INFO ============================
  i.AddMember("N", jsonifya(map.name, allocator), allocator);

  // == ANTIGENS ========================
  Value a(kArrayType);
  for( int i=0; i<num_antigens; i++ ){

    AcAntigen& ag = map.antigens[i];
    Value agval(kObjectType);

    agval.AddMember("N", jsonifya(ag.get_name(), allocator), allocator);
    if (!ag.isdefault("passage"))             agval.AddMember("P", jsonifya(ag.get_passage(), allocator), allocator);
    if (!ag.isdefault("clade"))               agval.AddMember("c", jsonifya(ag.get_clade(), allocator), allocator);
    if (!ag.isdefault("annotations"))         agval.AddMember("a", jsonifya(ag.get_annotations(), allocator), allocator);
    if (!ag.isdefault("labids"))              agval.AddMember("l", jsonifya(ag.get_labids(), allocator), allocator);
    if (!ag.isdefault("sequence"))            agval.AddMember("A", jsonifya(ag.get_sequence(), allocator), allocator);
    if (!ag.isdefault("sequence_insertions")) agval.AddMember("Ai", jsonifya(ag.get_sequence_insertions(), allocator), allocator);
    if (!ag.isdefault("date"))                agval.AddMember("D", jsonifya(ag.get_date(), allocator), allocator);
    if (!ag.isdefault("lineage"))             agval.AddMember("L", jsonifya(ag.get_lineage(), allocator), allocator);
    if (!ag.isdefault("reassortant"))         agval.AddMember("R", jsonifya(ag.get_reassortant(), allocator), allocator);
    if (!ag.isdefault("strings"))             agval.AddMember("S", jsonifya(ag.get_strings(), allocator), allocator);
    if (!ag.isdefault("continent"))           agval.AddMember("C", jsonifya(ag.get_continent(), allocator), allocator);
    if (!ag.isdefault("nucleotidesequence"))  agval.AddMember("B", jsonifya(ag.get_nucleotidesequence(), allocator), allocator);

    // set_group_values
    // set_reference
    // set_name_full
    // set_name_abbreviated
    a.PushBack(agval, allocator);

  }


  // == SERA ============================
  Value s(kArrayType);
  for( int i=0; i<num_sera; i++ ){

    AcSerum& sr = map.sera[i];
    Value srval(kObjectType);

    srval.AddMember("N", jsonifya(sr.get_name(), allocator), allocator);
    if (!sr.isdefault("passage"))             srval.AddMember("P", jsonifya(sr.get_passage(), allocator), allocator);
    if (!sr.isdefault("clade"))               srval.AddMember("c", jsonifya(sr.get_clade(), allocator), allocator);
    if (!sr.isdefault("annotations"))         srval.AddMember("a", jsonifya(sr.get_annotations(), allocator), allocator);
    if (!sr.isdefault("sequence"))            srval.AddMember("A", jsonifya(sr.get_sequence(), allocator), allocator);
    if (!sr.isdefault("sequence_insertions")) srval.AddMember("Ai", jsonifya(sr.get_sequence_insertions(), allocator), allocator);
    if (!sr.isdefault("date"))                srval.AddMember("D", jsonifya(sr.get_date(), allocator), allocator);
    if (!sr.isdefault("id"))                  srval.AddMember("I", jsonifya(sr.get_id(), allocator), allocator);
    if (!sr.isdefault("species"))             srval.AddMember("s", jsonifya(sr.get_species(), allocator), allocator);
    if (sr.get_homologous_ags().n_elem > 0)   srval.AddMember("h", jsonifya(sr.get_homologous_ags(), allocator), allocator);
    if (!sr.isdefault("lineage"))             srval.AddMember("L", jsonifya(sr.get_lineage(), allocator), allocator);
    if (!sr.isdefault("reassortant"))         srval.AddMember("R", jsonifya(sr.get_reassortant(), allocator), allocator);
    if (!sr.isdefault("strings"))             srval.AddMember("S", jsonifya(sr.get_strings(), allocator), allocator);
    if (!sr.isdefault("continent"))           srval.AddMember("C", jsonifya(sr.get_continent(), allocator), allocator);
    if (!sr.isdefault("nucleotidesequence"))  srval.AddMember("B", jsonifya(sr.get_nucleotidesequence(), allocator), allocator);

    // set_group_values
    // set_reference
    // set_name_full
    // set_name_abbreviated
    s.PushBack(srval, allocator);

  }


  // == TITERS ==========================
  Value t(kObjectType);
  Value d = jsonifya( map.titer_table_flat, allocator );
  t.AddMember("d", d, allocator);

  if(map.titer_table_layers.size() > 1){
    Value L(kArrayType);
    for(arma::uword layer=0; layer<map.titer_table_layers.size(); layer++){
      Value titertableval = jsonifya( map.titer_table_layers[layer], allocator );
      L.PushBack(titertableval, allocator);
    }
    t.AddMember("L", L, allocator);
  }

  // == PLOTSPEC =====================
  Value p(kObjectType);
  Value ptstyles(kArrayType);
  arma::uvec ptstyle_indices( num_points );

  // Antigens
  for(int i=0; i<num_antigens; i++){

    // Generate the point style
    Value ptstyle = jsonifya(map.antigens[i].plotspec, allocator);

    // Check if that point style already exists
    int ptstyle_index = -1;
    for(SizeType j=0; j<ptstyles.Size(); j++){
      if(ptstyles[j] == ptstyle){
        ptstyle_index = j;
        break;
      }
    }

    // Add the point style if not already found
    if(ptstyle_index == -1){
      ptstyles.PushBack(ptstyle, allocator);
      ptstyle_index = ptstyles.Size() - 1;
    }

    // Record the point style index
    ptstyle_indices[i] = ptstyle_index;

  }

  // Sera
  for(int i=0; i<num_sera; i++){

    // Generate the point style
    Value ptstyle = jsonifya(map.sera[i].plotspec, allocator);

    // Check if that point style already exists
    int ptstyle_index = -1;
    for(SizeType j=0; j<ptstyles.Size(); j++){
      if(ptstyles[j] == ptstyle){
        ptstyle_index = j;
        break;
      }
    }

    // Add the point style if not already found
    if(ptstyle_index == -1){
      ptstyles.PushBack(ptstyle, allocator);
      ptstyle_index = ptstyles.Size() - 1;
    }

    // Record the point style index
    ptstyle_indices[i + num_antigens] = ptstyle_index;

  }

  // Add to the plotspec json
  p.AddMember("p", jsonifya(ptstyle_indices, allocator), allocator);
  p.AddMember("P", ptstyles, allocator);

  // Drawing order
  p.AddMember("d", jsonifya(map.get_pt_drawing_order(), allocator), allocator);


  // == OPTIMIZATION RUNS ======================
  Value P(kArrayType); // optimizations aka "projections"

  // Add optimizations
  for(arma::uword i=0; i<map.optimizations.size(); i++){

    Value optjson(kObjectType);

    // Comment
    if (!map.optimizations.at(i).isdefault("comment")) {
      optjson.AddMember("c", jsonifya(map.optimizations.at(i).get_comment(), allocator), allocator);
    }

    // Stress
    optjson.AddMember("s", jsonify(map.optimizations.at(i).stress), allocator);

    // Minimum column basis
    if (!map.optimizations.at(i).isdefault("minimum_column_basis")) {
      optjson.AddMember("m", jsonifya(map.optimizations.at(i).get_min_column_basis(), allocator), allocator);
    }

    // Fixed column bases
    if (!map.optimizations.at(i).isdefault("fixed_column_bases")) {
      optjson.AddMember("C", jsonifya( map.optimizations.at(i).get_fixed_column_bases(), allocator), allocator);
    }

    // Transformation
    if (!map.optimizations.at(i).isdefault("transformation")) {
      arma::vec transformation_vec = arma::vectorise( map.optimizations.at(i).get_transformation() );
      optjson.AddMember("t", jsonifya( transformation_vec , allocator ), allocator);
    }

    // Coords
    arma::mat coords = arma::join_cols( map.optimizations.at(i).get_ag_base_coords(), map.optimizations.at(i).get_sr_base_coords() );
    optjson.AddMember("l", jsonifya( coords, allocator ), allocator);

    // Add to array
    P.PushBack(optjson, allocator);

  }

  // == EXTRAS ==================================
  Value x(kObjectType);
  x.AddMember("racmacs-v", jsonifya(version, allocator), allocator); // Version info

  // = AGs =
  Value xa(kArrayType);
  bool ag_extras = false;
  bool ag_grouping_included = !map.isdefault("ag_group_levels");
  for(arma::uword i=0; i<map.antigens.size(); i++){
    Value agx(kObjectType);
    if (ag_grouping_included) {
      ag_extras = true;
      agx.AddMember("g", map.antigens[i].get_group(), allocator);
    }
    if (!map.antigens[i].isdefault("id")) {
      ag_extras = true;
      agx.AddMember("i", jsonifya(map.antigens[i].get_id(), allocator), allocator);
    }
    if (!map.antigens[i].isdefault("extra")) {
      ag_extras = true;
      agx.AddMember("x", jsonifya(map.antigens[i].get_extra(), allocator), allocator);
    }
    xa.PushBack(agx, allocator);
  }
  if (ag_extras) x.AddMember("a", xa, allocator);

  // = SR =
  Value xs(kArrayType);
  bool sr_extras = false;
  bool sr_grouping_included = !map.isdefault("sr_group_levels");
  for(arma::uword i=0; i<map.sera.size(); i++){
    Value srx(kObjectType);
    if (sr_grouping_included) {
      sr_extras = true;
      srx.AddMember("g", map.sera[i].get_group(), allocator);
    }
    if (!map.sera[i].isdefault("extra")) {
      sr_extras = true;
      srx.AddMember("x", jsonifya(map.sera[i].get_extra(), allocator), allocator);
    }
    xs.PushBack(srx, allocator);
  }
  if (sr_extras) x.AddMember("s", xs, allocator);

  // = OPTIMIZATIONS =
  Value xp(kArrayType);
  bool opt_extras = false;
  for(arma::uword i=0; i<map.optimizations.size(); i++){

    Value optx(kObjectType);

    // Translation
    if (!map.optimizations.at(i).isdefault("translation")) {
      opt_extras = true;
      optx.AddMember(
        "t",
        jsonifya(
          arma::conv_to<arma::vec>::from(map.optimizations.at(i).get_translation()),
          allocator
        ),
        allocator
      );
    }

    // Ag reactivity adjustments
    if (!map.optimizations.at(i).isdefault("ag_reactivity")) {
      opt_extras = true;
      optx.AddMember(
        "r",
        jsonifya(
          map.optimizations.at(i).get_ag_reactivity_adjustments(),
          allocator
        ),
        allocator
      );
    }

    // Bootstrapping
    if (!map.optimizations.at(i).isdefault("bootstrap")) {
      opt_extras = true;
      if (map.optimizations.at(i).bootstrap.size() > 0) {
        optx.AddMember(
          "b",
          jsonifya(map.optimizations.at(i).bootstrap, allocator),
          allocator
        );
      }
    }

    // // Hemisphering
    // for(arma::uword ag=0; ag<map.optimizations.at(i).ag_diagnostics.size(); ag++){
    //   if (map.optimizations.at(i).ag_diagnostics[ag].hemi.size() > 0) {
    //     Value key(
    //         std::to_string(ag).c_str(),
    //         allocator
    //     );
    //     optxh.AddMember(
    //       key,
    //       jsonifya(
    //         map.optimizations.at(i).ag_diagnostics[ag].hemi,
    //         allocator
    //       ),
    //       allocator
    //     );
    //   }
    // }
    //
    // for(arma::uword sr=0; sr<map.optimizations.at(i).sr_diagnostics.size(); sr++){
    //   if (map.optimizations.at(i).sr_diagnostics[sr].hemi.size() > 0) {
    //     Value key(
    //         std::to_string(sr + num_antigens).c_str(),
    //         allocator
    //     );
    //     optxh.AddMember(
    //       key,
    //       jsonifya(
    //         map.optimizations.at(i).sr_diagnostics[sr].hemi,
    //         allocator
    //       ),
    //       allocator
    //     );
    //   }
    // }
    //
    // if (optxh.Size() > 0) {
    //   optx.AddMember("h", optxh, allocator);
    // }

    xp.PushBack(optx, allocator);

  }
  if (opt_extras) x.AddMember("p", xp, allocator);

  // = OTHER =
  if (!map.isdefault("ag_group_levels"))   x.AddMember("agv", jsonifya(map.get_ag_group_levels(), allocator), allocator);
  if (!map.isdefault("sr_group_levels"))   x.AddMember("srv", jsonifya(map.get_sr_group_levels(), allocator), allocator);
  if (!map.isdefault("layer_names"))       x.AddMember("ln",  jsonifya(map.get_layer_names(), allocator), allocator);
  if (!map.isdefault("dilution_stepsize")) x.AddMember("ds",  map.dilution_stepsize, allocator);
  if (!map.isdefault("description"))       x.AddMember("D",   jsonifya(map.description, allocator), allocator);
  if (!map.isdefault("ag_reactivity"))     x.AddMember("r",   jsonifya(map.get_ag_reactivity_adjustments(), allocator), allocator);

  // == FINISH UP ===============================
  // Assemble the json map data and add it
  c.AddMember("i", i, allocator);
  c.AddMember("a", a, allocator);
  c.AddMember("s", s, allocator);
  c.AddMember("t", t, allocator);
  c.AddMember("p", p, allocator);
  c.AddMember("P", P, allocator);
  c.AddMember("x", x, allocator);
  doc.AddMember("c", c, allocator);

  // Return the map
  StringBuffer buffer;
  bool success;

  // Setup the writer
  if (pretty) {

    // PrettyWriter<StringBuffer> writer(buffer);
    PrettyWriter<
      StringBuffer, // Output Stream
      UTF8<>,       // Source Encoding
      UTF8<>,       // Target Encoding
      CrtAllocator,
      kParseFullPrecisionFlag
    > writer(buffer);
    writer.SetMaxDecimalPlaces(6);
    success = doc.Accept(writer);

  } else {

    // Writer<StringBuffer> writer(buffer);
    Writer<
      StringBuffer, // Output Stream
      UTF8<>,       // Source Encoding
      UTF8<>,       // Target Encoding
      CrtAllocator,
      kParseFullPrecisionFlag
      > writer(buffer);
    writer.SetMaxDecimalPlaces(6);
    success = doc.Accept(writer);

  }

  // Check for errors
  if(!success){
    Rf_error("Parsing to json .ace format failed");
  }

  // Return the string
  return buffer.GetString();

}



# ================================================
# FILE: src/json_write_from_acmap.h
# ================================================


#include "acmap_point.h"
#include "acmap_titers.h"
#include "acmap_diagnostics.h"

#include "json_assert.h"
// [[Rcpp::depends(rapidjsonr)]]
#include <rapidjson/document.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/writer.h>
#include <rapidjson/prettywriter.h>
// #include <rapidjson/filereadstream.h>

#ifndef Racmacs__json_write_from_acmap__h
#define Racmacs__json_write_from_acmap__h

// Setup general template for conversions
using namespace rapidjson;
template <typename T> Value jsonify(const T& object);

// To double
template <>
Value jsonify(
    const double& d
){

  Value val;
  if(std::isfinite(d)){
    val.SetDouble(round(d * 1e6) / 1e6);
  } else {
    val.SetNull();
  }
  return val;

}

// Setup general template for conversions using allocator
template <typename T> Value jsonifya(const T& object, Document::AllocatorType& allocator);

// To string
template <>
Value jsonifya(
    const std::string& s,
    Document::AllocatorType& allocator
){

  Value val;
  val.SetString( StringRef(s.c_str()), allocator );
  return val;

}

// To string array
template <>
Value jsonifya(
    const std::vector<std::string>& stringvec,
    Document::AllocatorType& allocator
){

  Value strvecjson(kArrayType);
  for(SizeType i=0; i<stringvec.size(); i++){
    strvecjson.PushBack(
      jsonifya( stringvec[i], allocator ),
      allocator
    );
  }
  return strvecjson;

}

// From arma::vec
template <>
Value jsonifya(
    const arma::vec& x,
    Document::AllocatorType& allocator
){

  Value a(kArrayType);
  for( arma::uword i=0; i<x.n_elem; i++ ){
    a.PushBack(jsonify(x(i)), allocator);
  }
  return a;

}

template <>
Value jsonifya(
    const arma::uvec& x,
    Document::AllocatorType& allocator
){

  Value a(kArrayType);
  for( arma::uword i=0; i<x.n_elem; i++ ){
    a.PushBack(x(i), allocator);
  }
  return a;

}

// From arma::mat
template <>
Value jsonifya(
    const arma::mat& m,
    Document::AllocatorType& allocator
){

  Value a(kArrayType);
  for( arma::uword i=0; i<m.n_rows; i++ ){
    arma::vec row = arma::vectorise( m.row(i) );
    a.PushBack(
      jsonifya(row, allocator),
      allocator
    );
  }
  return a;

}

// From titer table to json
template <>
Value jsonifya(
    const AcTiterTable& titertable,
    Document::AllocatorType& allocator
){

  Value agrows(kArrayType);
  for(SizeType ag=0; ag<titertable.nags(); ag++){
    Value srtiters(kObjectType);
    for(SizeType sr=0; sr<titertable.nsr(); sr++){
      if(titertable.titer_measured(ag, sr)){
        srtiters.AddMember(
          jsonifya( std::to_string(sr), allocator ),
          jsonifya(titertable.get_titer_string(ag, sr), allocator),
          allocator
        );
      }
    }
    agrows.PushBack(srtiters, allocator);
  }
  return agrows;

}

// From plotspec to json
template <>
Value jsonifya(
    const AcPlotspec& plotspec,
    Document::AllocatorType& allocator
){

  Value ptstyle(kObjectType);
  ptstyle.AddMember("+", plotspec.get_shown(), allocator);
  ptstyle.AddMember("F", jsonifya(plotspec.get_fill(), allocator), allocator);
  ptstyle.AddMember("O", jsonifya(plotspec.get_outline(), allocator), allocator);
  ptstyle.AddMember("o", plotspec.get_outline_width(), allocator);
  ptstyle.AddMember("S", jsonifya(plotspec.get_shape(), allocator), allocator);
  ptstyle.AddMember("s", plotspec.get_size(), allocator);
  ptstyle.AddMember("r", plotspec.get_rotation(), allocator);
  ptstyle.AddMember("a", plotspec.get_aspect(), allocator);
  return ptstyle;

}

// From BootstrapOutput
template <>
Value jsonifya(
    const std::vector<BootstrapOutput>& bootstraps,
    Document::AllocatorType& allocator
){

  Value bs(kObjectType);
  Value sampling(kArrayType);
  Value coords(kArrayType);

  for(auto &bootstrap : bootstraps){
    sampling.PushBack(jsonifya(bootstrap.sampling, allocator), allocator);
    coords.PushBack(jsonifya(bootstrap.coords, allocator), allocator);
  }

  bs.AddMember("coords", coords, allocator);
  bs.AddMember("sampling", sampling, allocator);
  return bs;

}

// To sequence insertions
template <>
Value jsonifya(
    const std::vector<SeqInsertion>& insertions,
    Document::AllocatorType& allocator
){

  Value out(kArrayType);
  for(SizeType i=0; i<insertions.size(); i++){
    Value insertion(kArrayType);
    insertion.PushBack(insertions[i].position, allocator);
    insertion.PushBack(jsonifya(insertions[i].insertion, allocator), allocator);
    out.PushBack(insertion, allocator);
  }
  return out;

}

#endif


# ================================================
# FILE: src/procrustes.cpp
# ================================================


#include <RcppArmadillo.h>
#include "acmap_map.h"
#include "procrustes.h"
#include "utils.h"
using namespace Rcpp;

// Define a procrustes transformation
// [[Rcpp::export]]
Procrustes ac_procrustes(
  arma::mat X,
  arma::mat Xstar,
  bool translation,
  bool dilation
){

  // Check input
  if(X.n_rows != Xstar.n_rows){ Rf_error("X and Xstar do not have same number of rows."); }

  // Exclude NaN coords
  arma::uvec na_rows = arma::join_cols( na_row_indices(X), na_row_indices(Xstar) );
  na_rows = arma::unique(na_rows);

  X.shed_rows(na_rows);
  Xstar.shed_rows(na_rows);

  // Expand coords to match maximum dimensions
  int dims = arma::max( arma::uvec{ X.n_cols, Xstar.n_cols } );
  X.resize(X.n_rows, dims);
  Xstar.resize(X.n_rows, dims);

  // Perform the calculation
  int n = X.n_rows;
  int m = X.n_cols;

  arma::mat J = arma::mat(n,n,arma::fill::eye);
  if(translation){
    J -= (1.0/n);
  }

  arma::mat tX = arma::trans(X);
  arma::mat tXstar = arma::trans(Xstar);

  arma::mat C = tXstar * J * X;


  arma::vec svd_d;
  arma::mat svd_u;
  arma::mat svd_v;
  arma::svd(
    svd_u,
    svd_d,
    svd_v,
    C
  );

  arma::mat R = svd_v * svd_u.t();
  double s = 1.0;

  if(dilation){

    arma::mat mat1 = tXstar * J * X * R;
    arma::mat mat2 = tX * J * X;

    double s_numer = 0.0;
    double s_denom = 0.0;

    for(int i=0; i<m; i++){
      s_numer += mat1(i,i);
      s_denom += mat2(i,i);
    }

    s = s_numer / s_denom;

  }

  arma::mat tt = arma::mat(m, 1, arma::fill::zeros);
  if(translation){

    arma::mat mat1 = arma::mat(n, 1, arma::fill::ones);
    arma::mat tmatmid = arma::trans(Xstar - s * X * R);
    tt = ((1.0/n) * tmatmid)*mat1;

  }

  Procrustes out;
  out.R = R;
  out.tt = tt;
  out.s = s;
  return out;

}


// Apply a procrustes transformation
arma::mat ac_apply_procrustes(
    arma::mat coords,
    Procrustes p
){

  return transform_coords(
    coords,
    p.R,
    p.tt,
    p.s
  );

}

// Align coordinates via procrustes
// [[Rcpp::export]]
arma::mat ac_align_coords(
    arma::mat source,
    arma::mat target,
    bool translation = true,
    bool dilation = false
){

  Procrustes p = ac_procrustes(
    source,
    target,
    translation,
    dilation
  );

  return ac_apply_procrustes(source, p);

}

// Apply a coordinate transformation
arma::mat transform_coords(
  const arma::mat &coords,
  const arma::mat &rotation,
  const arma::mat &translation,
  const double &scaling
) {

  // Work out maximum dims
  int dims = arma::max(
    arma::uvec{
      coords.n_cols,
      rotation.n_cols,
      translation.n_rows
    }
  );

  // Expand matrices to match maximum dimensions
  arma::mat tcoords(coords.n_rows, dims, arma::fill::zeros);
  tcoords.cols(0, coords.n_cols - 1) = coords;

  arma::mat trotation(dims, dims, arma::fill::eye);
  if(rotation.n_rows > 0){
    trotation.submat(
      0, 0,
      rotation.n_rows - 1, rotation.n_cols - 1
    ) = rotation;
  }

  arma::mat ttranslation(coords.n_rows, dims, arma::fill::zeros);
  for(arma::uword i=0; i<ttranslation.n_rows; i++){
    for(arma::uword j=0; j<translation.n_rows; j++){
      ttranslation(i,j) = translation(j,0);
    }
  }

  // Perform the transformation
  arma::mat out = (scaling*tcoords)*trotation + ttranslation;
  return out;

}

// Get procrustes result from one map to another
// [[Rcpp::export]]
AcCoords ac_procrustes_map_coords(
  const AcMap &base_map,
  AcMap procrustes_map,
  int base_map_optimization_number,
  int procrustes_map_optimization_number,
  bool translation = true,
  bool scaling = false
){

  // First realign the map to the base map
  procrustes_map.keepSingleOptimization( procrustes_map_optimization_number );
  procrustes_map.realign_to_map(
    base_map,
    base_map_optimization_number,
    translation,
    scaling,
    true // align_to_base_coords
  );

  // Return the coordinates of the realigned map
  AcCoords result;
  result.ag_coords = subset_rows( procrustes_map.optimizations.at(0).agCoords(), ac_match_points( base_map.antigens, procrustes_map.antigens ) );
  result.sr_coords = subset_rows( procrustes_map.optimizations.at(0).srCoords(), ac_match_points( base_map.sera, procrustes_map.sera ) );

  // Set coords that were na in the main map to na in the procrustes coords
  arma::uvec na_ags = arma::find_nonfinite(base_map.optimizations.at(base_map_optimization_number).get_ag_base_coords());
  arma::uvec na_srs = arma::find_nonfinite(base_map.optimizations.at(base_map_optimization_number).get_sr_base_coords());
  result.ag_coords.elem(na_ags).fill(arma::datum::nan);
  result.sr_coords.elem(na_srs).fill(arma::datum::nan);

  // Return the coordinates
  return result;

}

// Get a summary of procrustes data
// [[Rcpp::export]]
ProcrustesData ac_procrustes_map_data(
    const AcOptimization &optimization,
    AcCoords pc_coords
){

  // Calculate data
  arma::vec ag_dists = ac_coord_dists( optimization.get_ag_base_coords(), pc_coords.ag_coords );
  arma::vec sr_dists = ac_coord_dists( optimization.get_sr_base_coords(), pc_coords.sr_coords );
  double ag_rmsd = rmsd(ag_dists);
  double sr_rmsd = rmsd(sr_dists);
  double total_rmsd = rmsd( arma::join_cols(ag_dists, sr_dists) );

  // Return the summary of data
  return ProcrustesData{
    ag_dists,
    sr_dists,
    ag_rmsd,
    sr_rmsd,
    total_rmsd
  };

}



# ================================================
# FILE: src/procrustes.h
# ================================================


#ifndef Racmacs__procrustes__h
#define Racmacs__procrustes__h

#include <RcppArmadillo.h>

struct Procrustes
{
  arma::mat R;
  arma::mat tt;
  double s;
};

struct AcCoords
{
  arma::mat ag_coords;
  arma::mat sr_coords;
};

struct ProcrustesData
{
  arma::vec ag_dists;
  arma::vec sr_dists;
  double ag_rmsd;
  double sr_rmsd;
  double total_rmsd;
};

Procrustes ac_procrustes(
    arma::mat X,
    arma::mat Xstar,
    bool translation = true,
    bool dilation = false
);

arma::mat transform_coords(
    const arma::mat &coords,
    const arma::mat &rotation,
    const arma::mat &translation,
    const double &scaling = 1
);

#endif



# ================================================
# FILE: src/Racmacs_types.h
# ================================================


#include <RcppArmadillo.h>
#include "acmap_optimization.h"
#include "acmap_titers.h"
#include "acmap_map.h"
#include "acmap_diagnostics.h"
#include "procrustes.h"
#include "ac_dimension_test.h"
#include "ac_bootstrap.h"
#include "ac_errorlines.h"
#include "ac_stress_blobs.h"
#include "ac_optim_map_stress.h"
#include "ac_hemi_test.h"
#include "ac_merge.h"
#include "utils_error.h"

#ifndef Racmacs__RacmacsWrap__h
#define Racmacs__RacmacsWrap__h

// Functions for checking classes
void check_class(
    const SEXP &sxp,
    const std::string &classname
){
  if(!Rf_inherits(sxp, classname.c_str())){
    std::string msg = "Object must be of class '" + classname + "'\n";
    ac_error(msg);
  }
}

void check_matrix(
    const SEXP &sxp
){
  if(!Rf_isMatrix(sxp)){
    ac_error("Object must be of class 'matrix'");
  }
}

// declaring the specialization
namespace Rcpp {

// FROM: ACCOORDS
template <>
SEXP wrap(const AcCoords& coords){
  return wrap(
    List::create(
      _["ag_coords"] = coords.ag_coords,
      _["sr_coords"] = coords.sr_coords
    )
  );
}

// FROM: PROCRUSTES DATA
template <>
SEXP wrap(const ProcrustesData &pc){
  return wrap(
    List::create(
      _["ag_dists"] = pc.ag_dists,
      _["sr_dists"] = pc.sr_dists,
      _["ag_rmsd"] = pc.ag_rmsd,
      _["sr_rmsd"] = pc.sr_rmsd,
      _["total_rmsd"] = pc.total_rmsd
    )
  );
}

// FROM: ACTITER
template <>
SEXP wrap(const AcTiter& t){
  return wrap(t.toString());
}

// FROM: ACTITER VECTOR
template <>
SEXP wrap(const std::vector<AcTiter>& titers){
  CharacterVector titers_out(titers.size());
  for(arma::uword i=0; i<titers.size(); i++){
    titers_out[i] = titers[i].toString();
  }
  return wrap(titers_out);
}

// FROM: ACTITERTABLE
template <>
SEXP wrap(const AcTiterTable& t){

  int num_ags = t.nags();
  int num_sr = t.nsr();

  CharacterMatrix titers_out(num_ags, num_sr);
  for(int ag=0;ag<num_ags;ag++){
    for(int sr=0;sr<num_sr;sr++){
      std::string titer = t.get_titer_string(ag, sr);
      titers_out(ag, sr) = titer;
    }
  }

  return wrap(titers_out);
}

// FROM: PROCRUSTES
template <>
SEXP wrap(const Procrustes& p){
  return wrap(
    List::create(
      _["R"] = p.R,
      _["tt"] = p.tt,
      _["s"] = p.s
    )
  );
}

// FROM: ARMA::VEC
template <>
SEXP wrap(const arma::vec& v){
  NumericVector out(v.n_elem);
  for(arma::uword i=0; i<v.n_elem; i++){
    out[i] = v[i];
  }
  return wrap(out);
}

// FROM: ARMA::UVEC
template <>
SEXP wrap(const arma::uvec& v){
  NumericVector out(v.n_elem);
  for(arma::uword i=0; i<v.n_elem; i++){
    out[i] = v[i];
  }
  return wrap(out);
}

// FROM: ACPLOTSPEC
SEXP wrap(const AcPlotspec& ps){

  List out = wrap(
    List::create(
      _["shown"] = ps.get_shown(),
      _["size"] = ps.get_size(),
      _["fill"] = ps.get_fill(),
      _["shape"] = ps.get_shape(),
      _["outline"] = ps.get_outline(),
      _["outline_width"] = ps.get_outline_width(),
      _["rotation"] = ps.get_rotation(),
      _["aspect"] = ps.get_aspect()
    )
  );

  return out;

}

// FROM: ACANTIGEN
SEXP wrap(const AcAntigen& ag){

  List out = wrap(
    List::create(

      // Attributes
      _["name"] = ag.get_name(),
      _["extra"] = ag.get_extra(),
      // _["name_abbreviated"] = ag.get_name_abbreviated(),
      // _["name_full"] = ag.get_name_full(),
      _["id"] = ag.get_id(),
      _["date"] = ag.get_date(),
      _["group"] = ag.get_group(),
      _["sequence"] = ag.get_sequence(),
      _["sequence_insertions"] = ag.get_sequence_insertions(),
      _["passage"] = ag.get_passage(),
      _["clade"] = ag.get_clade(),
      _["annotations"] = ag.get_annotations(),
      _["labids"] = ag.get_labids(),
      _["lineage"] = ag.get_lineage(),
      _["reassortant"] = ag.get_reassortant(),
      _["strings"] = ag.get_strings(),
      _["continent"] = ag.get_continent(),
      _["nucleotidesequence"] = ag.get_nucleotidesequence(),

      // Plotspec
      _["plotspec"] = as<List>(wrap(ag.plotspec))

    )
  );

  // Set class attribute and return
  out.attr("class") = CharacterVector::create("acantigen", "list");
  return out;

}

// FROM: ACSERUM
SEXP wrap(const AcSerum& sr){

  List out = wrap(
    List::create(

      // Attributes
      _["name"] = sr.get_name(),
      _["extra"] = sr.get_extra(),
      _["id"] = sr.get_id(),
      _["date"] = sr.get_date(),
      _["group"] = sr.get_group(),
      _["homologous_ags"] = sr.get_homologous_ags(),
      _["sequence"] = sr.get_sequence(),
      _["sequence_insertions"] = sr.get_sequence_insertions(),
      _["passage"] = sr.get_passage(),
      _["species"] = sr.get_species(),
      _["clade"] = sr.get_clade(),
      _["annotations"] = sr.get_annotations(),
      _["lineage"] = sr.get_lineage(),
      _["reassortant"] = sr.get_reassortant(),
      _["strings"] = sr.get_strings(),
      _["continent"] = sr.get_continent(),
      _["nucleotidesequence"] = sr.get_nucleotidesequence(),

      // Plotspec
      _["plotspec"] = as<List>(wrap(sr.plotspec))

    )
  );

  // Set class attribute and return
  out.attr("class") = CharacterVector::create("acserum", "list");
  return out;

}

// FROM: ACDIAGNOSTICS
template <>
SEXP wrap(const HemiDiagnosis& hemidiag){
  return List::create(
    _["coords"] = hemidiag.coords,
    _["diagnosis"] = hemidiag.diagnosis
  );
}

template <>
SEXP wrap(const AcDiagnostics& acdiag){
  return List::create(
    _["hemi"] = acdiag.hemi
  );
}

// FROM: SEQINSERTION
template <>
SEXP wrap(const SeqInsertion& s){
  return List::create(
    s.position,
    s.insertion
  );
}

// FROM: ACOPTIMIZATION
template <>
SEXP wrap(const AcOptimization& acopt){

  List out = List::create(
    _["ag_base_coords"] = acopt.get_ag_base_coords(),
    _["sr_base_coords"] = acopt.get_sr_base_coords(),
    _["min_column_basis"] = acopt.get_min_column_basis(),
    _["fixed_column_bases"] = acopt.get_fixed_column_bases(),
    _["ag_reactivity_adjustments"] = acopt.get_ag_reactivity_adjustments(),
    _["transformation"] = acopt.get_transformation(),
    _["translation"] = acopt.get_translation(),
    _["stress"] = acopt.get_stress(),
    _["comment"] = acopt.get_comment(),
    _["ag_diagnostics"] = acopt.ag_diagnostics,
    _["sr_diagnostics"] = acopt.sr_diagnostics,
    _["bootstrap"] = acopt.bootstrap
  );

  // Set class attribute and return
  out.attr("class") = CharacterVector::create("acoptimization", "list");
  return out;

}

// FROM: ACMAP
template <>
SEXP wrap(const AcMap& acmap){

  // Attributes
  arma::uvec pt_drawing_order = acmap.get_pt_drawing_order() + 1;

  // Antigens
  List antigens = List::create();
  for(auto &antigen : acmap.antigens){
    antigens.push_back(as<List>(wrap(antigen)));
  }

  // Sera
  List sera = List::create();
  for(auto &serum : acmap.sera){
    sera.push_back(as<List>(wrap(serum)));
  }

  // Optimizations
  List optimizations = List::create();
  for(auto &optimization : acmap.optimizations){
    optimizations.push_back(as<List>(wrap(optimization)));
  }

  // Titer table layers
  List titer_table_layers = List::create();
  for(auto &titer_table_layer : acmap.titer_table_layers){
    titer_table_layers.push_back(as<CharacterMatrix>(wrap(titer_table_layer)));
  }

  // Titer table flat
  CharacterMatrix titer_table_flat = as<CharacterMatrix>(wrap(acmap.titer_table_flat));

  // Assemable list
  List out = List::create(
    _["name"] = acmap.name,
    _["description"] = acmap.description,
    _["dilution_stepsize"] = acmap.dilution_stepsize,
    _["antigens"] = antigens,
    _["sera"] = sera,
    _["optimizations"] = optimizations,
    _["titer_table_flat"] = titer_table_flat,
    _["titer_table_layers"] = titer_table_layers,
    _["pt_drawing_order"] = pt_drawing_order,
    _["ag_group_levels"] = acmap.get_ag_group_levels(),
    _["sr_group_levels"] = acmap.get_sr_group_levels(),
    _["ag_reactivity_adjustments"] = acmap.get_ag_reactivity_adjustments(),
    _["layer_names"] = acmap.get_layer_names()
  );

  // Set class attribute and return
  out.attr("class") = CharacterVector::create("acmap", "list");
  return wrap(out);

}

// Dimtest results
template <>
SEXP wrap(const DimTestOutput& dimtestout){

  List coords = List::create();
  for(auto &coord : dimtestout.coords){
    coords.push_back(as<NumericMatrix>(wrap(coord)));
  }

  List predictions = List::create();
  for(auto &prediction : dimtestout.predictions){
    predictions.push_back(as<NumericVector>(wrap(prediction)));
  }

  return wrap(
    List::create(
      _["test_indices"] = dimtestout.test_indices,
      _["dim"] = dimtestout.dim,
      _["coords"] = coords,
      _["predictions"] = predictions
    )
  );

}

// Bootstrap results
template <>
SEXP wrap(const BootstrapOutput& bootstrapout){

  return wrap(
    List::create(
      _["sampling"] = bootstrapout.sampling,
      _["coords"] = bootstrapout.coords,
      _["stress"] = bootstrapout.stress
    )
  );

}

// Error line results
template <>
SEXP wrap(const ErrorLineData &errorlines){

  return wrap(
    DataFrame::create(
      _["x"] = errorlines.x,
      _["xend"] = errorlines.xend,
      _["y"] = errorlines.y,
      _["yend"] = errorlines.yend,
      _["color"] = errorlines.color
    )
  );

}

// Stress blob results 2d
template <>
SEXP wrap(const StressBlobGrid& blobgrid){

  return wrap(
    List::create(
      _["grid"] = blobgrid.grid,
      _["coords"] = List::create(blobgrid.xcoords, blobgrid.ycoords, blobgrid.zcoords),
      _["stress_lim"] = blobgrid.stress_lim
    )
  );

}

// For converting from R to C++
// TP: ACCOORDS
template <>
AcCoords as(SEXP sxp){
  List coords = as<List>(sxp);
  return AcCoords{
    coords["ag_coords"],
          coords["sr_coords"]
  };
}

// TO: AcMergeOptions
template <>
AcMergeOptions as(SEXP sxp){

  List opt = as<List>(sxp);
  return AcMergeOptions{
    opt["sd_limit"],
    opt["dilution_stepsize"],
    opt["merge_function"],
    opt["method"]
  };

}

// TO: AcOptimizerOptions
template <>
AcOptimizerOptions as(SEXP sxp){

  List opt = as<List>(sxp);
  
  AcOptimizerOptions options;
  
  options.dim_annealing = opt["dim_annealing"];
  options.method = Rcpp::as<std::string>(opt["method"]);
  options.maxit = opt["maxit"];
  options.num_basis = opt["num_basis"];
  options.armijo_constant = opt["armijo_constant"];
  options.wolfe = opt["wolfe"];
  options.min_gradient_norm = opt["min_gradient_norm"];
  options.factr = opt["factr"];
  options.max_line_search_trials = opt["max_line_search_trials"];
  options.min_step = opt["min_step"];
  options.max_step = opt["max_step"];
  options.num_cores = opt["num_cores"];
  options.report_progress = opt["report_progress"];
  options.progress_bar_length = opt["progress_bar_length"];
  
  // NEW: Handle optimize_colbases with backward compatibility
  if (opt.containsElementNamed("optimize_colbases")) {
    options.optimize_colbases = opt["optimize_colbases"];
  } else {
    options.optimize_colbases = false;
  }
  
  return options;

}

// TO: ACTITER
template <>
AcTiter as(SEXP sxp){
  std::string titer = as<std::string>(sxp);
  return AcTiter(titer);
}

// TO: ACTITERTABLE
template <>
AcTiterTable as(SEXP sxp){

  check_matrix(sxp);
  CharacterMatrix titers = as<CharacterMatrix>(sxp);
  int num_ags = titers.nrow();
  int num_sr = titers.ncol();
  AcTiterTable titertable = AcTiterTable(
    num_ags,
    num_sr
  );

  for(int ag=0; ag<num_ags; ag++){
    for(int sr=0; sr<num_sr; sr++){
      titertable.set_titer_string(
        ag, sr,
        as<std::string>(titers(ag,sr))
      );
    }
  }

  return titertable;

}

// TO: ACTITER VECTOR
template <>
std::vector<AcTiter> as(SEXP sxp){
  CharacterVector titerstrings = as<CharacterVector>(sxp);
  int ntiters = titerstrings.size();
  std::vector<AcTiter> out(ntiters);
  for(int i=0; i<ntiters; i++){
    out[i] = as<AcTiter>(wrap(titerstrings(i)));
  }
  return out;
}

// TO: ACTITERTABLE VECTOR
template <>
std::vector<AcTiterTable> as(SEXP sxp){
  List list = as<List>(sxp);
  std::vector<AcTiterTable> out;
  for(int i=0; i<list.size(); i++){
    out.push_back(
      as<AcTiterTable>(wrap(
          list(i)
      ))
    );
  }
  return out;
}

// TO: ACPLOTSPEC
template<>
AcPlotspec as(SEXP sxp){

  List list = as<List>(sxp);
  AcPlotspec ps;

  if(list.containsElementNamed("shown")) ps.set_shown(list["shown"]);
  if(list.containsElementNamed("size")) ps.set_size(list["size"]);
  if(list.containsElementNamed("fill")) ps.set_fill(list["fill"]);
  if(list.containsElementNamed("shape")) ps.set_shape(list["shape"]);
  if(list.containsElementNamed("outline")) ps.set_outline(list["outline"]);
  if(list.containsElementNamed("outline_width")) ps.set_outline_width(list["outline_width"]);
  if(list.containsElementNamed("rotation")) ps.set_rotation(list["rotation"]);
  if(list.containsElementNamed("aspect")) ps.set_aspect(list["aspect"]);

  return ps;

}

// TO: ACANTIGEN
template <>
AcAntigen as(SEXP sxp){

  check_class(sxp, "acantigen");
  List list = as<List>(sxp);
  AcAntigen ag;

  // Attributes
  if(list.containsElementNamed("name")) ag.set_name(list["name"]);
  if(list.containsElementNamed("extra")) ag.set_extra(list["extra"]);
  if(list.containsElementNamed("id")) ag.set_id(list["id"]);
  if(list.containsElementNamed("date")) ag.set_date(list["date"]);
  if(list.containsElementNamed("group")) ag.set_group(list["group"]);
  if(list.containsElementNamed("sequence")) ag.set_sequence(list["sequence"]);
  if(list.containsElementNamed("sequence_insertions")) ag.set_sequence_insertions(list["sequence_insertions"]);
  if(list.containsElementNamed("passage")) ag.set_passage(list["passage"]);
  if(list.containsElementNamed("clade")) ag.set_clade(list["clade"]);
  if(list.containsElementNamed("annotations")) ag.set_annotations(list["annotations"]);
  if(list.containsElementNamed("labids")) ag.set_labids(list["labids"]);
  if(list.containsElementNamed("lineage")) ag.set_lineage(list["lineage"]);
  if(list.containsElementNamed("reassortant")) ag.set_reassortant(list["reassortant"]);
  if(list.containsElementNamed("strings")) ag.set_strings(list["strings"]);
  if(list.containsElementNamed("continent")) ag.set_continent(list["continent"]);
  if(list.containsElementNamed("nucleotidesequence")) ag.set_nucleotidesequence(list["nucleotidesequence"]);

  // Plotspec
  if(list.containsElementNamed("plotspec")) ag.plotspec = as<AcPlotspec>(list["plotspec"]);

  return ag;

}

// TO: ACSERUM
template <>
AcSerum as(SEXP sxp){

  check_class(sxp, "acserum");
  List list = as<List>(sxp);
  AcSerum sr;

  // Attributes
  if(list.containsElementNamed("name")) sr.set_name(list["name"]);
  if(list.containsElementNamed("extra")) sr.set_extra(list["extra"]);
  // if(list.containsElementNamed("name_abbreviated")) sr.set_name_abbreviated(list["name_abbreviated"]);
  // if(list.containsElementNamed("name_full")) sr.set_name_full(list["name_full"]);
  if(list.containsElementNamed("id")) sr.set_id(list["id"]);
  if(list.containsElementNamed("date")) sr.set_date(list["date"]);
  if(list.containsElementNamed("group")) sr.set_group(list["group"]);
  if(list.containsElementNamed("homologous_ags")) sr.set_homologous_ags(list["homologous_ags"]);
  if(list.containsElementNamed("sequence")) sr.set_sequence(list["sequence"]);
  if(list.containsElementNamed("sequence_insertions")) sr.set_sequence_insertions(list["sequence_insertions"]);
  if(list.containsElementNamed("passage")) sr.set_passage(list["passage"]);
  if(list.containsElementNamed("species")) sr.set_species(list["species"]);
  if(list.containsElementNamed("clade")) sr.set_clade(list["clade"]);
  if(list.containsElementNamed("annotations")) sr.set_annotations(list["annotations"]);
  if(list.containsElementNamed("lineage")) sr.set_lineage(list["lineage"]);
  if(list.containsElementNamed("reassortant")) sr.set_reassortant(list["reassortant"]);
  if(list.containsElementNamed("strings")) sr.set_strings(list["strings"]);
  if(list.containsElementNamed("continent")) sr.set_continent(list["continent"]);
  if(list.containsElementNamed("nucleotidesequence")) sr.set_nucleotidesequence(list["nucleotidesequence"]);

  // Plotspec
  if(list.containsElementNamed("plotspec")) sr.plotspec = as<AcPlotspec>(list["plotspec"]);

  return sr;

}

// TO: BOOTSTRAP
template <>
BootstrapOutput as(SEXP sxp) {

  List list = as<List>(sxp);
  BootstrapOutput out;

  out.sampling = as<arma::vec>(list["sampling"]);
  out.coords = as<arma::mat>(list["coords"]);

  return out;

}

// TO: ACDIAGNOSTICS
template <>
AcDiagnostics as(SEXP sxp){

  List list = as<List>(sxp);
  AcDiagnostics out;

  // Hemisphering data
  if (list.containsElementNamed("hemi")) {
    List list_hemi = list["hemi"];
    for (arma::uword i=0; i<list_hemi.size(); i++) {
      List list_hemi_i = list_hemi[i];
      HemiDiagnosis hemi;
      hemi.coords = as<arma::vec>(list_hemi_i["coords"]);
      hemi.diagnosis = as<std::string>(list_hemi_i["diagnosis"]);
      out.hemi.push_back(hemi);
    }
  }

  return out;

}

// TO: SEQINSERTION
template <>
SeqInsertion as(SEXP sxp){

  List list = as<List>(sxp);
  SeqInsertion out;
  out.position = list[0];
  out.insertion = as<std::string>(list[1]);
  return out;

}

// TO: ACOPTIMIZATION
template <>
AcOptimization as(SEXP sxp){

  // Check input
  check_class(sxp, "acoptimization");
  List opt = as<List>(sxp);

  // Get variables
  if(!opt.containsElementNamed("ag_base_coords")) { stop("Optimization must contain ag_base_coords"); }
  if(!opt.containsElementNamed("sr_base_coords")) { stop("Optimization must contain sr_base_coords"); }
  arma::mat ag_base_coords = as<arma::mat>(wrap(opt["ag_base_coords"]));
  arma::mat sr_base_coords = as<arma::mat>(wrap(opt["sr_base_coords"]));

  // Setup object
  AcOptimization acopt = AcOptimization(
    ag_base_coords.n_cols,
    ag_base_coords.n_rows,
    sr_base_coords.n_rows
  );

  // Populate
  acopt.set_ag_base_coords( ag_base_coords );
  acopt.set_sr_base_coords( sr_base_coords );
  if(opt.containsElementNamed("transformation")) {
    acopt.set_transformation( as<arma::mat>(wrap(opt["transformation"])) );
  }
  if(opt.containsElementNamed("translation")) {
    acopt.set_translation( as<arma::mat>(wrap(opt["translation"])) );
  }
  if(opt.containsElementNamed("comment")) {
    acopt.set_comment( as<std::string>(wrap(opt["comment"])) );
  }
  if(opt.containsElementNamed("fixed_column_bases")) {
    acopt.set_fixed_column_bases( as<arma::vec>(wrap(opt["fixed_column_bases"])) );
  }
  if(opt.containsElementNamed("min_column_basis")) {
    acopt.set_min_column_basis( as<std::string>(wrap(opt["min_column_basis"])) );
  }
  if(opt.containsElementNamed("ag_reactivity_adjustments")) {
    acopt.set_ag_reactivity_adjustments( as<arma::vec>(wrap(opt["ag_reactivity_adjustments"])) );
  }
  if(opt.containsElementNamed("ag_diagnostics")) {
    List ag_diagnostics = opt["ag_diagnostics"];
    for (arma::uword i=0; i<ag_diagnostics.size(); i++) {
      acopt.ag_diagnostics[i] = as<AcDiagnostics>(wrap(ag_diagnostics[i]));
    }
  }
  if(opt.containsElementNamed("sr_diagnostics")) {
    List sr_diagnostics = opt["sr_diagnostics"];
    for (arma::uword i=0; i<sr_diagnostics.size(); i++) {
      acopt.sr_diagnostics[i] = as<AcDiagnostics>(wrap(sr_diagnostics[i]));
    }
  }
  if(opt.containsElementNamed("bootstrap")) {
    acopt.bootstrap = as<std::vector<BootstrapOutput>>(wrap(opt["bootstrap"]));
  }
  if(opt.containsElementNamed("stress")) {
    acopt.set_stress( as<double>(wrap(opt["stress"])) );
  }

  // Return the object
  return acopt;

}

// TO: VECTOR OF ACOPTIMIZATION
template <>
std::vector<AcOptimization> as(SEXP sxp){

  // Setup output
  std::vector<AcOptimization> out;

  // Convert to list
  List optlist = as<List>(sxp);
  for (arma::uword i=0; i<optlist.size(); i++) {
    out.push_back(as<AcOptimization>(wrap(optlist[i])));
  }

  // Return vector output
  return(out);

}

// TO: ACMAP
template <>
AcMap as(SEXP sxp){

  check_class(sxp, "acmap");
  List list = as<List>(sxp);
  List antigens = list["antigens"];
  List sera = list["sera"];
  AcMap acmap(antigens.size(), sera.size());

  // Attributes
  if(list.containsElementNamed("name")) acmap.name = as<std::string>(list["name"]);
  if(list.containsElementNamed("description")) acmap.description = as<std::string>(list["description"]);
  if(list.containsElementNamed("dilution_stepsize")) acmap.dilution_stepsize = as<double>(list["dilution_stepsize"]);
  if(list.containsElementNamed("pt_drawing_order")){
    acmap.set_pt_drawing_order(
      as<arma::uvec>(wrap(list["pt_drawing_order"])) - 1
    );
  }
  if(list.containsElementNamed("ag_group_levels")) acmap.set_ag_group_levels( list["ag_group_levels"] );
  if(list.containsElementNamed("sr_group_levels")) acmap.set_sr_group_levels( list["sr_group_levels"] );
  if(list.containsElementNamed("ag_reactivity_adjustments")) acmap.set_ag_reactivity_adjustments( list["ag_reactivity_adjustments"] );
  if(list.containsElementNamed("layer_names")) acmap.set_layer_names( list["layer_names"] );

  // Antigens
  for(arma::uword i=0; i<acmap.antigens.size(); i++){
    acmap.antigens[i] = as<AcAntigen>(wrap(antigens[i]));
  }

  // Sera
  for(arma::uword i=0; i<acmap.sera.size(); i++){
    acmap.sera[i] = as<AcSerum>(wrap(sera[i]));
  }

  // Optimizations
  if(list.containsElementNamed("optimizations")){
    List optimizations = list["optimizations"];
    for(int i=0; i<optimizations.size(); i++){
      acmap.optimizations.push_back(as<AcOptimization>(wrap(optimizations.at(i))));
    }
  }

  // Titer table layers
  if(list.containsElementNamed("titer_table_layers")){
    List titer_table_layers = list["titer_table_layers"];
    for(int i=0; i<titer_table_layers.size(); i++){
      acmap.titer_table_layers.push_back(as<AcTiterTable>(wrap(titer_table_layers[i])));
    }
  }

  // Titer table flat
  if(list.containsElementNamed("titer_table_flat")){
    acmap.titer_table_flat = as<AcTiterTable>(wrap(list["titer_table_flat"]));
  }

  return acmap;

}

// TO: ACMAP VECTOR
template <>
std::vector<AcMap> as(SEXP sxp){
  List maps = as<List>(sxp);
  int nmaps = maps.size();
  std::vector<AcMap> out;
  for(int i=0; i<nmaps; i++){
    out.push_back(as<AcMap>(wrap(maps[i])));
  }
  return out;
}

}

#endif


# ================================================
# FILE: src/Racmacs_wrappers_antigens.cpp
# ================================================


#include <RcppArmadillo.h>
#include "acmap_map.h"
#include "acmap_point.h"


// [[Rcpp::export(rng = false)]]
AcAntigen ac_new_antigen( std::string name ){
  AcAntigen ag;
  ag.set_name(name);
  return ag;
}


// --- GETTERS -----------------------------

// [[Rcpp::export(rng = false)]]
std::string ac_ag_get_id( const AcAntigen &ag ){ return ag.get_id(); }
// [[Rcpp::export(rng = false)]]
std::string ac_ag_get_date( const AcAntigen &ag ){ return ag.get_date(); }
// [[Rcpp::export(rng = false)]]
bool ac_ag_get_reference( const AcAntigen &ag ){ return ag.get_reference(); }
// [[Rcpp::export(rng = false)]]
std::string ac_ag_get_passage( const AcAntigen &ag ){ return ag.get_passage(); }
// [[Rcpp::export(rng = false)]]
std::vector<std::string> ac_ag_get_clade( const AcAntigen &ag ){ return ag.get_clade(); }
// [[Rcpp::export(rng = false)]]
std::vector<std::string> ac_ag_get_annotations( const AcAntigen &ag ){ return ag.get_annotations(); }
// [[Rcpp::export(rng = false)]]
std::vector<std::string> ac_ag_get_labids( const AcAntigen &ag ){ return ag.get_labids(); }
// [[Rcpp::export(rng = false)]]
std::string ac_ag_get_name( const AcAntigen &ag ){ return ag.get_name(); }
// [[Rcpp::export(rng = false)]]
std::string ac_ag_get_extra( const AcAntigen &ag ){ return ag.get_extra(); }
// [[Rcpp::export(rng = false)]]
std::string ac_ag_get_lineage( const AcAntigen &ag ){ return ag.get_lineage(); }
// [[Rcpp::export(rng = false)]]
std::string ac_ag_get_reassortant( const AcAntigen &ag ){ return ag.get_reassortant(); }
// [[Rcpp::export(rng = false)]]
std::string ac_ag_get_strings( const AcAntigen &ag ){ return ag.get_strings(); }
// [[Rcpp::export(rng = false)]]
std::string ac_ag_get_continent( const AcAntigen &ag ){ return ag.get_continent(); }

// [[Rcpp::export(rng = false)]]
std::string ac_ag_get_match_id( const AcAntigen &ag ){ return ag.get_match_id(); }
// [[Rcpp::export(rng = false)]]
int ac_ag_get_group( const AcAntigen &ag ){ return ag.get_group(); }
// [[Rcpp::export(rng = false)]]
std::vector<std::string> ac_ag_get_group_levels( const AcMap map ){ return map.get_ag_group_levels(); }


// --- SETTERS -----------------------------

// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_id( AcAntigen ag, std::string value ){ ag.set_id(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_date( AcAntigen ag, std::string value ){ ag.set_date(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_reference( AcAntigen ag, bool value ){  ag.set_reference(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_passage( AcAntigen ag, std::string value ){ ag.set_passage(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_clade( AcAntigen ag, std::vector<std::string> value ){ ag.set_clade(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_annotations( AcAntigen ag, std::vector<std::string> value ){ ag.set_annotations(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_labids( AcAntigen ag, std::vector<std::string> value ){ ag.set_labids(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_name( AcAntigen ag, std::string value ){ ag.set_name(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_extra( AcAntigen ag, std::string value ){ ag.set_extra(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_lineage( AcAntigen ag, std::string value ){ ag.set_lineage(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_reassortant( AcAntigen ag, std::string value ){ ag.set_reassortant(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_strings( AcAntigen ag, std::string value ){ ag.set_strings(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_continent( AcAntigen ag, std::string value ){ ag.set_continent(value); return ag; }

// [[Rcpp::export(rng = false)]]
AcAntigen ac_ag_set_group( AcAntigen ag, int value ){ ag.set_group(value); return ag; }
// [[Rcpp::export(rng = false)]]
AcMap ac_ag_set_group_levels( AcMap map, std::vector<std::string> values ){ map.set_ag_group_levels( values ); return map; }



# ================================================
# FILE: src/Racmacs_wrappers_optimizations.cpp
# ================================================


#include <RcppArmadillo.h>
#include "acmap_optimization.h"

// --- GETTERS -----------------------------

// [[Rcpp::export(rng = false)]]
arma::mat ac_opt_get_ag_base_coords( const AcOptimization opt ){ return opt.get_ag_base_coords(); }
// [[Rcpp::export(rng = false)]]
arma::mat ac_opt_get_sr_base_coords( const AcOptimization opt ){ return opt.get_sr_base_coords(); }
// [[Rcpp::export(rng = false)]]
arma::mat ac_opt_get_transformation( const AcOptimization opt ){ return opt.get_transformation(); }
// [[Rcpp::export(rng = false)]]
arma::mat ac_opt_get_translation( const AcOptimization opt ){ return opt.get_translation(); }
// [[Rcpp::export(rng = false)]]
std::string ac_opt_get_mincolbasis( const AcOptimization opt ){ return opt.get_min_column_basis(); }
// [[Rcpp::export(rng = false)]]
arma::vec ac_opt_get_fixedcolbases( const AcOptimization opt ){ return opt.get_fixed_column_bases(); }
// [[Rcpp::export(rng = false)]]
arma::vec ac_opt_get_agreactivityadjustments( const AcOptimization opt ){ return opt.get_ag_reactivity_adjustments(); }
// [[Rcpp::export(rng = false)]]
double ac_opt_get_stress( const AcOptimization opt ){ return opt.get_stress(); }
// [[Rcpp::export(rng = false)]]
int ac_opt_get_dimensions( const AcOptimization opt ){ return opt.get_dimensions(); }
// [[Rcpp::export(rng = false)]]
std::string ac_opt_get_comment( const AcOptimization opt ){ return opt.get_comment(); }




// --- SETTERS -----------------------------

// [[Rcpp::export(rng = false)]]
AcOptimization ac_opt_set_ag_base_coords( AcOptimization opt, arma::mat value ){ opt.set_ag_base_coords(value); return opt; }
// [[Rcpp::export(rng = false)]]
AcOptimization ac_opt_set_sr_base_coords( AcOptimization opt, arma::mat value ){ opt.set_sr_base_coords(value); return opt; }
// [[Rcpp::export(rng = false)]]
AcOptimization ac_opt_set_transformation( AcOptimization opt, arma::mat value ){ opt.set_transformation(value); return opt; }
// [[Rcpp::export(rng = false)]]
AcOptimization ac_opt_set_translation( AcOptimization opt, arma::mat value ){ opt.set_translation(value); return opt; }
// [[Rcpp::export(rng = false)]]
AcOptimization ac_opt_set_mincolbasis( AcOptimization opt, std::string value ){ opt.set_min_column_basis(value); return opt; }
// [[Rcpp::export(rng = false)]]
AcOptimization ac_opt_set_fixedcolbases( AcOptimization opt, arma::vec value ){
  opt.set_fixed_column_bases(value);
  return opt;
}
// [[Rcpp::export(rng = false)]]
AcOptimization ac_opt_set_agreactivityadjustments( AcOptimization opt, arma::vec value ){
  opt.set_ag_reactivity_adjustments(value);
  return opt;
}
// [[Rcpp::export(rng = false)]]
AcOptimization ac_opt_set_stress( AcOptimization opt, double value ){ opt.set_stress(value); return opt; }
// [[Rcpp::export(rng = false)]]
AcOptimization ac_opt_set_comment( AcOptimization opt, std::string value ){ opt.set_comment(value); return opt; }



// --- OTHER -----------------------------
// [[Rcpp::export(rng = false)]]
AcOptimization ac_rotate_optimization( AcOptimization opt, double degrees, int axis_num ){
  opt.rotate( degrees, axis_num );
  return opt;
}

// [[Rcpp::export(rng = false)]]
AcOptimization ac_reflect_optimization( AcOptimization opt, int axis_num ){
  opt.reflect( axis_num );
  return opt;
}

// [[Rcpp::export(rng = false)]]
AcOptimization ac_translate_optimization( AcOptimization opt, arma::mat translation ){
  opt.translate( translation );
  return opt;
}

// [[Rcpp::export(rng = false)]]
arma::mat ac_apply_optimization_transform( AcOptimization opt, arma::mat coords ){
  return opt.applyTransformation( coords );
}



# ================================================
# FILE: src/Racmacs_wrappers_plotspec.cpp
# ================================================


#include <RcppArmadillo.h>
#include "acmap_plotspec.h"

// --- GETTERS -----------------------------

// [[Rcpp::export(rng = false)]]
bool ac_plotspec_get_shown( const AcPlotspec ps ){ return ps.get_shown(); }
// [[Rcpp::export(rng = false)]]
double ac_plotspec_get_size( const AcPlotspec ps ){ return ps.get_size(); }
// [[Rcpp::export(rng = false)]]
std::string ac_plotspec_get_fill( const AcPlotspec ps ){ return ps.get_fill(); }
// [[Rcpp::export(rng = false)]]
std::string ac_plotspec_get_outline( const AcPlotspec ps ){ return ps.get_outline(); }
// [[Rcpp::export(rng = false)]]
double ac_plotspec_get_outline_width( const AcPlotspec ps ){ return ps.get_outline_width(); }
// [[Rcpp::export(rng = false)]]
double ac_plotspec_get_rotation( const AcPlotspec ps ){ return ps.get_rotation(); }
// [[Rcpp::export(rng = false)]]
double ac_plotspec_get_aspect( const AcPlotspec ps ){ return ps.get_aspect(); }
// [[Rcpp::export(rng = false)]]
std::string ac_plotspec_get_shape( const AcPlotspec ps ){ return ps.get_shape(); }


// --- SETTERS -----------------------------

// [[Rcpp::export(rng = false)]]
AcPlotspec ac_plotspec_set_shown( AcPlotspec ps, bool value ){ ps.set_shown(value); return ps; }
// [[Rcpp::export(rng = false)]]
AcPlotspec ac_plotspec_set_size( AcPlotspec ps, double value ){ ps.set_size(value); return ps; }
// [[Rcpp::export(rng = false)]]
AcPlotspec ac_plotspec_set_fill( AcPlotspec ps, std::string value ){ ps.set_fill(value); return ps; }
// [[Rcpp::export(rng = false)]]
AcPlotspec ac_plotspec_set_outline( AcPlotspec ps, std::string value ){ ps.set_outline(value); return ps; }
// [[Rcpp::export(rng = false)]]
AcPlotspec ac_plotspec_set_outline_width( AcPlotspec ps, double value ){ ps.set_outline_width(value); return ps; }
// [[Rcpp::export(rng = false)]]
AcPlotspec ac_plotspec_set_rotation( AcPlotspec ps, double value ){ ps.set_rotation(value); return ps; }
// [[Rcpp::export(rng = false)]]
AcPlotspec ac_plotspec_set_aspect( AcPlotspec ps, double value ){ ps.set_aspect(value); return ps; }
// [[Rcpp::export(rng = false)]]
AcPlotspec ac_plotspec_set_shape( AcPlotspec ps, std::string value ){ ps.set_shape(value); return ps; }



# ================================================
# FILE: src/Racmacs_wrappers_sera.cpp
# ================================================


#include <RcppArmadillo.h>
#include "acmap_map.h"
#include "acmap_point.h"


// [[Rcpp::export(rng = false)]]
AcSerum ac_new_serum( std::string name ){
  AcSerum sr;
  sr.set_name(name);
  return sr;
}


// --- GETTERS -----------------------------

// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_id( const AcSerum &sr ){ return sr.get_id(); }
// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_date( const AcSerum &sr ){ return sr.get_date(); }
// [[Rcpp::export(rng = false)]]
bool ac_sr_get_reference( const AcSerum &sr ){ return sr.get_reference(); }
// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_passage( const AcSerum &sr ){ return sr.get_passage(); }
// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_species( const AcSerum &sr ){ return sr.get_species(); }
// [[Rcpp::export(rng = false)]]
std::vector<std::string> ac_sr_get_clade( const AcSerum &sr ){ return sr.get_clade(); }
// [[Rcpp::export(rng = false)]]
std::vector<std::string> ac_sr_get_annotations( const AcSerum &sr ){ return sr.get_annotations(); }
// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_name( const AcSerum &sr ){ return sr.get_name(); }
// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_extra( const AcSerum &sr ){ return sr.get_extra(); }
// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_lineage( const AcSerum &sr ){ return sr.get_lineage(); }
// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_reassortant( const AcSerum &sr ){ return sr.get_reassortant(); }
// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_strings( const AcSerum &sr ){ return sr.get_strings(); }
// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_continent( const AcSerum &sr ){ return sr.get_continent(); }

// [[Rcpp::export(rng = false)]]
std::string ac_sr_get_match_id( const AcSerum &sr ){ return sr.get_match_id(); }

// [[Rcpp::export(rng = false)]]
arma::uvec ac_sr_get_homologous_ags( const AcSerum &sr ){ return sr.get_homologous_ags(); }

// [[Rcpp::export(rng = false)]]
int ac_sr_get_group( const AcSerum &sr ){ return sr.get_group(); }
// [[Rcpp::export(rng = false)]]
std::vector<std::string> ac_sr_get_group_levels( const AcMap map ){ return map.get_sr_group_levels(); }


// --- SETTERS -----------------------------

// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_id( AcSerum sr, std::string value ){ sr.set_id(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_date( AcSerum sr, std::string value ){ sr.set_date(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_reference( AcSerum sr, bool value ){  sr.set_reference(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_passage( AcSerum sr, std::string value ){ sr.set_passage(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_species( AcSerum sr, std::string value ){ sr.set_species(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_clade( AcSerum sr, std::vector<std::string> value ){ sr.set_clade(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_annotations( AcSerum sr, std::vector<std::string> value ){ sr.set_annotations(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_name( AcSerum sr, std::string value ){ sr.set_name(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_extra( AcSerum sr, std::string value ){ sr.set_extra(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_lineage( AcSerum sr, std::string value ){ sr.set_lineage(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_reassortant( AcSerum sr, std::string value ){ sr.set_reassortant(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_strings( AcSerum sr, std::string value ){ sr.set_strings(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_continent( AcSerum sr, std::string value ){ sr.set_continent(value); return sr; }


// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_homologous_ags( AcSerum sr, arma::uvec value ){ sr.set_homologous_ags(value); return sr; }

// [[Rcpp::export(rng = false)]]
AcSerum ac_sr_set_group( AcSerum sr, int value ){ sr.set_group(value); return sr; }
// [[Rcpp::export(rng = false)]]
AcMap ac_sr_set_group_levels( AcMap map, std::vector<std::string> values ){ map.set_sr_group_levels( values ); return map; }


# ================================================
# FILE: src/Racmacs_wrappers.cpp
# ================================================


#include <RcppArmadillo.h>
#include "ac_optim_map_stress.h"
#include "ac_optimization.h"
#include "acmap_map.h"
#include "acmap_optimization.h"
#include "procrustes.h"
using namespace Rcpp;

// Get variables
// [[Rcpp::export]]
std::vector<std::string> ac_ag_names(
  const AcMap map
){
  return map.agNames();
}

// Manipulate antigenic coordinates
// [[Rcpp::export]]
arma::mat ac_get_ag_coords(
  const AcOptimization opt
){
  return opt.agCoords();
}

// [[Rcpp::export]]
arma::mat ac_get_sr_coords(
    const AcOptimization opt
){
  return opt.srCoords();
}

// [[Rcpp::export]]
AcOptimization ac_set_ag_coords(
    AcOptimization opt,
    const arma::mat coords
){
  opt.set_ag_coords(coords);
  return opt;
}

// [[Rcpp::export]]
AcOptimization ac_set_sr_coords(
    AcOptimization opt,
    const arma::mat coords
){
  opt.set_sr_coords(coords);
  return opt;
}

// Align two optimizations
// [[Rcpp::export]]
AcOptimization ac_align_optimization(
  AcOptimization source_optimization,
  const AcOptimization target_optimization
){

  source_optimization.alignToOptimization(target_optimization);
  return source_optimization;

}

// Align all optimizations of one map to the first optimization of another
// [[Rcpp::export]]
AcMap ac_align_map(
  AcMap source_map,
  AcMap target_map,
  bool translation,
  bool scaling
){

  // Do the alignment
  source_map.realign_to_map(
    target_map,
    0,
    translation,
    scaling
  );

  // Return the map
  return source_map;

}

// Align multiple optimizations to the first one
// [[Rcpp::export]]
std::vector<AcOptimization> ac_align_optimizations(
  std::vector<AcOptimization> optimizations
){

  align_optimizations(optimizations);
  return optimizations;

}

// Subset a map
// [[Rcpp::export]]
AcMap ac_subset_map(
    AcMap map,
    const arma::uvec ags,
    const arma::uvec sr
){

  map.subset(ags, sr);
  return map;

}


// Get column bases
// [[Rcpp::export]]
arma::vec ac_table_colbases(
    const AcTiterTable titer_table,
    const std::string min_col_basis,
    const arma::vec fixed_col_bases,
    const arma::vec ag_reactivity_adjustments
){

  return titer_table.calc_colbases(
    min_col_basis,
    fixed_col_bases,
    ag_reactivity_adjustments
  );

}


// Get table distances
// [[Rcpp::export]]
arma::mat ac_numeric_table_distances(
    const AcTiterTable titer_table,
    const std::string min_col_basis,
    const arma::vec fixed_col_bases,
    const arma::vec ag_reactivity_adjustments
){

  return titer_table.numeric_table_distances(
    min_col_basis,
    fixed_col_bases,
    ag_reactivity_adjustments
  );

}


// Relax an optimization
// [[Rcpp::export]]
AcOptimization ac_newOptimization(
    int dimensions,
    int num_antigens,
    int num_sera
){

  return AcOptimization(
    dimensions,
    num_antigens,
    num_sera
  );

}


// Relax an optimization
// [[Rcpp::export]]
AcOptimization ac_relaxOptimization(
    AcOptimization opt,
    AcTiterTable titers,
    arma::uvec fixed_antigens,
    arma::uvec fixed_sera,
    AcOptimizerOptions options,
    arma::mat titer_weights,
    double dilution_stepsize
){

  opt.relax_from_titer_table(
    titers,
    options,
    fixed_antigens,
    fixed_sera,
    titer_weights,
    dilution_stepsize
  );
  return opt;

}


// Relax an optimization
// [[Rcpp::export]]
AcMap ac_optimize_map(
    AcMap map,
    int num_dims,
    int num_optimizations,
    std::string min_col_basis,
    arma::vec fixed_col_bases,
    arma::vec ag_reactivity_adjustments,
    arma::mat titer_weights,
    AcOptimizerOptions options
){

  map.optimize(
    num_dims,
    num_optimizations,
    min_col_basis,
    fixed_col_bases,
    ag_reactivity_adjustments,
    options,
    titer_weights
  );

  return map;

}






# ================================================
# FILE: src/RcppExports.cpp
# ================================================

// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "Racmacs_types.h"
#include <RcppArmadillo.h>
#include <RcppEnsmallen.h>
#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// ac_ag_names
std::vector<std::string> ac_ag_names(const AcMap map);
RcppExport SEXP _Racmacs_ac_ag_names(SEXP mapSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcMap >::type map(mapSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_names(map));
    return rcpp_result_gen;
END_RCPP
}
// ac_get_ag_coords
arma::mat ac_get_ag_coords(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_get_ag_coords(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_get_ag_coords(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_get_sr_coords
arma::mat ac_get_sr_coords(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_get_sr_coords(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_get_sr_coords(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_set_ag_coords
AcOptimization ac_set_ag_coords(AcOptimization opt, const arma::mat coords);
RcppExport SEXP _Racmacs_ac_set_ag_coords(SEXP optSEXP, SEXP coordsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type coords(coordsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_set_ag_coords(opt, coords));
    return rcpp_result_gen;
END_RCPP
}
// ac_set_sr_coords
AcOptimization ac_set_sr_coords(AcOptimization opt, const arma::mat coords);
RcppExport SEXP _Racmacs_ac_set_sr_coords(SEXP optSEXP, SEXP coordsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type coords(coordsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_set_sr_coords(opt, coords));
    return rcpp_result_gen;
END_RCPP
}
// ac_align_optimization
AcOptimization ac_align_optimization(AcOptimization source_optimization, const AcOptimization target_optimization);
RcppExport SEXP _Racmacs_ac_align_optimization(SEXP source_optimizationSEXP, SEXP target_optimizationSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type source_optimization(source_optimizationSEXP);
    Rcpp::traits::input_parameter< const AcOptimization >::type target_optimization(target_optimizationSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_align_optimization(source_optimization, target_optimization));
    return rcpp_result_gen;
END_RCPP
}
// ac_align_map
AcMap ac_align_map(AcMap source_map, AcMap target_map, bool translation, bool scaling);
RcppExport SEXP _Racmacs_ac_align_map(SEXP source_mapSEXP, SEXP target_mapSEXP, SEXP translationSEXP, SEXP scalingSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcMap >::type source_map(source_mapSEXP);
    Rcpp::traits::input_parameter< AcMap >::type target_map(target_mapSEXP);
    Rcpp::traits::input_parameter< bool >::type translation(translationSEXP);
    Rcpp::traits::input_parameter< bool >::type scaling(scalingSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_align_map(source_map, target_map, translation, scaling));
    return rcpp_result_gen;
END_RCPP
}
// ac_align_optimizations
std::vector<AcOptimization> ac_align_optimizations(std::vector<AcOptimization> optimizations);
RcppExport SEXP _Racmacs_ac_align_optimizations(SEXP optimizationsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<AcOptimization> >::type optimizations(optimizationsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_align_optimizations(optimizations));
    return rcpp_result_gen;
END_RCPP
}
// ac_subset_map
AcMap ac_subset_map(AcMap map, const arma::uvec ags, const arma::uvec sr);
RcppExport SEXP _Racmacs_ac_subset_map(SEXP mapSEXP, SEXP agsSEXP, SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcMap >::type map(mapSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type ags(agsSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_subset_map(map, ags, sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_table_colbases
arma::vec ac_table_colbases(const AcTiterTable titer_table, const std::string min_col_basis, const arma::vec fixed_col_bases, const arma::vec ag_reactivity_adjustments);
RcppExport SEXP _Racmacs_ac_table_colbases(SEXP titer_tableSEXP, SEXP min_col_basisSEXP, SEXP fixed_col_basesSEXP, SEXP ag_reactivity_adjustmentsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcTiterTable >::type titer_table(titer_tableSEXP);
    Rcpp::traits::input_parameter< const std::string >::type min_col_basis(min_col_basisSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type fixed_col_bases(fixed_col_basesSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type ag_reactivity_adjustments(ag_reactivity_adjustmentsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_table_colbases(titer_table, min_col_basis, fixed_col_bases, ag_reactivity_adjustments));
    return rcpp_result_gen;
END_RCPP
}
// ac_numeric_table_distances
arma::mat ac_numeric_table_distances(const AcTiterTable titer_table, const std::string min_col_basis, const arma::vec fixed_col_bases, const arma::vec ag_reactivity_adjustments);
RcppExport SEXP _Racmacs_ac_numeric_table_distances(SEXP titer_tableSEXP, SEXP min_col_basisSEXP, SEXP fixed_col_basesSEXP, SEXP ag_reactivity_adjustmentsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcTiterTable >::type titer_table(titer_tableSEXP);
    Rcpp::traits::input_parameter< const std::string >::type min_col_basis(min_col_basisSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type fixed_col_bases(fixed_col_basesSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type ag_reactivity_adjustments(ag_reactivity_adjustmentsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_numeric_table_distances(titer_table, min_col_basis, fixed_col_bases, ag_reactivity_adjustments));
    return rcpp_result_gen;
END_RCPP
}
// ac_newOptimization
AcOptimization ac_newOptimization(int dimensions, int num_antigens, int num_sera);
RcppExport SEXP _Racmacs_ac_newOptimization(SEXP dimensionsSEXP, SEXP num_antigensSEXP, SEXP num_seraSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< int >::type dimensions(dimensionsSEXP);
    Rcpp::traits::input_parameter< int >::type num_antigens(num_antigensSEXP);
    Rcpp::traits::input_parameter< int >::type num_sera(num_seraSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_newOptimization(dimensions, num_antigens, num_sera));
    return rcpp_result_gen;
END_RCPP
}
// ac_relaxOptimization
AcOptimization ac_relaxOptimization(AcOptimization opt, AcTiterTable titers, arma::uvec fixed_antigens, arma::uvec fixed_sera, AcOptimizerOptions options, arma::mat titer_weights, double dilution_stepsize);
RcppExport SEXP _Racmacs_ac_relaxOptimization(SEXP optSEXP, SEXP titersSEXP, SEXP fixed_antigensSEXP, SEXP fixed_seraSEXP, SEXP optionsSEXP, SEXP titer_weightsSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< AcTiterTable >::type titers(titersSEXP);
    Rcpp::traits::input_parameter< arma::uvec >::type fixed_antigens(fixed_antigensSEXP);
    Rcpp::traits::input_parameter< arma::uvec >::type fixed_sera(fixed_seraSEXP);
    Rcpp::traits::input_parameter< AcOptimizerOptions >::type options(optionsSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type titer_weights(titer_weightsSEXP);
    Rcpp::traits::input_parameter< double >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_relaxOptimization(opt, titers, fixed_antigens, fixed_sera, options, titer_weights, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// ac_optimize_map
AcMap ac_optimize_map(AcMap map, int num_dims, int num_optimizations, std::string min_col_basis, arma::vec fixed_col_bases, arma::vec ag_reactivity_adjustments, arma::mat titer_weights, AcOptimizerOptions options);
RcppExport SEXP _Racmacs_ac_optimize_map(SEXP mapSEXP, SEXP num_dimsSEXP, SEXP num_optimizationsSEXP, SEXP min_col_basisSEXP, SEXP fixed_col_basesSEXP, SEXP ag_reactivity_adjustmentsSEXP, SEXP titer_weightsSEXP, SEXP optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcMap >::type map(mapSEXP);
    Rcpp::traits::input_parameter< int >::type num_dims(num_dimsSEXP);
    Rcpp::traits::input_parameter< int >::type num_optimizations(num_optimizationsSEXP);
    Rcpp::traits::input_parameter< std::string >::type min_col_basis(min_col_basisSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type fixed_col_bases(fixed_col_basesSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type ag_reactivity_adjustments(ag_reactivity_adjustmentsSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type titer_weights(titer_weightsSEXP);
    Rcpp::traits::input_parameter< AcOptimizerOptions >::type options(optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_optimize_map(map, num_dims, num_optimizations, min_col_basis, fixed_col_bases, ag_reactivity_adjustments, titer_weights, options));
    return rcpp_result_gen;
END_RCPP
}
// ac_new_antigen
AcAntigen ac_new_antigen(std::string name);
RcppExport SEXP _Racmacs_ac_new_antigen(SEXP nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::string >::type name(nameSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_new_antigen(name));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_id
std::string ac_ag_get_id(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_id(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_id(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_date
std::string ac_ag_get_date(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_date(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_date(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_reference
bool ac_ag_get_reference(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_reference(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_reference(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_passage
std::string ac_ag_get_passage(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_passage(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_passage(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_clade
std::vector<std::string> ac_ag_get_clade(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_clade(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_clade(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_annotations
std::vector<std::string> ac_ag_get_annotations(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_annotations(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_annotations(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_labids
std::vector<std::string> ac_ag_get_labids(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_labids(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_labids(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_name
std::string ac_ag_get_name(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_name(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_name(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_extra
std::string ac_ag_get_extra(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_extra(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_extra(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_lineage
std::string ac_ag_get_lineage(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_lineage(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_lineage(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_reassortant
std::string ac_ag_get_reassortant(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_reassortant(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_reassortant(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_strings
std::string ac_ag_get_strings(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_strings(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_strings(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_continent
std::string ac_ag_get_continent(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_continent(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_continent(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_match_id
std::string ac_ag_get_match_id(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_match_id(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_match_id(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_group
int ac_ag_get_group(const AcAntigen& ag);
RcppExport SEXP _Racmacs_ac_ag_get_group(SEXP agSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcAntigen& >::type ag(agSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_group(ag));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_get_group_levels
std::vector<std::string> ac_ag_get_group_levels(const AcMap map);
RcppExport SEXP _Racmacs_ac_ag_get_group_levels(SEXP mapSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcMap >::type map(mapSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_get_group_levels(map));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_id
AcAntigen ac_ag_set_id(AcAntigen ag, std::string value);
RcppExport SEXP _Racmacs_ac_ag_set_id(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_id(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_date
AcAntigen ac_ag_set_date(AcAntigen ag, std::string value);
RcppExport SEXP _Racmacs_ac_ag_set_date(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_date(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_reference
AcAntigen ac_ag_set_reference(AcAntigen ag, bool value);
RcppExport SEXP _Racmacs_ac_ag_set_reference(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< bool >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_reference(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_passage
AcAntigen ac_ag_set_passage(AcAntigen ag, std::string value);
RcppExport SEXP _Racmacs_ac_ag_set_passage(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_passage(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_clade
AcAntigen ac_ag_set_clade(AcAntigen ag, std::vector<std::string> value);
RcppExport SEXP _Racmacs_ac_ag_set_clade(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::vector<std::string> >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_clade(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_annotations
AcAntigen ac_ag_set_annotations(AcAntigen ag, std::vector<std::string> value);
RcppExport SEXP _Racmacs_ac_ag_set_annotations(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::vector<std::string> >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_annotations(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_labids
AcAntigen ac_ag_set_labids(AcAntigen ag, std::vector<std::string> value);
RcppExport SEXP _Racmacs_ac_ag_set_labids(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::vector<std::string> >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_labids(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_name
AcAntigen ac_ag_set_name(AcAntigen ag, std::string value);
RcppExport SEXP _Racmacs_ac_ag_set_name(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_name(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_extra
AcAntigen ac_ag_set_extra(AcAntigen ag, std::string value);
RcppExport SEXP _Racmacs_ac_ag_set_extra(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_extra(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_lineage
AcAntigen ac_ag_set_lineage(AcAntigen ag, std::string value);
RcppExport SEXP _Racmacs_ac_ag_set_lineage(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_lineage(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_reassortant
AcAntigen ac_ag_set_reassortant(AcAntigen ag, std::string value);
RcppExport SEXP _Racmacs_ac_ag_set_reassortant(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_reassortant(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_strings
AcAntigen ac_ag_set_strings(AcAntigen ag, std::string value);
RcppExport SEXP _Racmacs_ac_ag_set_strings(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_strings(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_continent
AcAntigen ac_ag_set_continent(AcAntigen ag, std::string value);
RcppExport SEXP _Racmacs_ac_ag_set_continent(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_continent(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_group
AcAntigen ac_ag_set_group(AcAntigen ag, int value);
RcppExport SEXP _Racmacs_ac_ag_set_group(SEXP agSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcAntigen >::type ag(agSEXP);
    Rcpp::traits::input_parameter< int >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_group(ag, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_ag_set_group_levels
AcMap ac_ag_set_group_levels(AcMap map, std::vector<std::string> values);
RcppExport SEXP _Racmacs_ac_ag_set_group_levels(SEXP mapSEXP, SEXP valuesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcMap >::type map(mapSEXP);
    Rcpp::traits::input_parameter< std::vector<std::string> >::type values(valuesSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_ag_set_group_levels(map, values));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_get_ag_base_coords
arma::mat ac_opt_get_ag_base_coords(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_opt_get_ag_base_coords(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_get_ag_base_coords(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_get_sr_base_coords
arma::mat ac_opt_get_sr_base_coords(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_opt_get_sr_base_coords(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_get_sr_base_coords(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_get_transformation
arma::mat ac_opt_get_transformation(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_opt_get_transformation(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_get_transformation(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_get_translation
arma::mat ac_opt_get_translation(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_opt_get_translation(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_get_translation(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_get_mincolbasis
std::string ac_opt_get_mincolbasis(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_opt_get_mincolbasis(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_get_mincolbasis(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_get_fixedcolbases
arma::vec ac_opt_get_fixedcolbases(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_opt_get_fixedcolbases(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_get_fixedcolbases(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_get_agreactivityadjustments
arma::vec ac_opt_get_agreactivityadjustments(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_opt_get_agreactivityadjustments(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_get_agreactivityadjustments(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_get_stress
double ac_opt_get_stress(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_opt_get_stress(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_get_stress(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_get_dimensions
int ac_opt_get_dimensions(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_opt_get_dimensions(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_get_dimensions(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_get_comment
std::string ac_opt_get_comment(const AcOptimization opt);
RcppExport SEXP _Racmacs_ac_opt_get_comment(SEXP optSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcOptimization >::type opt(optSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_get_comment(opt));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_set_ag_base_coords
AcOptimization ac_opt_set_ag_base_coords(AcOptimization opt, arma::mat value);
RcppExport SEXP _Racmacs_ac_opt_set_ag_base_coords(SEXP optSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_set_ag_base_coords(opt, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_set_sr_base_coords
AcOptimization ac_opt_set_sr_base_coords(AcOptimization opt, arma::mat value);
RcppExport SEXP _Racmacs_ac_opt_set_sr_base_coords(SEXP optSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_set_sr_base_coords(opt, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_set_transformation
AcOptimization ac_opt_set_transformation(AcOptimization opt, arma::mat value);
RcppExport SEXP _Racmacs_ac_opt_set_transformation(SEXP optSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_set_transformation(opt, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_set_translation
AcOptimization ac_opt_set_translation(AcOptimization opt, arma::mat value);
RcppExport SEXP _Racmacs_ac_opt_set_translation(SEXP optSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_set_translation(opt, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_set_mincolbasis
AcOptimization ac_opt_set_mincolbasis(AcOptimization opt, std::string value);
RcppExport SEXP _Racmacs_ac_opt_set_mincolbasis(SEXP optSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_set_mincolbasis(opt, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_set_fixedcolbases
AcOptimization ac_opt_set_fixedcolbases(AcOptimization opt, arma::vec value);
RcppExport SEXP _Racmacs_ac_opt_set_fixedcolbases(SEXP optSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_set_fixedcolbases(opt, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_set_agreactivityadjustments
AcOptimization ac_opt_set_agreactivityadjustments(AcOptimization opt, arma::vec value);
RcppExport SEXP _Racmacs_ac_opt_set_agreactivityadjustments(SEXP optSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_set_agreactivityadjustments(opt, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_set_stress
AcOptimization ac_opt_set_stress(AcOptimization opt, double value);
RcppExport SEXP _Racmacs_ac_opt_set_stress(SEXP optSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< double >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_set_stress(opt, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_opt_set_comment
AcOptimization ac_opt_set_comment(AcOptimization opt, std::string value);
RcppExport SEXP _Racmacs_ac_opt_set_comment(SEXP optSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_opt_set_comment(opt, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_rotate_optimization
AcOptimization ac_rotate_optimization(AcOptimization opt, double degrees, int axis_num);
RcppExport SEXP _Racmacs_ac_rotate_optimization(SEXP optSEXP, SEXP degreesSEXP, SEXP axis_numSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< double >::type degrees(degreesSEXP);
    Rcpp::traits::input_parameter< int >::type axis_num(axis_numSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_rotate_optimization(opt, degrees, axis_num));
    return rcpp_result_gen;
END_RCPP
}
// ac_reflect_optimization
AcOptimization ac_reflect_optimization(AcOptimization opt, int axis_num);
RcppExport SEXP _Racmacs_ac_reflect_optimization(SEXP optSEXP, SEXP axis_numSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< int >::type axis_num(axis_numSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_reflect_optimization(opt, axis_num));
    return rcpp_result_gen;
END_RCPP
}
// ac_translate_optimization
AcOptimization ac_translate_optimization(AcOptimization opt, arma::mat translation);
RcppExport SEXP _Racmacs_ac_translate_optimization(SEXP optSEXP, SEXP translationSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type translation(translationSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_translate_optimization(opt, translation));
    return rcpp_result_gen;
END_RCPP
}
// ac_apply_optimization_transform
arma::mat ac_apply_optimization_transform(AcOptimization opt, arma::mat coords);
RcppExport SEXP _Racmacs_ac_apply_optimization_transform(SEXP optSEXP, SEXP coordsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type opt(optSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type coords(coordsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_apply_optimization_transform(opt, coords));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_get_shown
bool ac_plotspec_get_shown(const AcPlotspec ps);
RcppExport SEXP _Racmacs_ac_plotspec_get_shown(SEXP psSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcPlotspec >::type ps(psSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_get_shown(ps));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_get_size
double ac_plotspec_get_size(const AcPlotspec ps);
RcppExport SEXP _Racmacs_ac_plotspec_get_size(SEXP psSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcPlotspec >::type ps(psSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_get_size(ps));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_get_fill
std::string ac_plotspec_get_fill(const AcPlotspec ps);
RcppExport SEXP _Racmacs_ac_plotspec_get_fill(SEXP psSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcPlotspec >::type ps(psSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_get_fill(ps));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_get_outline
std::string ac_plotspec_get_outline(const AcPlotspec ps);
RcppExport SEXP _Racmacs_ac_plotspec_get_outline(SEXP psSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcPlotspec >::type ps(psSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_get_outline(ps));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_get_outline_width
double ac_plotspec_get_outline_width(const AcPlotspec ps);
RcppExport SEXP _Racmacs_ac_plotspec_get_outline_width(SEXP psSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcPlotspec >::type ps(psSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_get_outline_width(ps));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_get_rotation
double ac_plotspec_get_rotation(const AcPlotspec ps);
RcppExport SEXP _Racmacs_ac_plotspec_get_rotation(SEXP psSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcPlotspec >::type ps(psSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_get_rotation(ps));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_get_aspect
double ac_plotspec_get_aspect(const AcPlotspec ps);
RcppExport SEXP _Racmacs_ac_plotspec_get_aspect(SEXP psSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcPlotspec >::type ps(psSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_get_aspect(ps));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_get_shape
std::string ac_plotspec_get_shape(const AcPlotspec ps);
RcppExport SEXP _Racmacs_ac_plotspec_get_shape(SEXP psSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcPlotspec >::type ps(psSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_get_shape(ps));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_set_shown
AcPlotspec ac_plotspec_set_shown(AcPlotspec ps, bool value);
RcppExport SEXP _Racmacs_ac_plotspec_set_shown(SEXP psSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcPlotspec >::type ps(psSEXP);
    Rcpp::traits::input_parameter< bool >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_set_shown(ps, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_set_size
AcPlotspec ac_plotspec_set_size(AcPlotspec ps, double value);
RcppExport SEXP _Racmacs_ac_plotspec_set_size(SEXP psSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcPlotspec >::type ps(psSEXP);
    Rcpp::traits::input_parameter< double >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_set_size(ps, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_set_fill
AcPlotspec ac_plotspec_set_fill(AcPlotspec ps, std::string value);
RcppExport SEXP _Racmacs_ac_plotspec_set_fill(SEXP psSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcPlotspec >::type ps(psSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_set_fill(ps, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_set_outline
AcPlotspec ac_plotspec_set_outline(AcPlotspec ps, std::string value);
RcppExport SEXP _Racmacs_ac_plotspec_set_outline(SEXP psSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcPlotspec >::type ps(psSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_set_outline(ps, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_set_outline_width
AcPlotspec ac_plotspec_set_outline_width(AcPlotspec ps, double value);
RcppExport SEXP _Racmacs_ac_plotspec_set_outline_width(SEXP psSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcPlotspec >::type ps(psSEXP);
    Rcpp::traits::input_parameter< double >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_set_outline_width(ps, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_set_rotation
AcPlotspec ac_plotspec_set_rotation(AcPlotspec ps, double value);
RcppExport SEXP _Racmacs_ac_plotspec_set_rotation(SEXP psSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcPlotspec >::type ps(psSEXP);
    Rcpp::traits::input_parameter< double >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_set_rotation(ps, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_set_aspect
AcPlotspec ac_plotspec_set_aspect(AcPlotspec ps, double value);
RcppExport SEXP _Racmacs_ac_plotspec_set_aspect(SEXP psSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcPlotspec >::type ps(psSEXP);
    Rcpp::traits::input_parameter< double >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_set_aspect(ps, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_plotspec_set_shape
AcPlotspec ac_plotspec_set_shape(AcPlotspec ps, std::string value);
RcppExport SEXP _Racmacs_ac_plotspec_set_shape(SEXP psSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcPlotspec >::type ps(psSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_plotspec_set_shape(ps, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_new_serum
AcSerum ac_new_serum(std::string name);
RcppExport SEXP _Racmacs_ac_new_serum(SEXP nameSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::string >::type name(nameSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_new_serum(name));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_id
std::string ac_sr_get_id(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_id(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_id(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_date
std::string ac_sr_get_date(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_date(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_date(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_reference
bool ac_sr_get_reference(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_reference(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_reference(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_passage
std::string ac_sr_get_passage(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_passage(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_passage(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_species
std::string ac_sr_get_species(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_species(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_species(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_clade
std::vector<std::string> ac_sr_get_clade(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_clade(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_clade(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_annotations
std::vector<std::string> ac_sr_get_annotations(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_annotations(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_annotations(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_name
std::string ac_sr_get_name(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_name(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_name(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_extra
std::string ac_sr_get_extra(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_extra(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_extra(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_lineage
std::string ac_sr_get_lineage(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_lineage(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_lineage(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_reassortant
std::string ac_sr_get_reassortant(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_reassortant(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_reassortant(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_strings
std::string ac_sr_get_strings(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_strings(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_strings(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_continent
std::string ac_sr_get_continent(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_continent(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_continent(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_match_id
std::string ac_sr_get_match_id(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_match_id(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_match_id(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_homologous_ags
arma::uvec ac_sr_get_homologous_ags(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_homologous_ags(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_homologous_ags(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_group
int ac_sr_get_group(const AcSerum& sr);
RcppExport SEXP _Racmacs_ac_sr_get_group(SEXP srSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcSerum& >::type sr(srSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_group(sr));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_get_group_levels
std::vector<std::string> ac_sr_get_group_levels(const AcMap map);
RcppExport SEXP _Racmacs_ac_sr_get_group_levels(SEXP mapSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const AcMap >::type map(mapSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_get_group_levels(map));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_id
AcSerum ac_sr_set_id(AcSerum sr, std::string value);
RcppExport SEXP _Racmacs_ac_sr_set_id(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_id(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_date
AcSerum ac_sr_set_date(AcSerum sr, std::string value);
RcppExport SEXP _Racmacs_ac_sr_set_date(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_date(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_reference
AcSerum ac_sr_set_reference(AcSerum sr, bool value);
RcppExport SEXP _Racmacs_ac_sr_set_reference(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< bool >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_reference(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_passage
AcSerum ac_sr_set_passage(AcSerum sr, std::string value);
RcppExport SEXP _Racmacs_ac_sr_set_passage(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_passage(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_species
AcSerum ac_sr_set_species(AcSerum sr, std::string value);
RcppExport SEXP _Racmacs_ac_sr_set_species(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_species(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_clade
AcSerum ac_sr_set_clade(AcSerum sr, std::vector<std::string> value);
RcppExport SEXP _Racmacs_ac_sr_set_clade(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::vector<std::string> >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_clade(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_annotations
AcSerum ac_sr_set_annotations(AcSerum sr, std::vector<std::string> value);
RcppExport SEXP _Racmacs_ac_sr_set_annotations(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::vector<std::string> >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_annotations(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_name
AcSerum ac_sr_set_name(AcSerum sr, std::string value);
RcppExport SEXP _Racmacs_ac_sr_set_name(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_name(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_extra
AcSerum ac_sr_set_extra(AcSerum sr, std::string value);
RcppExport SEXP _Racmacs_ac_sr_set_extra(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_extra(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_lineage
AcSerum ac_sr_set_lineage(AcSerum sr, std::string value);
RcppExport SEXP _Racmacs_ac_sr_set_lineage(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_lineage(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_reassortant
AcSerum ac_sr_set_reassortant(AcSerum sr, std::string value);
RcppExport SEXP _Racmacs_ac_sr_set_reassortant(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_reassortant(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_strings
AcSerum ac_sr_set_strings(AcSerum sr, std::string value);
RcppExport SEXP _Racmacs_ac_sr_set_strings(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_strings(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_continent
AcSerum ac_sr_set_continent(AcSerum sr, std::string value);
RcppExport SEXP _Racmacs_ac_sr_set_continent(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< std::string >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_continent(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_homologous_ags
AcSerum ac_sr_set_homologous_ags(AcSerum sr, arma::uvec value);
RcppExport SEXP _Racmacs_ac_sr_set_homologous_ags(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< arma::uvec >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_homologous_ags(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_group
AcSerum ac_sr_set_group(AcSerum sr, int value);
RcppExport SEXP _Racmacs_ac_sr_set_group(SEXP srSEXP, SEXP valueSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcSerum >::type sr(srSEXP);
    Rcpp::traits::input_parameter< int >::type value(valueSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_group(sr, value));
    return rcpp_result_gen;
END_RCPP
}
// ac_sr_set_group_levels
AcMap ac_sr_set_group_levels(AcMap map, std::vector<std::string> values);
RcppExport SEXP _Racmacs_ac_sr_set_group_levels(SEXP mapSEXP, SEXP valuesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< AcMap >::type map(mapSEXP);
    Rcpp::traits::input_parameter< std::vector<std::string> >::type values(valuesSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_sr_set_group_levels(map, values));
    return rcpp_result_gen;
END_RCPP
}
// ac_bootstrap_map
BootstrapOutput ac_bootstrap_map(const AcMap map, std::string method, bool bootstrap_ags, bool bootstrap_sr, bool reoptimize, double ag_noise_sd, double titer_noise_sd, std::string minimum_column_basis, arma::vec fixed_column_bases, arma::vec ag_reactivity_adjustments, int num_optimizations, int num_dimensions, AcOptimizerOptions options);
RcppExport SEXP _Racmacs_ac_bootstrap_map(SEXP mapSEXP, SEXP methodSEXP, SEXP bootstrap_agsSEXP, SEXP bootstrap_srSEXP, SEXP reoptimizeSEXP, SEXP ag_noise_sdSEXP, SEXP titer_noise_sdSEXP, SEXP minimum_column_basisSEXP, SEXP fixed_column_basesSEXP, SEXP ag_reactivity_adjustmentsSEXP, SEXP num_optimizationsSEXP, SEXP num_dimensionsSEXP, SEXP optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcMap >::type map(mapSEXP);
    Rcpp::traits::input_parameter< std::string >::type method(methodSEXP);
    Rcpp::traits::input_parameter< bool >::type bootstrap_ags(bootstrap_agsSEXP);
    Rcpp::traits::input_parameter< bool >::type bootstrap_sr(bootstrap_srSEXP);
    Rcpp::traits::input_parameter< bool >::type reoptimize(reoptimizeSEXP);
    Rcpp::traits::input_parameter< double >::type ag_noise_sd(ag_noise_sdSEXP);
    Rcpp::traits::input_parameter< double >::type titer_noise_sd(titer_noise_sdSEXP);
    Rcpp::traits::input_parameter< std::string >::type minimum_column_basis(minimum_column_basisSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type fixed_column_bases(fixed_column_basesSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type ag_reactivity_adjustments(ag_reactivity_adjustmentsSEXP);
    Rcpp::traits::input_parameter< int >::type num_optimizations(num_optimizationsSEXP);
    Rcpp::traits::input_parameter< int >::type num_dimensions(num_dimensionsSEXP);
    Rcpp::traits::input_parameter< AcOptimizerOptions >::type options(optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_bootstrap_map(map, method, bootstrap_ags, bootstrap_sr, reoptimize, ag_noise_sd, titer_noise_sd, minimum_column_basis, fixed_column_bases, ag_reactivity_adjustments, num_optimizations, num_dimensions, options));
    return rcpp_result_gen;
END_RCPP
}
// ac_dimension_test_map
DimTestOutput ac_dimension_test_map(AcTiterTable titer_table, arma::uvec dimensions_to_test, double test_proportion, std::string minimum_column_basis, arma::vec fixed_column_bases, arma::vec ag_reactivity_adjustments, int num_optimizations, AcOptimizerOptions options);
RcppExport SEXP _Racmacs_ac_dimension_test_map(SEXP titer_tableSEXP, SEXP dimensions_to_testSEXP, SEXP test_proportionSEXP, SEXP minimum_column_basisSEXP, SEXP fixed_column_basesSEXP, SEXP ag_reactivity_adjustmentsSEXP, SEXP num_optimizationsSEXP, SEXP optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcTiterTable >::type titer_table(titer_tableSEXP);
    Rcpp::traits::input_parameter< arma::uvec >::type dimensions_to_test(dimensions_to_testSEXP);
    Rcpp::traits::input_parameter< double >::type test_proportion(test_proportionSEXP);
    Rcpp::traits::input_parameter< std::string >::type minimum_column_basis(minimum_column_basisSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type fixed_column_bases(fixed_column_basesSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type ag_reactivity_adjustments(ag_reactivity_adjustmentsSEXP);
    Rcpp::traits::input_parameter< int >::type num_optimizations(num_optimizationsSEXP);
    Rcpp::traits::input_parameter< AcOptimizerOptions >::type options(optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_dimension_test_map(titer_table, dimensions_to_test, test_proportion, minimum_column_basis, fixed_column_bases, ag_reactivity_adjustments, num_optimizations, options));
    return rcpp_result_gen;
END_RCPP
}
// ac_errorline_data
ErrorLineData ac_errorline_data(const AcMap& map);
RcppExport SEXP _Racmacs_ac_errorline_data(SEXP mapSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcMap& >::type map(mapSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_errorline_data(map));
    return rcpp_result_gen;
END_RCPP
}
// ac_hemi_test
AcOptimization ac_hemi_test(AcOptimization optimization, AcTiterTable titertable, double grid_spacing, double stress_lim, AcOptimizerOptions options, double dilution_stepsize);
RcppExport SEXP _Racmacs_ac_hemi_test(SEXP optimizationSEXP, SEXP titertableSEXP, SEXP grid_spacingSEXP, SEXP stress_limSEXP, SEXP optionsSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type optimization(optimizationSEXP);
    Rcpp::traits::input_parameter< AcTiterTable >::type titertable(titertableSEXP);
    Rcpp::traits::input_parameter< double >::type grid_spacing(grid_spacingSEXP);
    Rcpp::traits::input_parameter< double >::type stress_lim(stress_limSEXP);
    Rcpp::traits::input_parameter< AcOptimizerOptions >::type options(optionsSEXP);
    Rcpp::traits::input_parameter< double >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_hemi_test(optimization, titertable, grid_spacing, stress_lim, options, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// ac_match_map_ags
arma::ivec ac_match_map_ags(AcMap const& map1, AcMap const& map2);
RcppExport SEXP _Racmacs_ac_match_map_ags(SEXP map1SEXP, SEXP map2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcMap const& >::type map1(map1SEXP);
    Rcpp::traits::input_parameter< AcMap const& >::type map2(map2SEXP);
    rcpp_result_gen = Rcpp::wrap(ac_match_map_ags(map1, map2));
    return rcpp_result_gen;
END_RCPP
}
// ac_match_map_sr
arma::ivec ac_match_map_sr(AcMap const& map1, AcMap const& map2);
RcppExport SEXP _Racmacs_ac_match_map_sr(SEXP map1SEXP, SEXP map2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcMap const& >::type map1(map1SEXP);
    Rcpp::traits::input_parameter< AcMap const& >::type map2(map2SEXP);
    rcpp_result_gen = Rcpp::wrap(ac_match_map_sr(map1, map2));
    return rcpp_result_gen;
END_RCPP
}
// ac_merge_titers
AcTiter ac_merge_titers(const std::vector<AcTiter>& titers, const AcMergeOptions& options);
RcppExport SEXP _Racmacs_ac_merge_titers(SEXP titersSEXP, SEXP optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const std::vector<AcTiter>& >::type titers(titersSEXP);
    Rcpp::traits::input_parameter< const AcMergeOptions& >::type options(optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_merge_titers(titers, options));
    return rcpp_result_gen;
END_RCPP
}
// ac_merge_titer_layers
AcTiterTable ac_merge_titer_layers(const std::vector<AcTiterTable>& titer_layers, const AcMergeOptions& options);
RcppExport SEXP _Racmacs_ac_merge_titer_layers(SEXP titer_layersSEXP, SEXP optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const std::vector<AcTiterTable>& >::type titer_layers(titer_layersSEXP);
    Rcpp::traits::input_parameter< const AcMergeOptions& >::type options(optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_merge_titer_layers(titer_layers, options));
    return rcpp_result_gen;
END_RCPP
}
// ac_merge_tables
AcMap ac_merge_tables(std::vector<AcMap> maps, const AcMergeOptions& merge_options);
RcppExport SEXP _Racmacs_ac_merge_tables(SEXP mapsSEXP, SEXP merge_optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<AcMap> >::type maps(mapsSEXP);
    Rcpp::traits::input_parameter< const AcMergeOptions& >::type merge_options(merge_optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_merge_tables(maps, merge_options));
    return rcpp_result_gen;
END_RCPP
}
// ac_merge_reoptimized
AcMap ac_merge_reoptimized(std::vector<AcMap> maps, int num_dims, int num_optimizations, std::string min_col_basis, AcOptimizerOptions optimizer_options, AcMergeOptions merge_options);
RcppExport SEXP _Racmacs_ac_merge_reoptimized(SEXP mapsSEXP, SEXP num_dimsSEXP, SEXP num_optimizationsSEXP, SEXP min_col_basisSEXP, SEXP optimizer_optionsSEXP, SEXP merge_optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<AcMap> >::type maps(mapsSEXP);
    Rcpp::traits::input_parameter< int >::type num_dims(num_dimsSEXP);
    Rcpp::traits::input_parameter< int >::type num_optimizations(num_optimizationsSEXP);
    Rcpp::traits::input_parameter< std::string >::type min_col_basis(min_col_basisSEXP);
    Rcpp::traits::input_parameter< AcOptimizerOptions >::type optimizer_options(optimizer_optionsSEXP);
    Rcpp::traits::input_parameter< AcMergeOptions >::type merge_options(merge_optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_merge_reoptimized(maps, num_dims, num_optimizations, min_col_basis, optimizer_options, merge_options));
    return rcpp_result_gen;
END_RCPP
}
// ac_merge_frozen_overlay
AcMap ac_merge_frozen_overlay(std::vector<AcMap> maps, const AcMergeOptions& merge_options);
RcppExport SEXP _Racmacs_ac_merge_frozen_overlay(SEXP mapsSEXP, SEXP merge_optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<AcMap> >::type maps(mapsSEXP);
    Rcpp::traits::input_parameter< const AcMergeOptions& >::type merge_options(merge_optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_merge_frozen_overlay(maps, merge_options));
    return rcpp_result_gen;
END_RCPP
}
// ac_merge_relaxed_overlay
AcMap ac_merge_relaxed_overlay(std::vector<AcMap> maps, AcOptimizerOptions optimizer_options, AcMergeOptions merge_options);
RcppExport SEXP _Racmacs_ac_merge_relaxed_overlay(SEXP mapsSEXP, SEXP optimizer_optionsSEXP, SEXP merge_optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<AcMap> >::type maps(mapsSEXP);
    Rcpp::traits::input_parameter< AcOptimizerOptions >::type optimizer_options(optimizer_optionsSEXP);
    Rcpp::traits::input_parameter< AcMergeOptions >::type merge_options(merge_optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_merge_relaxed_overlay(maps, optimizer_options, merge_options));
    return rcpp_result_gen;
END_RCPP
}
// ac_merge_frozen_merge
AcMap ac_merge_frozen_merge(std::vector<AcMap> maps, const AcOptimizerOptions& optimizer_options, const AcMergeOptions& merge_options);
RcppExport SEXP _Racmacs_ac_merge_frozen_merge(SEXP mapsSEXP, SEXP optimizer_optionsSEXP, SEXP merge_optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<AcMap> >::type maps(mapsSEXP);
    Rcpp::traits::input_parameter< const AcOptimizerOptions& >::type optimizer_options(optimizer_optionsSEXP);
    Rcpp::traits::input_parameter< const AcMergeOptions& >::type merge_options(merge_optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_merge_frozen_merge(maps, optimizer_options, merge_options));
    return rcpp_result_gen;
END_RCPP
}
// ac_merge_incremental
AcMap ac_merge_incremental(const std::vector<AcMap>& maps, int num_dims, int num_optimizations, std::string min_colbasis, const AcOptimizerOptions& optimizer_options, const AcMergeOptions& merge_options);
RcppExport SEXP _Racmacs_ac_merge_incremental(SEXP mapsSEXP, SEXP num_dimsSEXP, SEXP num_optimizationsSEXP, SEXP min_colbasisSEXP, SEXP optimizer_optionsSEXP, SEXP merge_optionsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const std::vector<AcMap>& >::type maps(mapsSEXP);
    Rcpp::traits::input_parameter< int >::type num_dims(num_dimsSEXP);
    Rcpp::traits::input_parameter< int >::type num_optimizations(num_optimizationsSEXP);
    Rcpp::traits::input_parameter< std::string >::type min_colbasis(min_colbasisSEXP);
    Rcpp::traits::input_parameter< const AcOptimizerOptions& >::type optimizer_options(optimizer_optionsSEXP);
    Rcpp::traits::input_parameter< const AcMergeOptions& >::type merge_options(merge_optionsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_merge_incremental(maps, num_dims, num_optimizations, min_colbasis, optimizer_options, merge_options));
    return rcpp_result_gen;
END_RCPP
}
// ac_titer_merge_type
int ac_titer_merge_type(const std::vector<AcTiter>& titers);
RcppExport SEXP _Racmacs_ac_titer_merge_type(SEXP titersSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const std::vector<AcTiter>& >::type titers(titersSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_titer_merge_type(titers));
    return rcpp_result_gen;
END_RCPP
}
// ac_titer_layer_merge_types
arma::imat ac_titer_layer_merge_types(const std::vector<AcTiterTable>& titer_layers);
RcppExport SEXP _Racmacs_ac_titer_layer_merge_types(SEXP titer_layersSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const std::vector<AcTiterTable>& >::type titer_layers(titer_layersSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_titer_layer_merge_types(titer_layers));
    return rcpp_result_gen;
END_RCPP
}
// ac_titer_layer_sd
arma::mat ac_titer_layer_sd(const std::vector<AcTiterTable>& titer_layers, const double dilution_stepsize);
RcppExport SEXP _Racmacs_ac_titer_layer_sd(SEXP titer_layersSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const std::vector<AcTiterTable>& >::type titer_layers(titer_layersSEXP);
    Rcpp::traits::input_parameter< const double >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_titer_layer_sd(titer_layers, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// ac_move_trapped_points
AcOptimization ac_move_trapped_points(AcOptimization optimization, AcTiterTable titertable, double grid_spacing, AcOptimizerOptions options, int max_iterations, double dilution_stepsize);
RcppExport SEXP _Racmacs_ac_move_trapped_points(SEXP optimizationSEXP, SEXP titertableSEXP, SEXP grid_spacingSEXP, SEXP optionsSEXP, SEXP max_iterationsSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcOptimization >::type optimization(optimizationSEXP);
    Rcpp::traits::input_parameter< AcTiterTable >::type titertable(titertableSEXP);
    Rcpp::traits::input_parameter< double >::type grid_spacing(grid_spacingSEXP);
    Rcpp::traits::input_parameter< AcOptimizerOptions >::type options(optionsSEXP);
    Rcpp::traits::input_parameter< int >::type max_iterations(max_iterationsSEXP);
    Rcpp::traits::input_parameter< double >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_move_trapped_points(optimization, titertable, grid_spacing, options, max_iterations, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// ac_coords_stress
double ac_coords_stress(const AcTiterTable& titers, const std::string& min_colbasis, const arma::vec& fixed_colbases, const arma::vec& ag_reactivity_adjustments, arma::mat& ag_coords, arma::mat& sr_coords, double dilution_stepsize);
RcppExport SEXP _Racmacs_ac_coords_stress(SEXP titersSEXP, SEXP min_colbasisSEXP, SEXP fixed_colbasesSEXP, SEXP ag_reactivity_adjustmentsSEXP, SEXP ag_coordsSEXP, SEXP sr_coordsSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcTiterTable& >::type titers(titersSEXP);
    Rcpp::traits::input_parameter< const std::string& >::type min_colbasis(min_colbasisSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type fixed_colbases(fixed_colbasesSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type ag_reactivity_adjustments(ag_reactivity_adjustmentsSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type ag_coords(ag_coordsSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type sr_coords(sr_coordsSEXP);
    Rcpp::traits::input_parameter< double >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_coords_stress(titers, min_colbasis, fixed_colbases, ag_reactivity_adjustments, ag_coords, sr_coords, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// ac_point_stresses
arma::mat ac_point_stresses(AcTiterTable titer_table, std::string min_colbasis, arma::vec fixed_colbases, arma::vec ag_reactivity_adjustments, arma::mat map_dists, double dilution_stepsize);
RcppExport SEXP _Racmacs_ac_point_stresses(SEXP titer_tableSEXP, SEXP min_colbasisSEXP, SEXP fixed_colbasesSEXP, SEXP ag_reactivity_adjustmentsSEXP, SEXP map_distsSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcTiterTable >::type titer_table(titer_tableSEXP);
    Rcpp::traits::input_parameter< std::string >::type min_colbasis(min_colbasisSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type fixed_colbases(fixed_colbasesSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type ag_reactivity_adjustments(ag_reactivity_adjustmentsSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type map_dists(map_distsSEXP);
    Rcpp::traits::input_parameter< double >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_point_stresses(titer_table, min_colbasis, fixed_colbases, ag_reactivity_adjustments, map_dists, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// ac_point_residuals
arma::mat ac_point_residuals(const AcMap& map, const arma::uword& optimization_number);
RcppExport SEXP _Racmacs_ac_point_residuals(SEXP mapSEXP, SEXP optimization_numberSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcMap& >::type map(mapSEXP);
    Rcpp::traits::input_parameter< const arma::uword& >::type optimization_number(optimization_numberSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_point_residuals(map, optimization_number));
    return rcpp_result_gen;
END_RCPP
}
// ac_relax_coords
double ac_relax_coords(const arma::mat& tabledist_matrix, const arma::imat& titertype_matrix, arma::mat& ag_coords, arma::mat& sr_coords, const AcOptimizerOptions& options, const arma::uvec& fixed_antigens, const arma::uvec& fixed_sera, const arma::mat& titer_weights, const double& dilution_stepsize);
RcppExport SEXP _Racmacs_ac_relax_coords(SEXP tabledist_matrixSEXP, SEXP titertype_matrixSEXP, SEXP ag_coordsSEXP, SEXP sr_coordsSEXP, SEXP optionsSEXP, SEXP fixed_antigensSEXP, SEXP fixed_seraSEXP, SEXP titer_weightsSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type tabledist_matrix(tabledist_matrixSEXP);
    Rcpp::traits::input_parameter< const arma::imat& >::type titertype_matrix(titertype_matrixSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type ag_coords(ag_coordsSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type sr_coords(sr_coordsSEXP);
    Rcpp::traits::input_parameter< const AcOptimizerOptions& >::type options(optionsSEXP);
    Rcpp::traits::input_parameter< const arma::uvec& >::type fixed_antigens(fixed_antigensSEXP);
    Rcpp::traits::input_parameter< const arma::uvec& >::type fixed_sera(fixed_seraSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type titer_weights(titer_weightsSEXP);
    Rcpp::traits::input_parameter< const double& >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_relax_coords(tabledist_matrix, titertype_matrix, ag_coords, sr_coords, options, fixed_antigens, fixed_sera, titer_weights, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// ac_relax_coords_with_colbases
Rcpp::List ac_relax_coords_with_colbases(const arma::mat& logtiter_matrix, const arma::imat& titertype_matrix, arma::mat& ag_coords, arma::mat& sr_coords, arma::vec& colbases, const AcOptimizerOptions& options, const arma::uvec& fixed_antigens, const arma::uvec& fixed_sera, const arma::mat& titer_weights, const double& dilution_stepsize);
RcppExport SEXP _Racmacs_ac_relax_coords_with_colbases(SEXP logtiter_matrixSEXP, SEXP titertype_matrixSEXP, SEXP ag_coordsSEXP, SEXP sr_coordsSEXP, SEXP colbasesSEXP, SEXP optionsSEXP, SEXP fixed_antigensSEXP, SEXP fixed_seraSEXP, SEXP titer_weightsSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type logtiter_matrix(logtiter_matrixSEXP);
    Rcpp::traits::input_parameter< const arma::imat& >::type titertype_matrix(titertype_matrixSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type ag_coords(ag_coordsSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type sr_coords(sr_coordsSEXP);
    Rcpp::traits::input_parameter< arma::vec& >::type colbases(colbasesSEXP);
    Rcpp::traits::input_parameter< const AcOptimizerOptions& >::type options(optionsSEXP);
    Rcpp::traits::input_parameter< const arma::uvec& >::type fixed_antigens(fixed_antigensSEXP);
    Rcpp::traits::input_parameter< const arma::uvec& >::type fixed_sera(fixed_seraSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type titer_weights(titer_weightsSEXP);
    Rcpp::traits::input_parameter< const double& >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_relax_coords_with_colbases(logtiter_matrix, titertype_matrix, ag_coords, sr_coords, colbases, options, fixed_antigens, fixed_sera, titer_weights, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// ac_runOptimizations
std::vector<AcOptimization> ac_runOptimizations(const AcTiterTable& titertable, const std::string& minimum_col_basis, const arma::vec& fixed_colbases, const arma::vec& ag_reactivity_adjustments, const arma::uword& num_dims, const arma::uword& num_optimizations, const AcOptimizerOptions& options, const arma::mat& titer_weights, const double& dilution_stepsize);
RcppExport SEXP _Racmacs_ac_runOptimizations(SEXP titertableSEXP, SEXP minimum_col_basisSEXP, SEXP fixed_colbasesSEXP, SEXP ag_reactivity_adjustmentsSEXP, SEXP num_dimsSEXP, SEXP num_optimizationsSEXP, SEXP optionsSEXP, SEXP titer_weightsSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcTiterTable& >::type titertable(titertableSEXP);
    Rcpp::traits::input_parameter< const std::string& >::type minimum_col_basis(minimum_col_basisSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type fixed_colbases(fixed_colbasesSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type ag_reactivity_adjustments(ag_reactivity_adjustmentsSEXP);
    Rcpp::traits::input_parameter< const arma::uword& >::type num_dims(num_dimsSEXP);
    Rcpp::traits::input_parameter< const arma::uword& >::type num_optimizations(num_optimizationsSEXP);
    Rcpp::traits::input_parameter< const AcOptimizerOptions& >::type options(optionsSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type titer_weights(titer_weightsSEXP);
    Rcpp::traits::input_parameter< const double& >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_runOptimizations(titertable, minimum_col_basis, fixed_colbases, ag_reactivity_adjustments, num_dims, num_optimizations, options, titer_weights, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// ac_reactivity_adjustment_stress
double ac_reactivity_adjustment_stress(const arma::vec& par, const arma::vec& fixed_ag_reactivities, const std::string& minimum_column_basis, const arma::vec& fixed_column_bases, const AcTiterTable& titertable, arma::mat ag_coords, arma::mat sr_coords, AcOptimizerOptions& options, const arma::uvec& fixed_antigens, const arma::uvec& fixed_sera, const arma::mat& titer_weights, const double& reactivity_stress_weighting, const bool reoptimize, const arma::uword num_optimizations, const double& dilution_stepsize);
RcppExport SEXP _Racmacs_ac_reactivity_adjustment_stress(SEXP parSEXP, SEXP fixed_ag_reactivitiesSEXP, SEXP minimum_column_basisSEXP, SEXP fixed_column_basesSEXP, SEXP titertableSEXP, SEXP ag_coordsSEXP, SEXP sr_coordsSEXP, SEXP optionsSEXP, SEXP fixed_antigensSEXP, SEXP fixed_seraSEXP, SEXP titer_weightsSEXP, SEXP reactivity_stress_weightingSEXP, SEXP reoptimizeSEXP, SEXP num_optimizationsSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type par(parSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type fixed_ag_reactivities(fixed_ag_reactivitiesSEXP);
    Rcpp::traits::input_parameter< const std::string& >::type minimum_column_basis(minimum_column_basisSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type fixed_column_bases(fixed_column_basesSEXP);
    Rcpp::traits::input_parameter< const AcTiterTable& >::type titertable(titertableSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type ag_coords(ag_coordsSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type sr_coords(sr_coordsSEXP);
    Rcpp::traits::input_parameter< AcOptimizerOptions& >::type options(optionsSEXP);
    Rcpp::traits::input_parameter< const arma::uvec& >::type fixed_antigens(fixed_antigensSEXP);
    Rcpp::traits::input_parameter< const arma::uvec& >::type fixed_sera(fixed_seraSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type titer_weights(titer_weightsSEXP);
    Rcpp::traits::input_parameter< const double& >::type reactivity_stress_weighting(reactivity_stress_weightingSEXP);
    Rcpp::traits::input_parameter< const bool >::type reoptimize(reoptimizeSEXP);
    Rcpp::traits::input_parameter< const arma::uword >::type num_optimizations(num_optimizationsSEXP);
    Rcpp::traits::input_parameter< const double& >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_reactivity_adjustment_stress(par, fixed_ag_reactivities, minimum_column_basis, fixed_column_bases, titertable, ag_coords, sr_coords, options, fixed_antigens, fixed_sera, titer_weights, reactivity_stress_weighting, reoptimize, num_optimizations, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// ac_stress_blob_grid
StressBlobGrid ac_stress_blob_grid(arma::vec testcoords, arma::mat coords, arma::vec tabledists, arma::ivec titertypes, double stress_lim, double grid_spacing, double dilution_stepsize);
RcppExport SEXP _Racmacs_ac_stress_blob_grid(SEXP testcoordsSEXP, SEXP coordsSEXP, SEXP tabledistsSEXP, SEXP titertypesSEXP, SEXP stress_limSEXP, SEXP grid_spacingSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::vec >::type testcoords(testcoordsSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type coords(coordsSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type tabledists(tabledistsSEXP);
    Rcpp::traits::input_parameter< arma::ivec >::type titertypes(titertypesSEXP);
    Rcpp::traits::input_parameter< double >::type stress_lim(stress_limSEXP);
    Rcpp::traits::input_parameter< double >::type grid_spacing(grid_spacingSEXP);
    Rcpp::traits::input_parameter< double >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_stress_blob_grid(testcoords, coords, tabledists, titertypes, stress_lim, grid_spacing, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// numeric_titers
arma::vec numeric_titers(std::vector<AcTiter> titers);
RcppExport SEXP _Racmacs_numeric_titers(SEXP titersSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<AcTiter> >::type titers(titersSEXP);
    rcpp_result_gen = Rcpp::wrap(numeric_titers(titers));
    return rcpp_result_gen;
END_RCPP
}
// log_titers
arma::vec log_titers(std::vector<AcTiter> titers, double dilution_stepsize);
RcppExport SEXP _Racmacs_log_titers(SEXP titersSEXP, SEXP dilution_stepsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<AcTiter> >::type titers(titersSEXP);
    Rcpp::traits::input_parameter< double >::type dilution_stepsize(dilution_stepsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(log_titers(titers, dilution_stepsize));
    return rcpp_result_gen;
END_RCPP
}
// titer_types_int
arma::ivec titer_types_int(std::vector<AcTiter> titers);
RcppExport SEXP _Racmacs_titer_types_int(SEXP titersSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<AcTiter> >::type titers(titersSEXP);
    rcpp_result_gen = Rcpp::wrap(titer_types_int(titers));
    return rcpp_result_gen;
END_RCPP
}
// make_titers
std::vector<AcTiter> make_titers(arma::vec numeric_titers, arma::ivec titer_types_int);
RcppExport SEXP _Racmacs_make_titers(SEXP numeric_titersSEXP, SEXP titer_types_intSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::vec >::type numeric_titers(numeric_titersSEXP);
    Rcpp::traits::input_parameter< arma::ivec >::type titer_types_int(titer_types_intSEXP);
    rcpp_result_gen = Rcpp::wrap(make_titers(numeric_titers, titer_types_int));
    return rcpp_result_gen;
END_RCPP
}
// reduce_matrix_dimensions
arma::mat reduce_matrix_dimensions(arma::mat m, int dim);
RcppExport SEXP _Racmacs_reduce_matrix_dimensions(SEXP mSEXP, SEXP dimSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::mat >::type m(mSEXP);
    Rcpp::traits::input_parameter< int >::type dim(dimSEXP);
    rcpp_result_gen = Rcpp::wrap(reduce_matrix_dimensions(m, dim));
    return rcpp_result_gen;
END_RCPP
}
// json_to_acmap
AcMap json_to_acmap(std::string json);
RcppExport SEXP _Racmacs_json_to_acmap(SEXP jsonSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type json(jsonSEXP);
    rcpp_result_gen = Rcpp::wrap(json_to_acmap(json));
    return rcpp_result_gen;
END_RCPP
}
// acmap_to_json
std::string acmap_to_json(AcMap map, std::string version, bool pretty, bool round_titers);
RcppExport SEXP _Racmacs_acmap_to_json(SEXP mapSEXP, SEXP versionSEXP, SEXP prettySEXP, SEXP round_titersSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< AcMap >::type map(mapSEXP);
    Rcpp::traits::input_parameter< std::string >::type version(versionSEXP);
    Rcpp::traits::input_parameter< bool >::type pretty(prettySEXP);
    Rcpp::traits::input_parameter< bool >::type round_titers(round_titersSEXP);
    rcpp_result_gen = Rcpp::wrap(acmap_to_json(map, version, pretty, round_titers));
    return rcpp_result_gen;
END_RCPP
}
// ac_procrustes
Procrustes ac_procrustes(arma::mat X, arma::mat Xstar, bool translation, bool dilation);
RcppExport SEXP _Racmacs_ac_procrustes(SEXP XSEXP, SEXP XstarSEXP, SEXP translationSEXP, SEXP dilationSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type Xstar(XstarSEXP);
    Rcpp::traits::input_parameter< bool >::type translation(translationSEXP);
    Rcpp::traits::input_parameter< bool >::type dilation(dilationSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_procrustes(X, Xstar, translation, dilation));
    return rcpp_result_gen;
END_RCPP
}
// ac_align_coords
arma::mat ac_align_coords(arma::mat source, arma::mat target, bool translation, bool dilation);
RcppExport SEXP _Racmacs_ac_align_coords(SEXP sourceSEXP, SEXP targetSEXP, SEXP translationSEXP, SEXP dilationSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::mat >::type source(sourceSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type target(targetSEXP);
    Rcpp::traits::input_parameter< bool >::type translation(translationSEXP);
    Rcpp::traits::input_parameter< bool >::type dilation(dilationSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_align_coords(source, target, translation, dilation));
    return rcpp_result_gen;
END_RCPP
}
// ac_procrustes_map_coords
AcCoords ac_procrustes_map_coords(const AcMap& base_map, AcMap procrustes_map, int base_map_optimization_number, int procrustes_map_optimization_number, bool translation, bool scaling);
RcppExport SEXP _Racmacs_ac_procrustes_map_coords(SEXP base_mapSEXP, SEXP procrustes_mapSEXP, SEXP base_map_optimization_numberSEXP, SEXP procrustes_map_optimization_numberSEXP, SEXP translationSEXP, SEXP scalingSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcMap& >::type base_map(base_mapSEXP);
    Rcpp::traits::input_parameter< AcMap >::type procrustes_map(procrustes_mapSEXP);
    Rcpp::traits::input_parameter< int >::type base_map_optimization_number(base_map_optimization_numberSEXP);
    Rcpp::traits::input_parameter< int >::type procrustes_map_optimization_number(procrustes_map_optimization_numberSEXP);
    Rcpp::traits::input_parameter< bool >::type translation(translationSEXP);
    Rcpp::traits::input_parameter< bool >::type scaling(scalingSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_procrustes_map_coords(base_map, procrustes_map, base_map_optimization_number, procrustes_map_optimization_number, translation, scaling));
    return rcpp_result_gen;
END_RCPP
}
// ac_procrustes_map_data
ProcrustesData ac_procrustes_map_data(const AcOptimization& optimization, AcCoords pc_coords);
RcppExport SEXP _Racmacs_ac_procrustes_map_data(SEXP optimizationSEXP, SEXP pc_coordsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const AcOptimization& >::type optimization(optimizationSEXP);
    Rcpp::traits::input_parameter< AcCoords >::type pc_coords(pc_coordsSEXP);
    rcpp_result_gen = Rcpp::wrap(ac_procrustes_map_data(optimization, pc_coords));
    return rcpp_result_gen;
END_RCPP
}
// ac_coord_dists
arma::vec ac_coord_dists(arma::mat coords1, arma::mat coords2);
RcppExport SEXP _Racmacs_ac_coord_dists(SEXP coords1SEXP, SEXP coords2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::mat >::type coords1(coords1SEXP);
    Rcpp::traits::input_parameter< arma::mat >::type coords2(coords2SEXP);
    rcpp_result_gen = Rcpp::wrap(ac_coord_dists(coords1, coords2));
    return rcpp_result_gen;
END_RCPP
}
// parallel_mode
bool parallel_mode();
RcppExport SEXP _Racmacs_parallel_mode() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    rcpp_result_gen = Rcpp::wrap(parallel_mode());
    return rcpp_result_gen;
END_RCPP
}
// ac_coordDistMatrix
arma::mat ac_coordDistMatrix(arma::mat coords1, arma::mat coords2);
RcppExport SEXP _Racmacs_ac_coordDistMatrix(SEXP coords1SEXP, SEXP coords2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::mat >::type coords1(coords1SEXP);
    Rcpp::traits::input_parameter< arma::mat >::type coords2(coords2SEXP);
    rcpp_result_gen = Rcpp::wrap(ac_coordDistMatrix(coords1, coords2));
    return rcpp_result_gen;
END_RCPP
}
// mesh_volume
double mesh_volume(const arma::umat& faces, const arma::mat& vertices);
RcppExport SEXP _Racmacs_mesh_volume(SEXP facesSEXP, SEXP verticesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::umat& >::type faces(facesSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type vertices(verticesSEXP);
    rcpp_result_gen = Rcpp::wrap(mesh_volume(faces, vertices));
    return rcpp_result_gen;
END_RCPP
}
// polygon_area
double polygon_area(const arma::vec& x, const arma::vec& y);
RcppExport SEXP _Racmacs_polygon_area(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type y(ySEXP);
    rcpp_result_gen = Rcpp::wrap(polygon_area(x, y));
    return rcpp_result_gen;
END_RCPP
}
// interp2d
arma::vec interp2d(arma::mat x, arma::vec gpoints1, arma::vec gpoints2, arma::mat f);
RcppExport SEXP _Racmacs_interp2d(SEXP xSEXP, SEXP gpoints1SEXP, SEXP gpoints2SEXP, SEXP fSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::mat >::type x(xSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type gpoints1(gpoints1SEXP);
    Rcpp::traits::input_parameter< arma::vec >::type gpoints2(gpoints2SEXP);
    Rcpp::traits::input_parameter< arma::mat >::type f(fSEXP);
    rcpp_result_gen = Rcpp::wrap(interp2d(x, gpoints1, gpoints2, f));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_Racmacs_ac_ag_names", (DL_FUNC) &_Racmacs_ac_ag_names, 1},
    {"_Racmacs_ac_get_ag_coords", (DL_FUNC) &_Racmacs_ac_get_ag_coords, 1},
    {"_Racmacs_ac_get_sr_coords", (DL_FUNC) &_Racmacs_ac_get_sr_coords, 1},
    {"_Racmacs_ac_set_ag_coords", (DL_FUNC) &_Racmacs_ac_set_ag_coords, 2},
    {"_Racmacs_ac_set_sr_coords", (DL_FUNC) &_Racmacs_ac_set_sr_coords, 2},
    {"_Racmacs_ac_align_optimization", (DL_FUNC) &_Racmacs_ac_align_optimization, 2},
    {"_Racmacs_ac_align_map", (DL_FUNC) &_Racmacs_ac_align_map, 4},
    {"_Racmacs_ac_align_optimizations", (DL_FUNC) &_Racmacs_ac_align_optimizations, 1},
    {"_Racmacs_ac_subset_map", (DL_FUNC) &_Racmacs_ac_subset_map, 3},
    {"_Racmacs_ac_table_colbases", (DL_FUNC) &_Racmacs_ac_table_colbases, 4},
    {"_Racmacs_ac_numeric_table_distances", (DL_FUNC) &_Racmacs_ac_numeric_table_distances, 4},
    {"_Racmacs_ac_newOptimization", (DL_FUNC) &_Racmacs_ac_newOptimization, 3},
    {"_Racmacs_ac_relaxOptimization", (DL_FUNC) &_Racmacs_ac_relaxOptimization, 7},
    {"_Racmacs_ac_optimize_map", (DL_FUNC) &_Racmacs_ac_optimize_map, 8},
    {"_Racmacs_ac_new_antigen", (DL_FUNC) &_Racmacs_ac_new_antigen, 1},
    {"_Racmacs_ac_ag_get_id", (DL_FUNC) &_Racmacs_ac_ag_get_id, 1},
    {"_Racmacs_ac_ag_get_date", (DL_FUNC) &_Racmacs_ac_ag_get_date, 1},
    {"_Racmacs_ac_ag_get_reference", (DL_FUNC) &_Racmacs_ac_ag_get_reference, 1},
    {"_Racmacs_ac_ag_get_passage", (DL_FUNC) &_Racmacs_ac_ag_get_passage, 1},
    {"_Racmacs_ac_ag_get_clade", (DL_FUNC) &_Racmacs_ac_ag_get_clade, 1},
    {"_Racmacs_ac_ag_get_annotations", (DL_FUNC) &_Racmacs_ac_ag_get_annotations, 1},
    {"_Racmacs_ac_ag_get_labids", (DL_FUNC) &_Racmacs_ac_ag_get_labids, 1},
    {"_Racmacs_ac_ag_get_name", (DL_FUNC) &_Racmacs_ac_ag_get_name, 1},
    {"_Racmacs_ac_ag_get_extra", (DL_FUNC) &_Racmacs_ac_ag_get_extra, 1},
    {"_Racmacs_ac_ag_get_lineage", (DL_FUNC) &_Racmacs_ac_ag_get_lineage, 1},
    {"_Racmacs_ac_ag_get_reassortant", (DL_FUNC) &_Racmacs_ac_ag_get_reassortant, 1},
    {"_Racmacs_ac_ag_get_strings", (DL_FUNC) &_Racmacs_ac_ag_get_strings, 1},
    {"_Racmacs_ac_ag_get_continent", (DL_FUNC) &_Racmacs_ac_ag_get_continent, 1},
    {"_Racmacs_ac_ag_get_match_id", (DL_FUNC) &_Racmacs_ac_ag_get_match_id, 1},
    {"_Racmacs_ac_ag_get_group", (DL_FUNC) &_Racmacs_ac_ag_get_group, 1},
    {"_Racmacs_ac_ag_get_group_levels", (DL_FUNC) &_Racmacs_ac_ag_get_group_levels, 1},
    {"_Racmacs_ac_ag_set_id", (DL_FUNC) &_Racmacs_ac_ag_set_id, 2},
    {"_Racmacs_ac_ag_set_date", (DL_FUNC) &_Racmacs_ac_ag_set_date, 2},
    {"_Racmacs_ac_ag_set_reference", (DL_FUNC) &_Racmacs_ac_ag_set_reference, 2},
    {"_Racmacs_ac_ag_set_passage", (DL_FUNC) &_Racmacs_ac_ag_set_passage, 2},
    {"_Racmacs_ac_ag_set_clade", (DL_FUNC) &_Racmacs_ac_ag_set_clade, 2},
    {"_Racmacs_ac_ag_set_annotations", (DL_FUNC) &_Racmacs_ac_ag_set_annotations, 2},
    {"_Racmacs_ac_ag_set_labids", (DL_FUNC) &_Racmacs_ac_ag_set_labids, 2},
    {"_Racmacs_ac_ag_set_name", (DL_FUNC) &_Racmacs_ac_ag_set_name, 2},
    {"_Racmacs_ac_ag_set_extra", (DL_FUNC) &_Racmacs_ac_ag_set_extra, 2},
    {"_Racmacs_ac_ag_set_lineage", (DL_FUNC) &_Racmacs_ac_ag_set_lineage, 2},
    {"_Racmacs_ac_ag_set_reassortant", (DL_FUNC) &_Racmacs_ac_ag_set_reassortant, 2},
    {"_Racmacs_ac_ag_set_strings", (DL_FUNC) &_Racmacs_ac_ag_set_strings, 2},
    {"_Racmacs_ac_ag_set_continent", (DL_FUNC) &_Racmacs_ac_ag_set_continent, 2},
    {"_Racmacs_ac_ag_set_group", (DL_FUNC) &_Racmacs_ac_ag_set_group, 2},
    {"_Racmacs_ac_ag_set_group_levels", (DL_FUNC) &_Racmacs_ac_ag_set_group_levels, 2},
    {"_Racmacs_ac_opt_get_ag_base_coords", (DL_FUNC) &_Racmacs_ac_opt_get_ag_base_coords, 1},
    {"_Racmacs_ac_opt_get_sr_base_coords", (DL_FUNC) &_Racmacs_ac_opt_get_sr_base_coords, 1},
    {"_Racmacs_ac_opt_get_transformation", (DL_FUNC) &_Racmacs_ac_opt_get_transformation, 1},
    {"_Racmacs_ac_opt_get_translation", (DL_FUNC) &_Racmacs_ac_opt_get_translation, 1},
    {"_Racmacs_ac_opt_get_mincolbasis", (DL_FUNC) &_Racmacs_ac_opt_get_mincolbasis, 1},
    {"_Racmacs_ac_opt_get_fixedcolbases", (DL_FUNC) &_Racmacs_ac_opt_get_fixedcolbases, 1},
    {"_Racmacs_ac_opt_get_agreactivityadjustments", (DL_FUNC) &_Racmacs_ac_opt_get_agreactivityadjustments, 1},
    {"_Racmacs_ac_opt_get_stress", (DL_FUNC) &_Racmacs_ac_opt_get_stress, 1},
    {"_Racmacs_ac_opt_get_dimensions", (DL_FUNC) &_Racmacs_ac_opt_get_dimensions, 1},
    {"_Racmacs_ac_opt_get_comment", (DL_FUNC) &_Racmacs_ac_opt_get_comment, 1},
    {"_Racmacs_ac_opt_set_ag_base_coords", (DL_FUNC) &_Racmacs_ac_opt_set_ag_base_coords, 2},
    {"_Racmacs_ac_opt_set_sr_base_coords", (DL_FUNC) &_Racmacs_ac_opt_set_sr_base_coords, 2},
    {"_Racmacs_ac_opt_set_transformation", (DL_FUNC) &_Racmacs_ac_opt_set_transformation, 2},
    {"_Racmacs_ac_opt_set_translation", (DL_FUNC) &_Racmacs_ac_opt_set_translation, 2},
    {"_Racmacs_ac_opt_set_mincolbasis", (DL_FUNC) &_Racmacs_ac_opt_set_mincolbasis, 2},
    {"_Racmacs_ac_opt_set_fixedcolbases", (DL_FUNC) &_Racmacs_ac_opt_set_fixedcolbases, 2},
    {"_Racmacs_ac_opt_set_agreactivityadjustments", (DL_FUNC) &_Racmacs_ac_opt_set_agreactivityadjustments, 2},
    {"_Racmacs_ac_opt_set_stress", (DL_FUNC) &_Racmacs_ac_opt_set_stress, 2},
    {"_Racmacs_ac_opt_set_comment", (DL_FUNC) &_Racmacs_ac_opt_set_comment, 2},
    {"_Racmacs_ac_rotate_optimization", (DL_FUNC) &_Racmacs_ac_rotate_optimization, 3},
    {"_Racmacs_ac_reflect_optimization", (DL_FUNC) &_Racmacs_ac_reflect_optimization, 2},
    {"_Racmacs_ac_translate_optimization", (DL_FUNC) &_Racmacs_ac_translate_optimization, 2},
    {"_Racmacs_ac_apply_optimization_transform", (DL_FUNC) &_Racmacs_ac_apply_optimization_transform, 2},
    {"_Racmacs_ac_plotspec_get_shown", (DL_FUNC) &_Racmacs_ac_plotspec_get_shown, 1},
    {"_Racmacs_ac_plotspec_get_size", (DL_FUNC) &_Racmacs_ac_plotspec_get_size, 1},
    {"_Racmacs_ac_plotspec_get_fill", (DL_FUNC) &_Racmacs_ac_plotspec_get_fill, 1},
    {"_Racmacs_ac_plotspec_get_outline", (DL_FUNC) &_Racmacs_ac_plotspec_get_outline, 1},
    {"_Racmacs_ac_plotspec_get_outline_width", (DL_FUNC) &_Racmacs_ac_plotspec_get_outline_width, 1},
    {"_Racmacs_ac_plotspec_get_rotation", (DL_FUNC) &_Racmacs_ac_plotspec_get_rotation, 1},
    {"_Racmacs_ac_plotspec_get_aspect", (DL_FUNC) &_Racmacs_ac_plotspec_get_aspect, 1},
    {"_Racmacs_ac_plotspec_get_shape", (DL_FUNC) &_Racmacs_ac_plotspec_get_shape, 1},
    {"_Racmacs_ac_plotspec_set_shown", (DL_FUNC) &_Racmacs_ac_plotspec_set_shown, 2},
    {"_Racmacs_ac_plotspec_set_size", (DL_FUNC) &_Racmacs_ac_plotspec_set_size, 2},
    {"_Racmacs_ac_plotspec_set_fill", (DL_FUNC) &_Racmacs_ac_plotspec_set_fill, 2},
    {"_Racmacs_ac_plotspec_set_outline", (DL_FUNC) &_Racmacs_ac_plotspec_set_outline, 2},
    {"_Racmacs_ac_plotspec_set_outline_width", (DL_FUNC) &_Racmacs_ac_plotspec_set_outline_width, 2},
    {"_Racmacs_ac_plotspec_set_rotation", (DL_FUNC) &_Racmacs_ac_plotspec_set_rotation, 2},
    {"_Racmacs_ac_plotspec_set_aspect", (DL_FUNC) &_Racmacs_ac_plotspec_set_aspect, 2},
    {"_Racmacs_ac_plotspec_set_shape", (DL_FUNC) &_Racmacs_ac_plotspec_set_shape, 2},
    {"_Racmacs_ac_new_serum", (DL_FUNC) &_Racmacs_ac_new_serum, 1},
    {"_Racmacs_ac_sr_get_id", (DL_FUNC) &_Racmacs_ac_sr_get_id, 1},
    {"_Racmacs_ac_sr_get_date", (DL_FUNC) &_Racmacs_ac_sr_get_date, 1},
    {"_Racmacs_ac_sr_get_reference", (DL_FUNC) &_Racmacs_ac_sr_get_reference, 1},
    {"_Racmacs_ac_sr_get_passage", (DL_FUNC) &_Racmacs_ac_sr_get_passage, 1},
    {"_Racmacs_ac_sr_get_species", (DL_FUNC) &_Racmacs_ac_sr_get_species, 1},
    {"_Racmacs_ac_sr_get_clade", (DL_FUNC) &_Racmacs_ac_sr_get_clade, 1},
    {"_Racmacs_ac_sr_get_annotations", (DL_FUNC) &_Racmacs_ac_sr_get_annotations, 1},
    {"_Racmacs_ac_sr_get_name", (DL_FUNC) &_Racmacs_ac_sr_get_name, 1},
    {"_Racmacs_ac_sr_get_extra", (DL_FUNC) &_Racmacs_ac_sr_get_extra, 1},
    {"_Racmacs_ac_sr_get_lineage", (DL_FUNC) &_Racmacs_ac_sr_get_lineage, 1},
    {"_Racmacs_ac_sr_get_reassortant", (DL_FUNC) &_Racmacs_ac_sr_get_reassortant, 1},
    {"_Racmacs_ac_sr_get_strings", (DL_FUNC) &_Racmacs_ac_sr_get_strings, 1},
    {"_Racmacs_ac_sr_get_continent", (DL_FUNC) &_Racmacs_ac_sr_get_continent, 1},
    {"_Racmacs_ac_sr_get_match_id", (DL_FUNC) &_Racmacs_ac_sr_get_match_id, 1},
    {"_Racmacs_ac_sr_get_homologous_ags", (DL_FUNC) &_Racmacs_ac_sr_get_homologous_ags, 1},
    {"_Racmacs_ac_sr_get_group", (DL_FUNC) &_Racmacs_ac_sr_get_group, 1},
    {"_Racmacs_ac_sr_get_group_levels", (DL_FUNC) &_Racmacs_ac_sr_get_group_levels, 1},
    {"_Racmacs_ac_sr_set_id", (DL_FUNC) &_Racmacs_ac_sr_set_id, 2},
    {"_Racmacs_ac_sr_set_date", (DL_FUNC) &_Racmacs_ac_sr_set_date, 2},
    {"_Racmacs_ac_sr_set_reference", (DL_FUNC) &_Racmacs_ac_sr_set_reference, 2},
    {"_Racmacs_ac_sr_set_passage", (DL_FUNC) &_Racmacs_ac_sr_set_passage, 2},
    {"_Racmacs_ac_sr_set_species", (DL_FUNC) &_Racmacs_ac_sr_set_species, 2},
    {"_Racmacs_ac_sr_set_clade", (DL_FUNC) &_Racmacs_ac_sr_set_clade, 2},
    {"_Racmacs_ac_sr_set_annotations", (DL_FUNC) &_Racmacs_ac_sr_set_annotations, 2},
    {"_Racmacs_ac_sr_set_name", (DL_FUNC) &_Racmacs_ac_sr_set_name, 2},
    {"_Racmacs_ac_sr_set_extra", (DL_FUNC) &_Racmacs_ac_sr_set_extra, 2},
    {"_Racmacs_ac_sr_set_lineage", (DL_FUNC) &_Racmacs_ac_sr_set_lineage, 2},
    {"_Racmacs_ac_sr_set_reassortant", (DL_FUNC) &_Racmacs_ac_sr_set_reassortant, 2},
    {"_Racmacs_ac_sr_set_strings", (DL_FUNC) &_Racmacs_ac_sr_set_strings, 2},
    {"_Racmacs_ac_sr_set_continent", (DL_FUNC) &_Racmacs_ac_sr_set_continent, 2},
    {"_Racmacs_ac_sr_set_homologous_ags", (DL_FUNC) &_Racmacs_ac_sr_set_homologous_ags, 2},
    {"_Racmacs_ac_sr_set_group", (DL_FUNC) &_Racmacs_ac_sr_set_group, 2},
    {"_Racmacs_ac_sr_set_group_levels", (DL_FUNC) &_Racmacs_ac_sr_set_group_levels, 2},
    {"_Racmacs_ac_bootstrap_map", (DL_FUNC) &_Racmacs_ac_bootstrap_map, 13},
    {"_Racmacs_ac_dimension_test_map", (DL_FUNC) &_Racmacs_ac_dimension_test_map, 8},
    {"_Racmacs_ac_errorline_data", (DL_FUNC) &_Racmacs_ac_errorline_data, 1},
    {"_Racmacs_ac_hemi_test", (DL_FUNC) &_Racmacs_ac_hemi_test, 6},
    {"_Racmacs_ac_match_map_ags", (DL_FUNC) &_Racmacs_ac_match_map_ags, 2},
    {"_Racmacs_ac_match_map_sr", (DL_FUNC) &_Racmacs_ac_match_map_sr, 2},
    {"_Racmacs_ac_merge_titers", (DL_FUNC) &_Racmacs_ac_merge_titers, 2},
    {"_Racmacs_ac_merge_titer_layers", (DL_FUNC) &_Racmacs_ac_merge_titer_layers, 2},
    {"_Racmacs_ac_merge_tables", (DL_FUNC) &_Racmacs_ac_merge_tables, 2},
    {"_Racmacs_ac_merge_reoptimized", (DL_FUNC) &_Racmacs_ac_merge_reoptimized, 6},
    {"_Racmacs_ac_merge_frozen_overlay", (DL_FUNC) &_Racmacs_ac_merge_frozen_overlay, 2},
    {"_Racmacs_ac_merge_relaxed_overlay", (DL_FUNC) &_Racmacs_ac_merge_relaxed_overlay, 3},
    {"_Racmacs_ac_merge_frozen_merge", (DL_FUNC) &_Racmacs_ac_merge_frozen_merge, 3},
    {"_Racmacs_ac_merge_incremental", (DL_FUNC) &_Racmacs_ac_merge_incremental, 6},
    {"_Racmacs_ac_titer_merge_type", (DL_FUNC) &_Racmacs_ac_titer_merge_type, 1},
    {"_Racmacs_ac_titer_layer_merge_types", (DL_FUNC) &_Racmacs_ac_titer_layer_merge_types, 1},
    {"_Racmacs_ac_titer_layer_sd", (DL_FUNC) &_Racmacs_ac_titer_layer_sd, 2},
    {"_Racmacs_ac_move_trapped_points", (DL_FUNC) &_Racmacs_ac_move_trapped_points, 6},
    {"_Racmacs_ac_coords_stress", (DL_FUNC) &_Racmacs_ac_coords_stress, 7},
    {"_Racmacs_ac_point_stresses", (DL_FUNC) &_Racmacs_ac_point_stresses, 6},
    {"_Racmacs_ac_point_residuals", (DL_FUNC) &_Racmacs_ac_point_residuals, 2},
    {"_Racmacs_ac_relax_coords", (DL_FUNC) &_Racmacs_ac_relax_coords, 9},
    {"_Racmacs_ac_relax_coords_with_colbases", (DL_FUNC) &_Racmacs_ac_relax_coords_with_colbases, 10},
    {"_Racmacs_ac_runOptimizations", (DL_FUNC) &_Racmacs_ac_runOptimizations, 9},
    {"_Racmacs_ac_reactivity_adjustment_stress", (DL_FUNC) &_Racmacs_ac_reactivity_adjustment_stress, 15},
    {"_Racmacs_ac_stress_blob_grid", (DL_FUNC) &_Racmacs_ac_stress_blob_grid, 7},
    {"_Racmacs_numeric_titers", (DL_FUNC) &_Racmacs_numeric_titers, 1},
    {"_Racmacs_log_titers", (DL_FUNC) &_Racmacs_log_titers, 2},
    {"_Racmacs_titer_types_int", (DL_FUNC) &_Racmacs_titer_types_int, 1},
    {"_Racmacs_make_titers", (DL_FUNC) &_Racmacs_make_titers, 2},
    {"_Racmacs_reduce_matrix_dimensions", (DL_FUNC) &_Racmacs_reduce_matrix_dimensions, 2},
    {"_Racmacs_json_to_acmap", (DL_FUNC) &_Racmacs_json_to_acmap, 1},
    {"_Racmacs_acmap_to_json", (DL_FUNC) &_Racmacs_acmap_to_json, 4},
    {"_Racmacs_ac_procrustes", (DL_FUNC) &_Racmacs_ac_procrustes, 4},
    {"_Racmacs_ac_align_coords", (DL_FUNC) &_Racmacs_ac_align_coords, 4},
    {"_Racmacs_ac_procrustes_map_coords", (DL_FUNC) &_Racmacs_ac_procrustes_map_coords, 6},
    {"_Racmacs_ac_procrustes_map_data", (DL_FUNC) &_Racmacs_ac_procrustes_map_data, 2},
    {"_Racmacs_ac_coord_dists", (DL_FUNC) &_Racmacs_ac_coord_dists, 2},
    {"_Racmacs_parallel_mode", (DL_FUNC) &_Racmacs_parallel_mode, 0},
    {"_Racmacs_ac_coordDistMatrix", (DL_FUNC) &_Racmacs_ac_coordDistMatrix, 2},
    {"_Racmacs_mesh_volume", (DL_FUNC) &_Racmacs_mesh_volume, 2},
    {"_Racmacs_polygon_area", (DL_FUNC) &_Racmacs_polygon_area, 2},
    {"_Racmacs_interp2d", (DL_FUNC) &_Racmacs_interp2d, 4},
    {NULL, NULL, 0}
};

RcppExport void R_init_Racmacs(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}


# ================================================
# FILE: src/utils_error.cpp
# ================================================


#include <RcppArmadillo.h>

void ac_error(
    const char* msg
){

  Rf_error("%s", msg);

}

void ac_error(
    const std::string msg
){

  Rf_error("%s", msg.c_str());

}


# ================================================
# FILE: src/utils_error.h
# ================================================


#include <RcppArmadillo.h>

#ifndef Racmacs__utils_error__h
#define Racmacs__utils_error__h

void ac_error(
  const char* msg
);

void ac_error(
    const std::string msg
);

#endif


# ================================================
# FILE: src/utils_euc_dist.cpp
# ================================================


#include <RcppArmadillo.h>

// [[Rcpp::export]]
arma::mat ac_coordDistMatrix(
    arma::mat coords1,
    arma::mat coords2
){

  arma::uword nrows = coords1.n_rows;
  arma::uword ncols = coords2.n_rows;
  arma::uword ndims = coords1.n_cols;

  arma::mat distmat( coords1.n_rows, coords2.n_rows );
  for(arma::uword i=0; i<nrows; i++){
    for(arma::uword j=0; j<ncols; j++){
      double stress = 0;
      for(arma::uword k=0; k<ndims; k++){
        stress += std::pow(coords1(i,k) - coords2(j,k), 2);
      }
      distmat(i, j) = std::sqrt(stress);
    }
  }

  return distmat;

}


# ================================================
# FILE: src/utils_geometry.cpp
# ================================================


#include <RcppArmadillo.h>

double volume_of_tetrahedron(
    const arma::rowvec &p1,
    const arma::rowvec &p2,
    const arma::rowvec &p3
  ) {

  double v321 = p3[0]*p2[1]*p1[2];
  double v231 = p2[0]*p3[1]*p1[2];
  double v312 = p3[0]*p1[1]*p2[2];
  double v132 = p1[0]*p3[1]*p2[2];
  double v213 = p2[0]*p1[1]*p3[2];
  double v123 = p1[0]*p2[1]*p3[2];
  return (-v321 + v231 + v312 - v132 - v213 + v123) / 6;

}


// [[Rcpp::export]]
double mesh_volume(
    const arma::umat &faces,
    const arma::mat &vertices
  ) {

  double volume = 0;
  arma::rowvec v1;
  arma::rowvec v2;
  arma::rowvec v3;

  for (arma::uword n = 0; n < faces.n_rows; n++) {

    v1 = vertices.row(faces(n, 0));
    v2 = vertices.row(faces(n, 1));
    v3 = vertices.row(faces(n, 2));
    volume += volume_of_tetrahedron(v1, v2, v3);

  }

  return volume;

}


// [[Rcpp::export]]
double polygon_area(
    const arma::vec &x,
    const arma::vec &y
) {

  double area = 0;
  arma::uword i0;
  for (arma::uword i = 0; i < x.n_elem; i++) {

    // Get previous vertex
    i == 0 ? i0 = x.n_elem - 1 : i0 = i - 1;
    area += (-x[i0]*y[i] + x[i]*y[i0]) / 2;

  }

  return area;

}



# ================================================
# FILE: src/utils_interpolation.cpp
# ================================================

/*
 The interp2d function here is derived from the grid.interp.2d function in the "ks"
 package (https://cran.r-project.org/package=ks), with modifications from S.H.Wilks to
 make it compatible with the armadillo C++ library, and as such is release under the
 GPL-2 | GPL-3 licence as included with the original code version.
*/
//________________________________________________

#include <RcppArmadillo.h>

// [[Rcpp::export]]
arma::vec interp2d(
    arma::mat x,
    arma::vec gpoints1,
    arma::vec gpoints2,
    arma::mat f
  ) {

  // Set variables
  arma::uword n = x.n_rows;
  arma::vec x1 = x.col(0);
  arma::vec x2 = x.col(1);
  int M1 = gpoints1.n_elem;
  int M2 = gpoints2.n_elem;
  double a1 = gpoints1(0);
  double a2 = gpoints2(0);
  double b1 = gpoints1(M1 - 1);
  double b2 = gpoints2(M2 - 1);
  arma::vec fun = arma::vectorise(f);
  arma::vec est(n, arma::fill::zeros);

  double fx1, fx2, xdelta1, xdelta2, xpos1, xpos2;
  arma::uword i, ix1, ix2, ixmax1, ixmin1, ixmax2, ixmin2, MM1, MM2;

  MM1 = M1;
  MM2 = M2;
  ixmin1 = 0;
  ixmax1 = MM1 - 2;
  ixmin2 = 0;
  ixmax2 = MM2 - 2;
  xdelta1 = (b1 - a1) / (MM1 - 1);
  xdelta2 = (b2 - a2) / (MM2 - 1);

  // assign linear binning weights
  for (i=0; i < n; i++) {
    if(R_FINITE(x1[i]) && R_FINITE(x2[i])) {
      xpos1 = (x1[i] - a1) / xdelta1;
      xpos2 = (x2[i] - a2) / xdelta2;
      ix1 = floor(xpos1);
      ix2 = floor(xpos2);
      fx1 = xpos1 - ix1;
      fx2 = xpos2 - ix2;

      if(ixmin1 <= ix1 && ix1 <= ixmax1 && ixmin2 <= ix2 && ix2 <= ixmax2) {
	est[i] = fun[ix2*MM1 + ix1]*(1-fx1)*(1-fx2) \
               + fun[ix2*MM1 + ix1 + 1]*fx1*(1-fx2) \
               + fun[(ix2+1)*MM1 + ix1]*(1-fx1)*fx2 \
               + fun[(ix2+1)*MM1 + ix1 + 1]*fx1*fx2;
      }
      else if(ix1 == ixmax1 + 1 && ixmin2 <= ix2 && ix2 <= ixmax2) {
        est[i] = fun[ix2*MM1 + ix1]*(1-fx1)*(1-fx2) \
               + fun[(ix2+1)*MM1 + ix1]*(1-fx1)*fx2;
      }
      else if (ixmin1 <= ix1 && ix1 <= ixmax1 && ix2 == ixmax2 + 1) {
	est[i] = fun[ix2*MM1 + ix1]*(1-fx1)*(1-fx2) \
               + fun[ix2*MM1 + ix1 + 1]*fx1*(1-fx2);
      }
      else if (ix1 == ixmax1 + 1 && ix2 == ixmax2 + 1) {
        est[i] = fun[ix2*MM1 + ix1]*(1-fx1)*(1-fx2);
      }
    }
  }

  // Return the estimate
  return est;

}



# ================================================
# FILE: src/utils_progress.h
# ================================================


#include <RcppArmadillo.h>
#include <progress.hpp>
#include <progress_bar.hpp>
#include <R.h>

#ifndef Racmacs__utils_progress__h
#define Racmacs__utils_progress__h

class AcProgressBar: public ProgressBar{

  private:
    int barlength = 100;
    bool report;

  public:

    AcProgressBar(
      int length,
      bool reportprogress
    ){
      _finalized = false;
      barlength = length;
      report = reportprogress;
    }

    ~AcProgressBar() {}

    void display() {
      if(!report) return;
      for(int i=0; i<barlength; i++){
        REprintf("-");
      }
    }

    void update(
      float progress
    ){
      if(!report) return;
      if (_finalized) return;
      int amount_done = barlength*progress;
      REprintf("\r");
      for(int i=0; i<amount_done; i++){
        REprintf("=");
      }
    }

    void end_display() {
      if (_finalized) return;
      _finalized = true;
    }

    void complete(
      char const *msg,
      bool finished = true
    ) {

      if(!report) return;
      if(finished){
        REprintf("\r");
        for(int i=0; i<barlength; i++){
          REprintf("=");
        }
        REprintf("\n");
      }

      REprintf("%s", msg);
      REprintf("\n");

    }

  private:

    bool _finalized;

};

#endif



# ================================================
# FILE: src/utils_transformation.cpp
# ================================================


#include <RcppArmadillo.h>
#include "utils_error.h"

// Resizing transformation to match new dimensions
void ac_set_transformation_dims(
    arma::mat& transformation,
    const arma::uword& dims
){

  if(transformation.n_cols == dims) return;
  arma::mat new_transform(dims, dims, arma::fill::eye);
  new_transform.submat(
    0, 0,
    transformation.n_rows - 1,
    transformation.n_cols - 1
  ) = transformation;
  transformation = new_transform;

}

// Resizing translation to match new dimensions
void ac_set_translation_dims(
    arma::mat& translation,
    const arma::uword& dims
){

  if(translation.n_cols != 1) ac_error("Translation must be an n x 1 matrix");
  if(translation.n_rows == dims) return;
  arma::mat new_translation(dims, 1, arma::fill::zeros);
  new_translation.rows(0, translation.n_rows - 1) = translation;
  translation = new_translation;

}

// Transforming a transformation matrix
void ac_transform_transformation(
    arma::mat& transform,
    arma::mat transformation
){

  arma::uword max_dim = arma::max(
    arma::uvec{
      transform.n_cols,
      transformation.n_cols
    }
  );
  ac_set_transformation_dims(transform, max_dim);
  ac_set_transformation_dims(transformation, max_dim);
  transform = transform * transformation;

}

// Transforming a translation matrix
void ac_transform_translation(
    arma::mat& translate,
    arma::mat transformation
){

  arma::uword max_dim = arma::max(
    arma::uvec{
      translate.n_rows,
      transformation.n_cols
    }
  );
  ac_set_translation_dims(translate, max_dim);
  ac_set_transformation_dims(transformation, max_dim);
  translate = arma::trans( translate.t() * transformation );

}

// Translating a translation matrix
void ac_translate_translation(
    arma::mat& translate,
    arma::mat translation
){

  arma::uword max_dim = arma::max(
    arma::uvec{
      translate.n_rows,
      translation.n_rows
    }
  );
  ac_set_translation_dims(translate, max_dim);
  ac_set_translation_dims(translation, max_dim);
  translate = translate + translation;

}

// Creating a rotation transform matrix
arma::mat ac_rotation_matrix(
    double degrees,
    arma::uword dims,
    arma::uword axis_num = 2
){

  // Check input
  if(dims != 2 && dims != 3) ac_error("Rotation is only supported in 2 or 3 dimensions");
  if(dims == 2 && axis_num != 2) ac_error("3D rotation of 2D coordinates is not supported");

  // Create the rotation matrix
  arma::mat rotmat;
  double radians = arma::datum::pi * degrees / 180.0;

  switch(axis_num) {
  case 0:
    // x axis rotation
    rotmat = {
      { 1, 0, 0 },
      { 0, std::cos(radians), -std::sin(radians) },
      { 0, std::sin(radians), std::cos(radians) }
    };
    break;
  case 1:
    // y axis rotation
    rotmat = {
      { std::cos(radians), 0, std::sin(radians) },
      { 0, 1, 0 },
      { -std::sin(radians), 0, std::cos(radians) }
    };
    break;
  case 2:
    // z axis rotation
    rotmat = {
      { std::cos(radians), -std::sin(radians), 0 },
      { std::sin(radians), std::cos(radians), 0 },
      { 0, 0, 1 }
    };
    break;
  default:
    ac_error("rotation is only supported in the first 3 dimensions, otherwise apply a transformation");
  }

  // Resize to the right number of dimensions (only relevant for trimming 2d)
  // and return the result
  rotmat.resize(dims, dims);
  return rotmat;

}

// Creating a reflection transform matrix
arma::mat ac_reflection_matrix(
    const arma::uword &dims,
    const arma::uword &axis_num
){

  arma::mat rotmat(dims, dims, arma::fill::zeros);
  arma::vec diag(dims);
  diag.fill(-1);
  rotmat.diag() = diag;
  rotmat(axis_num, axis_num) = 1;
  return rotmat;

}


// Creating a scaling matrix
arma::mat ac_scaling_matrix(
    const arma::uword &dims,
    double scaling
){

  arma::mat rotmat(dims, dims, arma::fill::zeros);
  arma::vec diag(dims);
  diag.fill(scaling);
  rotmat.diag() = diag;
  return rotmat;

}



# ================================================
# FILE: src/utils_transformation.h
# ================================================


#include <RcppArmadillo.h>

#ifndef Racmacs__utils_transformation__h
#define Racmacs__utils_transformation__h

// Transforming a transformation matrix
void ac_transform_transformation(
  arma::mat& transform,
  arma::mat transformation
);

// Transforming a translation matrix
void ac_transform_translation(
  arma::mat& translate,
  arma::mat transformation
);

// Translating a translation matrix
void ac_translate_translation(
  arma::mat& translate,
  arma::mat translation
);

// Creating a rotation transform matrix
arma::mat ac_rotation_matrix(
  double degrees,
  arma::uword dims,
  arma::uword axis_num = 2
);

// Creating a reflection transform matrix
arma::mat ac_reflection_matrix(
    const arma::uword &dims,
    const arma::uword &axis_num
);

// Creating a scaling transform matrix
arma::mat ac_scaling_matrix(
    const arma::uword &dims,
    double scaling
);

#endif



# ================================================
# FILE: src/utils.cpp
# ================================================


#include <RcppArmadillo.h>

double rmsd(
  const arma::vec &x
){

  arma::uvec x_finite = arma::find_finite(x);
  if (x_finite.n_elem == 0) {

    return arma::datum::nan;

  } else {

    return std::sqrt(
      arma::mean(
        arma::square(
          x.elem( x_finite )
        )
      )
    );

  }

}

double euc_dist(
  const arma::vec &x1,
  const arma::vec &x2
){

  return std::sqrt(
    arma::sum(arma::square(x2 - x1))
  );

}

void uvec_push(arma::uvec &v, arma::uword value) {
  arma::uvec av(1);
  av.at(0) = value;
  v.insert_rows(v.n_rows, av.row(0));
}

// [[Rcpp::export]]
arma::vec ac_coord_dists(
  arma::mat coords1,
  arma::mat coords2
){

  // Check row dimensions
  if(coords1.n_rows != coords2.n_rows){
    Rf_error("Dimensions of coordinates do not match");
  }

  // Expand coords to match maximum dimensions
  int dims = arma::max( arma::uvec{ coords1.n_cols, coords2.n_cols } );
  coords1.resize(coords1.n_rows, dims);
  coords2.resize(coords2.n_rows, dims);

  // Calculate coordinate distances
  arma::vec dists(coords1.n_rows);
  double dist;
  for(arma::uword i=0; i<coords1.n_rows; i++){
    dist = 0.0;
    for(arma::uword j=0; j<coords1.n_cols; j++){
      dist += std::pow(coords1(i,j) - coords2(i,j), 2);
    }
    dists(i) = std::sqrt(dist);
  }

  // Return distances
  return dists;

}

// Get indices of rows containing NaN somewhere
arma::uvec na_row_indices(
  const arma::mat &X
){

  arma::uvec na_rows = arma::find_nonfinite( X.col(0) );
  return na_rows;

}

// Return a subset of matrix rows, non-matching elements, represented by
// -1 in the subset vector are left as NaN rows.
arma::mat subset_rows(
  const arma::mat &matrix,
  const arma::ivec &subset
){

  // Create matrix of results
  arma::mat submatrix( subset.n_elem, matrix.n_cols );
  submatrix.fill( arma::datum::nan );

  // Cycle through rows
  for(arma::uword i=0; i<subset.n_elem; i++){

    int index = subset(i);
    if(index < 0) continue; // -1 represents no match
    submatrix.row(i) = matrix.row(index);

  }

  // Return the matrix
  return submatrix;

}


// Helper function to get unique rows of a matrix
arma::mat unique_rows(
    const arma::mat& m
){

  arma::uvec ulmt = arma::zeros<arma::uvec>(m.n_rows);

  for (arma::uword i = 0; i < m.n_rows; i++) {
    for (arma::uword j = i + 1; j < m.n_rows; j++) {
      if (
          arma::approx_equal(
            m.row(i),
            m.row(j),
            "absdiff",
            0.001
          )
      ) {
        ulmt(j) = 1;
        break;
      }
    }
  }

  return m.rows(find(ulmt == 0));

}


// Check if openmp is used to run code in parallel
// [[Rcpp::export]]
bool parallel_mode(){

  #if defined(_OPENMP)
    return true;
  #else
    return false;
  #endif

}




# ================================================
# FILE: src/utils.h
# ================================================


#include <RcppArmadillo.h>

#ifndef Racmacs__utils__h
#define Racmacs__utils__h

double rmsd(
    const arma::vec &x
);

double euc_dist(
    const arma::vec &x1,
    const arma::vec &x2
);

arma::vec ac_coord_dists(
    arma::mat coords1,
    arma::mat coords2
);

arma::mat subset_rows(
    const arma::mat &matrix,
    const arma::ivec &subset
);

arma::uvec na_row_indices(
    const arma::mat &X
);

arma::mat unique_rows(
        const arma::mat &m
);

void uvec_push(arma::uvec &v, arma::uword value);

// Template for subsetting a vector
template<typename T>
std::vector<T> subset_vector(
        std::vector<T> vec,
        arma::uvec indices
){

    std::vector<T> subvec(indices.n_elem);
    for (arma::uword i=0; i < indices.n_elem; i++) {
        subvec[i] = vec[indices(i)];
    }
    return subvec;

}

#endif
